{"hash":"58f852aa160927c194b4037f9ecce8b90fab7929","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { format, isNullOrUndefined as isNullOrUndefined$1 } from 'util';\nimport { XMLSerializer, DOMParser } from 'xmldom';\nimport { isNullOrUndefined, isString } from 'is-what';\nimport Tokenizr from 'tokenizr';\n\nclass NgxI18nsupportLibModule {\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NgxI18nsupportLibModule.ɵfac = function NgxI18nsupportLibModule_Factory(t) { return new (t || NgxI18nsupportLibModule)(); };\r\n/** @nocollapse */ /** @nocollapse */ NgxI18nsupportLibModule.ɵmod = /** @pureOrBreakMyCode */ i0.ɵɵdefineNgModule({ type: NgxI18nsupportLibModule });\r\n/** @nocollapse */ /** @nocollapse */ NgxI18nsupportLibModule.ɵinj = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjector({ imports: [[]] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxI18nsupportLibModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [],\r\n                declarations: [],\r\n                exports: []\r\n            }]\r\n    }], null, null); })();\n\n/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n/**\r\n * supported file formats\r\n */\r\nconst FORMAT_XLIFF12 = 'xlf';\r\nconst FORMAT_XLIFF20 = 'xlf2';\r\nconst FORMAT_XMB = 'xmb';\r\nconst FORMAT_XTB = 'xtb';\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nconst FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nconst FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nconst FILETYPE_XMB = 'XMB';\r\nconst FILETYPE_XTB = 'XTB';\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nconst STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nconst STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nconst STATE_FINAL = 'final';\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nconst NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nconst NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\n\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\nclass DOMUtilities {\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    static getFirstElementByTagName(element, tagName) {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    static getElementByTagNameAndId(element, tagName, id) {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    static getElementFollowingSibling(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    static getElementPrecedingSibling(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    static getXMLContent(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    static getPCDATA(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    static replaceContentWithXMLContent(element, pcdata) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    static getPreviousElementSibling(element) {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    static createFollowingSibling(elementNameToCreate, previousSibling) {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    static insertAfter(newElement, previousSibling) {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        }\r\n        else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    static insertBefore(newElement, nextSibling) {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\n\n/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\nconst DEFAULT_INDENT_STRING = '  ';\r\nclass XmlSerializer {\r\n    constructor() {\r\n    }\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document, options) {\r\n        const buf = [];\r\n        let visibleNamespaces = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    { namespace: uri, prefix: null }\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    doSerializeToString(node, options, buf, indentLevel, partOfMixedContent, visibleNamespaces) {\r\n        let child;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode = node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<', nodeName);\r\n                }\r\n                else {\r\n                    this.outputIndented(options, buf, indentLevel, '<', nodeName);\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });\r\n                    }\r\n                    else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({ prefix: '', namespace: attr.value });\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({ prefix: prefix, namespace: uri });\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = elementNode.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({ prefix: prefix, namespace: uri });\r\n                }\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1, partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    }\r\n                    else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                }\r\n                else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                }\r\n                else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                }\r\n                else {\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = node;\r\n                return buf.push('<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n    needNamespaceDefine(node, visibleNamespaces) {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _xmlEncoder(c) {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n    outputIndented(options, buf, indentLevel, ...outputParts) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n    indentationString(options, indentLevel) {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    isMixedContentElement(tagName, options) {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    containsOnlyWhiteSpace(text) {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\nclass AbstractTranslationMessagesFile {\r\n    constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    parseContent(xmlString, path, encoding, optionalMaster) {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n    lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n    warnings() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    numberOfTransUnits() {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfTransUnitsWithMissingId() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    forEachTransUnit(callback) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    transUnitWithId(id) {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    setNewTransUnitTargetPraefix(targetPraefix) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix() {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    setNewTransUnitTargetSuffix(targetSuffix) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix() {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    removeTransUnitWithId(id) {\r\n        const tuNode = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    filename() {\r\n        return this._filename;\r\n    }\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    encoding() {\r\n        return this._encoding;\r\n    }\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    editedContent(beautifyOutput) {\r\n        const options = {};\r\n        if (beautifyOutput === true) {\r\n            options.beautify = true;\r\n            options.indentString = '  ';\r\n            options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        }\r\n        else {\r\n            return result;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\nclass AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        this._element = _element;\r\n        this._id = _id;\r\n        this._translationMessagesFile = _translationMessagesFile;\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile() {\r\n        return this._translationMessagesFile;\r\n    }\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent() {\r\n        return true;\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    sourceContentNormalized() {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    targetState() {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            this.translationMessagesFile().countNumbers();\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceReferences() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetDescriptionAndMeaning() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    checkNotes(newNotes) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    asXmlElement() {\r\n        return this._element;\r\n    }\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    translate(translation) {\r\n        let translationNative;\r\n        if (isString(translation)) {\r\n            translationNative = translation;\r\n        }\r\n        else {\r\n            translationNative = translation.asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    isICUMessage(message) {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\nvar ParsedMessagePartType;\r\n(function (ParsedMessagePartType) {\r\n    ParsedMessagePartType[ParsedMessagePartType[\"TEXT\"] = 0] = \"TEXT\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"PLACEHOLDER\"] = 1] = \"PLACEHOLDER\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"START_TAG\"] = 2] = \"START_TAG\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"END_TAG\"] = 3] = \"END_TAG\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"EMPTY_TAG\"] = 4] = \"EMPTY_TAG\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"ICU_MESSAGE\"] = 5] = \"ICU_MESSAGE\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"ICU_MESSAGE_REF\"] = 6] = \"ICU_MESSAGE_REF\";\r\n})(ParsedMessagePartType || (ParsedMessagePartType = {}));\r\nclass ParsedMessagePart {\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\nclass ParsedMessagePartText extends ParsedMessagePart {\r\n    constructor(text) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n    asDisplayString(format) {\r\n        return this.text;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\nclass ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n    constructor(index, disp) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n    asDisplayString(format) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    index() {\r\n        return this._index;\r\n    }\r\n    disp() {\r\n        return this._disp;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\nclass ParsedMessagePartStartTag extends ParsedMessagePart {\r\n    constructor(tagname, idcounter) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n    asDisplayString(format) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        }\r\n        else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n    tagName() {\r\n        return this._tagname;\r\n    }\r\n    idCounter() {\r\n        return this._idcounter;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\nclass ParsedMessagePartEndTag extends ParsedMessagePart {\r\n    constructor(tagname) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n    asDisplayString(format) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n    tagName() {\r\n        return this._tagname;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n// Tokens\r\nconst TEXT$1 = 'TEXT';\r\nconst CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nconst CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nconst COMMA = 'COMMA';\r\nconst PLURAL = 'PLURAL';\r\nconst SELECT = 'SELECT';\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\nclass ICUMessageTokenizer {\r\n    getLexer() {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT$1) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT$1, plaintext);\r\n                    plaintext = '';\r\n                }\r\n                else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT$1, plaintext);\r\n            }\r\n        });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            }\r\n            else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            }\r\n            else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT$1);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n            else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                }\r\n                else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT$1, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            }\r\n            else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT$1);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT$1);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT$1);\r\n        return lexer;\r\n    }\r\n    containsNonWhiteSpace(text) {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    tokenize(normalizedMessage) {\r\n        const lexer = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n    input(normalizedMessage) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n    next() {\r\n        return this.lexer.token();\r\n    }\r\n    peek() {\r\n        return this.lexer.peek();\r\n    }\r\n}\n\nclass MessageCategory {\r\n    constructor(_category, _message) {\r\n        this._category = _category;\r\n        this._message = _message;\r\n    }\r\n    getCategory() {\r\n        return this._category;\r\n    }\r\n    getMessageNormalized() {\r\n        return this._message;\r\n    }\r\n}\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nclass ICUMessage {\r\n    constructor(_parser, isPluralMessage) {\r\n        this._parser = _parser;\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n    addCategory(category, message) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    asNativeString() {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage() {\r\n        return this._isPluralMessage;\r\n    }\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage() {\r\n        return !this._isPluralMessage;\r\n    }\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories() {\r\n        return this._categories;\r\n    }\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation) {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories = new Set();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage;\r\n            const translationForCategory = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            }\r\n            else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(translationForCategory, null);\r\n            }\r\n            else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)', categoryName));\r\n                }\r\n                else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    const translatedMessage = this._parser.parseNormalizedString(translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    checkValidPluralCategory(categoryName) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\n\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\nclass ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n    constructor(icuMessageText, _parser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        this._parser = _parser;\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText) {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n    asDisplayString(displayFormat) {\r\n        return '<ICU-Message/>';\r\n    }\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    getICUMessage() {\r\n        return this._message;\r\n    }\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    parseICUMessage(text) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT$1); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        }\r\n        else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT$1).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT$1).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    looksLikeICUMessage(text) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT$1); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        }\r\n        catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    expectNext(tokentype) {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)', tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    parseNativeSubMessage(message) {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\nclass ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n    constructor(index, disp) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n    asDisplayString(format) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n    index() {\r\n        return this._index;\r\n    }\r\n    disp() {\r\n        return this._disp;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\nclass ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n    constructor(tagname, idcounter) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n    asDisplayString(format) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        }\r\n        else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n    tagName() {\r\n        return this._tagname;\r\n    }\r\n    idCounter() {\r\n        return this._idcounter;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nclass ParsedMessage {\r\n    constructor(parser, sourceMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser() {\r\n        return this._parser;\r\n    }\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString) {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(normalizedString, this);\r\n        }\r\n        else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")', normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation) {\r\n        const icuMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")', icuTranslation, this.asNativeString()));\r\n        }\r\n        else {\r\n            const translatedICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString) {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    asDisplayString(displayFormat) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString() {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        }\r\n        else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    validate() {\r\n        let hasErrors = false;\r\n        const errors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings() {\r\n        let hasWarnings = false;\r\n        const warnings = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n    /**\r\n     * Test wether this message is an ICU message.\r\n     * @return true, if it is an ICU message.\r\n     */\r\n    isICUMessage() {\r\n        return this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE;\r\n    }\r\n    /**\r\n     * Test wether this message contains an ICU message reference.\r\n     * ICU message references are something like <x ID=\"ICU\"../>.\r\n     * @return true, if there is an ICU message reference in the message.\r\n     */\r\n    containsICUMessageRef() {\r\n        return this._parts.findIndex(part => part.type === ParsedMessagePartType.ICU_MESSAGE_REF) >= 0;\r\n    }\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    getICUMessage() {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkPlaceholderAdded() {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkPlaceholderRemoved() {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkICUMessageRefAdded() {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkICUMessageRefRemoved() {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    allPlaceholders() {\r\n        const result = new Set();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = part.index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    getPlaceholderDisp(index) {\r\n        let placeHolder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart = part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    allICUMessageRefs() {\r\n        const result = new Set();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = part.index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    getICUMessageRefDisp(index) {\r\n        let icuMessageRefPart = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart = part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkTagAdded() {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        }\r\n        else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkTagRemoved() {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        }\r\n        else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    allTags() {\r\n        const result = new Set();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = part.tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    parts() {\r\n        return this._parts;\r\n    }\r\n    setXmlRepresentation(xmlRepresentation) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n    addText(text) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n    addPlaceholder(index, disp) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n    addStartTag(tagname, idcounter) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n    addEndTag(tagname) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")', tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n    addEmptyTag(tagname, idcounter) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n    addICUMessageRef(index, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n    addICUMessage(text) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    calculateOpenTagName() {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push(part.tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = part.tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")', tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\n\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n// Tokens\r\nconst TEXT = 'TEXT';\r\nconst START_TAG = 'START_TAG';\r\nconst END_TAG = 'END_TAG';\r\nconst EMPTY_TAG = 'EMPTY_TAG';\r\nconst PLACEHOLDER = 'PLACEHOLDER';\r\nconst ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nconst ICU_MESSAGE = 'ICU_MESSAGE';\r\nclass ParsedMesageTokenizer {\r\n    getLexer() {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, { text: plaintext });\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, { text: plaintext });\r\n            }\r\n        });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, { name: match[1], idcounter: idcount });\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, { name: match[1], idcounter: idcount });\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, { name: match[1] });\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, { idcounter: parseInt(match[1], 10) });\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, { idcounter: parseInt(match[1], 10) });\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, { message: match[0] });\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n    tokenize(normalizedMessage) {\r\n        const lexer = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nclass AbstractMessageParser {\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXML(xmlElement, sourceMessage) {\r\n        const message = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString, sourceMessage) {\r\n        const doc = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement = doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    addPartsOfNodeToMessage(node, message, includeSelf) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                }\r\n                catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(node, message);\r\n        }\r\n    }\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    getICUMessageText(node) {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(node);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    isICUMessageStart(text) {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n        //        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    parseNormalizedString(normalizedString, sourceMessage) {\r\n        const message = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens;\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        }\r\n        catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token) => {\r\n            let disp = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString, sourceMessage) {\r\n        const message = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    parseIdCountFromName(name) {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        }\r\n        else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    createXmlRepresentation(message) {\r\n        const root = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n    createXmlRepresentationOfTextPart(part, rootElem) {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\nclass TagMapping {\r\n    getStartTagPlaceholderName(tag, id) {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n    getCloseTagPlaceholderName(tag) {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n    getEmptyTagPlaceholderName(tag, id) {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n    getCtypeForTag(tag) {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n    getTagnameFromStartTagPlaceholderName(placeholderName) {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        }\r\n        else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n    getTagnameFromCloseTagPlaceholderName(placeholderName) {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        }\r\n        else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    isEmptyTagPlaceholderName(placeholderName) {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        }\r\n        else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    getTagnameFromEmptyTagPlaceholderName(placeholderName) {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        }\r\n        else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    stripCounter(placeholderName) {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    counterString(id) {\r\n        if (id === 0) {\r\n            return '';\r\n        }\r\n        else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nclass XliffMessageParser extends AbstractMessageParser {\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    processStartElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            }\r\n            else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            }\r\n            else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n            else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            }\r\n            else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    processEndElement(elementNode, message) {\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    parsePlaceholderIndexFromId(id) {\r\n        let indexString = '';\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    parseICUMessageRefIndexFromId(id) {\r\n        let indexString = '';\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    addXmlRepresentationToRoot(message, rootElem) {\r\n        message.parts().forEach((part) => {\r\n            let child;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart(part, rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfStartTagPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEndTagPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEmptyTagPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfPlaceholderPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\nclass XliffTransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n    sourceContent() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new XliffMessageParser();\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    nativeTargetState() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        switch (state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' + state);\r\n        }\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        switch (nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({ sourcefile: sourcefile, linenumber: linenumber });\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n    removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    description() {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    findNoteElementWithFromAttribute(attrValue) {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    findAllAdditionalNoteElements() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    createNoteElementWithFromAttribute(fromAttrValue, content) {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    removeNoteElementWithFromAttribute(attrValue) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    meaning() {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    notes() {\r\n        const noteElememts = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    setNotes(newNotes) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        const element = this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        }\r\n        else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        }\r\n        else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\nclass XliffFile extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString, path, encoding) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        }\r\n        else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s', path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = foreignTransUnit.cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        }\r\n        else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            }\r\n            else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        }\r\n        else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit) => {\r\n            transUnit.useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nclass XmbMessageParser extends AbstractMessageParser {\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    processStartElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            }\r\n            else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            }\r\n            else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            }\r\n            else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            }\r\n            else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        }\r\n        else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    getICUMessageText(node) {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || child.tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                }\r\n                else {\r\n                    return messageText;\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    processEndElement(elementNode, message) {\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    parsePlaceholderIndexFromName(name) {\r\n        let indexString = '';\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    parseICUMessageIndexFromName(name) {\r\n        let indexString = '';\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    parseTagnameFromPhElement(phElement) {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            }\r\n            else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    addXmlRepresentationToRoot(message, rootElem) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n    createXmlRepresentationOfPart(part, rootElem) {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart(part, rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart(part, rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart(part, rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart(part, rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart(part, rootElem);\r\n        }\r\n    }\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfStartTagPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEndTagPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEmptyTagPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfPlaceholderPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\nclass XmbTransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    static parseSourceAndPos(sourceAndPos) {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n    static parseLineNumber(lineNumberString) {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    sourceContent() {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        // not supported\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new XmbMessageParser();\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    nativeTargetState() {\r\n        return null; // not supported in xmb\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        return state;\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        return nativeState;\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        // not supported for xmb\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n    removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    description() {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    meaning() {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetDescriptionAndMeaning() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    notes() {\r\n        return [];\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    setNotes(newNotes) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        return this;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        // do nothing\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n}\n\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nconst XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\nclass XmbFile extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(_translationMessageFileFactory, xmlString, path, encoding) {\r\n        super();\r\n        this._translationMessageFileFactory = _translationMessageFileFactory;\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XMB;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XMB;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['message'];\r\n    }\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    guessLanguageFromFilename() {\r\n        if (this._filename) {\r\n            const parts = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        const translationbundleXMLSource = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XTB, translationbundleXMLSource, filename, this.encoding(), { xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding() });\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nclass Xliff2MessageParser extends AbstractMessageParser {\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    processStartElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            }\r\n            else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                }\r\n                else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            }\r\n            else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                }\r\n                else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            }\r\n            else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            }\r\n            else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            }\r\n            else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        }\r\n        else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    processEndElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    tagNameFromPCElement(pcNode) {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    addXmlRepresentationToRoot(message, rootElem) {\r\n        const stack = [{ element: rootElem, tagName: 'root' }];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfTextPart(part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfPlaceholderPart(part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfICUMessageRefPart(part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({ element: newTagElem, tagName: part.tagName() });\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = part.tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    createXmlRepresentationOfStartTagPart(part, rootElem, id) {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEndTagPart(part, rootElem) {\r\n        // not used\r\n        return null;\r\n    }\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    createXmlRepresentationOfEmptyTagPart(part, rootElem, id) {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n    getTypeForTag(tag) {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    createXmlRepresentationOfPlaceholderPart(part, rootElem, id) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\nclass Xliff2TransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n    sourceContent() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new Xliff2MessageParser();\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    nativeTargetState() {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        switch (state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' + state);\r\n        }\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        switch (nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    parseSourceAndPos(sourceAndPos) {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n    parseLineNumber(lineNumberString) {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined$1(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined$1(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n    removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    description() {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined$1(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined$1(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    findNoteElementWithCategoryAttribute(attrValue) {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    findAllAdditionalNoteElements() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    createNoteElementWithCategoryAttribute(attrValue, content) {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined$1(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n    removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    removeNoteElementWithCategoryAttribute(attrValue) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    meaning() {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined$1(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined$1(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    notes() {\r\n        const noteElememts = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    setNotes(newNotes) {\r\n        if (!isNullOrUndefined$1(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined$1(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        const element = this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        }\r\n        else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            }\r\n            else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\nclass Xliff2File extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString, path, encoding) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        }\r\n        else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s', path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = foreignTransUnit.cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        }\r\n        else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            }\r\n            else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        }\r\n        else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit) => {\r\n            transUnit.useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\nclass XtbTransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile, _sourceTransUnitFromMaster) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    sourceContent() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    nativeTargetState() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            }\r\n            else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        return state;\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        return nativeState;\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceReferences() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    description() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    meaning() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetDescriptionAndMeaning() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    notes() {\r\n        return [];\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    setNotes(newNotes) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        return this;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        // do nothing\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined$1(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\nclass XtbFile extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(_translationMessageFileFactory, xmlString, path, encoding, optionalMaster) {\r\n        super();\r\n        this._translationMessageFileFactory = _translationMessageFileFactory;\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding, optionalMaster) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XMB, optionalMaster.xmlContent, optionalMaster.path, optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format('%s trans units found in master, but this file has %s. Check if it is the correct master', numberInMaster, myNumber));\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, masterUnit));\r\n        }\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XTB;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XTB;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['translation'];\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = foreignTransUnit.cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!foreignTransUnit.isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        }\r\n        else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            }\r\n            else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        }\r\n        else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\n\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nclass TranslationMessagesFileFactory {\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    static fromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster) {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    static fromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster) {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster) {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n    }\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster) {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            }\r\n            catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n}\n\n/*\r\n * Public API Surface of ngx-i18nsupport-lib\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { FILETYPE_XLIFF12, FILETYPE_XLIFF20, FILETYPE_XMB, FILETYPE_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB, NORMALIZATION_FORMAT_DEFAULT, NORMALIZATION_FORMAT_NGXTRANSLATE, NgxI18nsupportLibModule, STATE_FINAL, STATE_NEW, STATE_TRANSLATED, TranslationMessagesFileFactory };\n//# sourceMappingURL=ngx-i18nsupport-ngx-i18nsupport-lib.mjs.map\n","map":{"version":3,"file":"ngx-i18nsupport-ngx-i18nsupport-lib.mjs","sources":["../../../projects/ngx-i18nsupport-lib/src/lib/ngx-i18nsupport-lib.module.ts","../../../projects/ngx-i18nsupport-lib/src/api/constants.ts","../../../projects/ngx-i18nsupport-lib/src/impl/dom-utilities.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xml-serializer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-translation-messages-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-text.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-placeholder.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-start-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-end-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/icu-message-tokenizer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/icu-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-icu-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-icu-message-ref.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-empty-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-tokenizer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/tag-mapping.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xtb-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xtb-file.ts","../../../projects/ngx-i18nsupport-lib/src/api/translation-messages-file-factory.ts","../../../projects/ngx-i18nsupport-lib/src/public_api.ts","../../../projects/ngx-i18nsupport-lib/src/ngx-i18nsupport-ngx-i18nsupport-lib.ts"],"sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class NgxI18nsupportLibModule { }\r\n","/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n\r\n/**\r\n * supported file formats\r\n */\r\nexport const FORMAT_XLIFF12 = 'xlf';\r\nexport const FORMAT_XLIFF20 = 'xlf2';\r\nexport const FORMAT_XMB = 'xmb';\r\nexport const FORMAT_XTB = 'xtb';\r\n\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nexport const FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nexport const FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nexport const FILETYPE_XMB = 'XMB';\r\nexport const FILETYPE_XTB = 'XTB';\r\n\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nexport const STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nexport const STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nexport const STATE_FINAL = 'final';\r\n\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\r\n","import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n","/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = elementNode.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {isNullOrUndefined} from 'is-what';\r\nimport {DOMParser} from 'xmldom';\r\nimport {XmlSerializer, XmlSerializerOptions} from './xml-serializer';\r\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\n\r\nexport abstract class AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    protected _filename: string;\r\n\r\n    protected _encoding: BufferEncoding ;\r\n\r\n    protected _parsedDocument: Document;\r\n\r\n    protected _fileEndsWithEOL: boolean;\r\n\r\n    // trans-unit elements and their id from the file\r\n    protected transUnits: ITransUnit[];\r\n\r\n    protected _warnings: string[];\r\n\r\n    protected _numberOfTransUnitsWithMissingId: number;\r\n\r\n    protected _numberOfUntranslatedTransUnits: number;\r\n\r\n    protected _numberOfReviewedTransUnits: number;\r\n\r\n    protected targetPraefix: string;\r\n\r\n    protected targetSuffix: string;\r\n\r\n    protected constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    protected parseContent(\r\n        xmlString: string,\r\n        path: string, encoding: BufferEncoding ,\r\n        optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  })\r\n        : void {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n\r\n    abstract i18nFormat(): string;\r\n\r\n    abstract fileType(): string;\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected abstract elementsWithMixedContent(): string[];\r\n\r\n    /**\r\n     * Read all trans units from xml content.\r\n     * Puts the found units into transUnits.\r\n     * Puts warnings for missing ids.\r\n     */\r\n    protected abstract initializeTransUnits();\r\n\r\n    protected lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    public countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu: ITransUnit) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n\r\n    public warnings(): string[] {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    public numberOfTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    public numberOfTransUnitsWithMissingId(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    abstract sourceLanguage(): string;\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    abstract targetLanguage(): string;\r\n\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    public forEachTransUnit(callback: ((transunit: ITransUnit) => void)) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public transUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Edit functions following her\r\n     */\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    abstract setSourceLanguage(language: string);\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    abstract setTargetLanguage(language: string);\r\n\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    public setNewTransUnitTargetPraefix(targetPraefix: string) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix(): string {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    public setNewTransUnitTargetSuffix(targetSuffix: string) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix(): string {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    abstract importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit;\r\n\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    public removeTransUnitWithId(id: string) {\r\n        const tuNode: Node = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    public filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    public encoding(): BufferEncoding {\r\n        return this._encoding;\r\n    }\r\n\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public editedContent(beautifyOutput?: boolean): string {\r\n        const options: XmlSerializerOptions = {};\r\n        if (beautifyOutput === true) {\r\n           options.beautify = true;\r\n           options.indentString = '  ';\r\n           options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    abstract createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile;\r\n}\r\n","import {STATE_TRANSLATED, ITranslationMessagesFile, INormalizedMessage, ITransUnit, INote} from './internalapi';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {isNullOrUndefined, isString} from 'is-what';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\n\r\nexport abstract class AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceContentNormalized: ParsedMessage;\r\n\r\n    protected constructor(protected _element: Element,\r\n                          protected _id: string,\r\n                          protected _translationMessagesFile: ITranslationMessagesFile) {\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile(): ITranslationMessagesFile {\r\n        return this._translationMessagesFile;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract sourceContent(): string;\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    abstract setSourceContent(newContent: string);\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public sourceContentNormalized(): ParsedMessage {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    abstract createSourceContentNormalized(): ParsedMessage;\r\n\r\n    /**\r\n     * The translated value.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract targetContent(): string;\r\n\r\n    /**\r\n     * The translated value as normalized message.\r\n     * All placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    abstract targetContentNormalized(): INormalizedMessage;\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    abstract nativeTargetState(): string;\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    public targetState(): string {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected abstract mapStateToNativeState(state: string): string;\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract mapNativeStateToState(nativeState: string): string;\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract setNativeTargetState(nativeState: string);\r\n\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState: string) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            (<AbstractTranslationMessagesFile> this.translationMessagesFile()).countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    abstract sourceReferences(): {sourcefile: string, linenumber: number}[];\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    abstract setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]);\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     */\r\n    abstract description(): string;\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     */\r\n    abstract meaning(): string;\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    abstract setDescription(description: string);\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    abstract setMeaning(meaning: string);\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    abstract notes(): INote[];\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    abstract supportsSetNotes(): boolean;\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains descpription or meaning as from attribute.\r\n     */\r\n    abstract setNotes(newNotes: INote[]);\r\n\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    protected checkNotes(newNotes: INote[]) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    public asXmlElement(): Element {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    abstract cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit;\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    abstract useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean);\r\n\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    public translate(translation: string | INormalizedMessage) {\r\n        let translationNative: string;\r\n        if (isString(translation)) {\r\n            translationNative = <string> translation;\r\n        } else {\r\n            translationNative = (<INormalizedMessage> translation).asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected abstract messageParser(): AbstractMessageParser;\r\n\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    public isICUMessage(message: string): boolean {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected abstract translateNative(translation: string);\r\n}\r\n","/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\n\r\nexport enum ParsedMessagePartType {\r\n    TEXT,\r\n    PLACEHOLDER,\r\n    START_TAG,\r\n    END_TAG,\r\n    EMPTY_TAG,\r\n    ICU_MESSAGE,\r\n    ICU_MESSAGE_REF\r\n}\r\n\r\nexport abstract class ParsedMessagePart {\r\n\r\n    constructor(public type: ParsedMessagePartType) {\r\n\r\n    }\r\n\r\n    /**\r\n     * String representation of the part.\r\n     * @param format optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public abstract asDisplayString(format?: string): string;\r\n\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\n\r\nexport class ParsedMessagePartText extends ParsedMessagePart {\r\n\r\n    private text: string;\r\n\r\n    constructor(text: string) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return this.text;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\n\r\nexport class ParsedMessagePartStartTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\n\r\nexport class ParsedMessagePartEndTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n\r\n    constructor(tagname: string) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n}\r\n","import Tokenizr from 'tokenizr';\r\n\r\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nexport const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nexport const COMMA = 'COMMA';\r\nexport const PLURAL = 'PLURAL';\r\nexport const SELECT = 'SELECT';\r\n\r\nexport interface ICUToken {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\n\r\nexport class ICUMessageTokenizer {\r\n    private lexer: Tokenizr;\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                } else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT, plaintext);\r\n            }\r\n         });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            } else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            } else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            } else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                } else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            } else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    private containsNonWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): ICUToken[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n    input(normalizedMessage: string) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n\r\n    next(): ICUToken {\r\n        return this.lexer.token();\r\n    }\r\n\r\n    peek(): ICUToken {\r\n        return this.lexer.peek();\r\n    }\r\n}\r\n","import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined, isString} from 'is-what';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    const translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\n\r\nexport class ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {INormalizedMessage, ValidationErrors} from '../api/i-normalized-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from 'is-what';\r\nimport {IICUMessage, IICUMessageTranslation} from '../api/i-icu-message';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ICUMessage} from './icu-message';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nexport class ParsedMessage implements INormalizedMessage {\r\n\r\n    /**\r\n     * Parser that created this message (determines the native format).\r\n     */\r\n    private _parser: IMessageParser;\r\n\r\n    /**\r\n     * The message where this one stems from as translation.\r\n     * Optional, set only for messages created by calling translate.\r\n     */\r\n    private sourceMessage: ParsedMessage;\r\n\r\n    /**\r\n     * The parts of the message.\r\n     */\r\n    private _parts: ParsedMessagePart[];\r\n\r\n    /**\r\n     * messages xml representation.\r\n     */\r\n    private _xmlRepresentation: Element;\r\n\r\n    constructor(parser: IMessageParser, sourceMessage: ParsedMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser(): IMessageParser {\r\n        return this._parser;\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString: string): INormalizedMessage {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(<string> normalizedString, this);\r\n        } else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")',\r\n                normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation: IICUMessageTranslation): INormalizedMessage {\r\n        const icuMessage: IICUMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")',\r\n                icuTranslation,  this.asNativeString()));\r\n        } else {\r\n            const translatedICUMessage: IICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public asDisplayString(displayFormat?: string) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString(): string {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        } else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    public validate(): ValidationErrors | null {\r\n        let hasErrors = false;\r\n        const errors: ValidationErrors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings(): ValidationErrors | null {\r\n        let hasWarnings = false;\r\n        const warnings: ValidationErrors = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message is an ICU message.\r\n     * @return true, if it is an ICU message.\r\n     */\r\n    isICUMessage(): boolean {\r\n        return this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message contains an ICU message reference.\r\n     * ICU message references are something like <x ID=\"ICU\"../>.\r\n     * @return true, if there is an ICU message reference in the message.\r\n     */\r\n    containsICUMessageRef(): boolean {\r\n        return this._parts.findIndex(part => part.type === ParsedMessagePartType.ICU_MESSAGE_REF) >= 0;\r\n    }\r\n\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = <ParsedMessagePartICUMessage> this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderRemoved(): any {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefRemoved(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    private allPlaceholders(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = (<ParsedMessagePartPlaceholder> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    public getPlaceholderDisp(index: number): string {\r\n        let placeHolder: ParsedMessagePartPlaceholder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart: ParsedMessagePartPlaceholder = <ParsedMessagePartPlaceholder> part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    private allICUMessageRefs(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = (<ParsedMessagePartICUMessageRef> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    public getICUMessageRefDisp(index: number): string {\r\n        let icuMessageRefPart: ParsedMessagePartICUMessageRef = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart: ParsedMessagePartICUMessageRef = <ParsedMessagePartICUMessageRef> part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagAdded(): any {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagRemoved(): any {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    private allTags(): Set<string> {\r\n        const result = new Set<string>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = (<ParsedMessagePartStartTag> part).tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    public parts(): ParsedMessagePart[] {\r\n        return this._parts;\r\n    }\r\n\r\n    setXmlRepresentation(xmlRepresentation: Element) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n\r\n    addText(text: string) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n\r\n    addPlaceholder(index: number, disp: string) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n\r\n    addStartTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n\r\n    addEndTag(tagname: string) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n\r\n    addEmptyTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n\r\n    addICUMessageRef(index: number, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n\r\n    addICUMessage(text: string) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    private calculateOpenTagName(): string {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push((<ParsedMessagePartStartTag> part).tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                            tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\r\n","import Tokenizr from 'tokenizr';\r\nimport {isNullOrUndefined} from 'is-what';\r\n\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const START_TAG = 'START_TAG';\r\nexport const END_TAG = 'END_TAG';\r\nexport const EMPTY_TAG = 'EMPTY_TAG';\r\nexport const PLACEHOLDER = 'PLACEHOLDER';\r\nexport const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nexport const ICU_MESSAGE = 'ICU_MESSAGE';\r\n\r\nexport interface Token {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\nexport class ParsedMesageTokenizer {\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n            }\r\n         });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, {name: match[1], idcounter: idcount});\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, {name: match[1], idcounter: idcount});\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, {name: match[1]});\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, {idcounter: parseInt(match[1], 10)});\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, {idcounter: parseInt(match[1], 10)});\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, {message: match[0]});\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): Token[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n}\r\n","import {ParsedMessage} from './parsed-message';\r\nimport {\r\n    EMPTY_TAG,\r\n    END_TAG, ICU_MESSAGE, ICU_MESSAGE_REF, ParsedMesageTokenizer, PLACEHOLDER, START_TAG, TEXT,\r\n    Token\r\n} from './parsed-message-tokenizer';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {DOMParser} from 'xmldom';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from 'is-what';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nexport abstract class AbstractMessageParser implements IMessageParser {\r\n\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    public createNormalizedMessageFromXML(xmlElement: Element, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const doc: Document = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement: Element = <Element> doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    private addPartsOfNodeToMessage(node: Node, message: ParsedMessage, includeSelf: boolean) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(<Element> node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                } catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(<Element> node, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(<Element> node);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    public isICUMessageStart(text: string): boolean {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n//        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n\r\n    /**\r\n     * Handle this node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected abstract processStartElement(elementNode: Element, message: ParsedMessage): boolean;\r\n\r\n    /**\r\n     * Handle end of this node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected abstract processEndElement(elementNode: Element, message: ParsedMessage);\r\n\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    public parseNormalizedString(normalizedString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens: Token[];\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        } catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token: Token) => {\r\n            let disp: string = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    protected parseIdCountFromName(name: string): number {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        } else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    protected createXmlRepresentation(message: ParsedMessage): Element {\r\n        const root: Document = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem: Element = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n\r\n    protected abstract addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element);\r\n\r\n    protected createXmlRepresentationOfTextPart(part: ParsedMessagePartText, rootElem: Element): Node {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node;\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node;\r\n}\r\n","/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\n\r\nexport class TagMapping {\r\n\r\n    public getStartTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n\r\n    public getCloseTagPlaceholderName(tag: string): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n\r\n    public getEmptyTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName =  TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n\r\n    public getCtypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n\r\n    public getTagnameFromStartTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public getTagnameFromCloseTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public isEmptyTagPlaceholderName(placeholderName: string): boolean {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public getTagnameFromEmptyTagPlaceholderName(placeholderName: string): string {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    private stripCounter(placeholderName: string): string {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    private counterString(id: number) {\r\n        if (id === 0) {\r\n            return '';\r\n        } else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nexport class XliffMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            } else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            } else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            } else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            } else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    private parsePlaceholderIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageRefIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            let child: Node;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XliffMessageParser} from './xliff-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'is-what';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\n\r\nexport class XliffTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XliffMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({sourcefile: sourcefile, linenumber: linenumber});\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n           if (isNullOrUndefined(noteElem)) {\r\n               // create it\r\n               noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n           } else {\r\n               DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n           }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithFromAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithFromAttribute(fromAttrValue: string, content: string): Element {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithFromAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n     }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        } else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF12, FILETYPE_XLIFF12} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {XliffTransUnit} from './xliff-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class XliffFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: BufferEncoding ) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ): XliffFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n         return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nexport class XmbMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            } else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        } else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || (<Element> child).tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(<Element> node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource: RegExp = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                } else {\r\n                    return messageText;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parsePlaceholderIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    private parseTagnameFromPhElement(phElement: Element): string {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            } else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected createXmlRepresentationOfPart(part: ParsedMessagePart, rootElem: Element): Node {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\r\n","import {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\n\r\nexport class XmbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    private static parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private static parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    public sourceContent(): string {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem: RegExp = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // not supported\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    public nativeTargetState(): string {\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // not supported for xmb\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos: string = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    public description(): string {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XMB, FILETYPE_XMB, FORMAT_XTB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {XmbTransUnit} from './xmb-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\n\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nexport const XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\n\r\nexport class XmbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(\r\n        private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n        xmlString: string, path: string, encoding: BufferEncoding ) {\r\n\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ): XmbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XMB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XMB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['message'];\r\n    }\r\n\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    private guessLanguageFromFilename(): string {\r\n        if (this._filename) {\r\n            const parts: string[] = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationbundleXMLSource =\r\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n            FORMAT_XTB,\r\n            translationbundleXMLSource, filename, this.encoding(),\r\n            {xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding()});\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF20, FILETYPE_XLIFF20} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {Xliff2TransUnit} from './xliff2-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class Xliff2File extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: BufferEncoding ) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ): Xliff2File {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XTB, FILETYPE_XTB, FORMAT_XMB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {XtbTransUnit} from './xtb-trans-unit';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\n\r\nexport class XtbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    // attached master file, if any\r\n    // used as source to determine state ...\r\n    private _masterFile: ITranslationMessagesFile; // an xmb-file\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n                xmlString: string, path: string, encoding: BufferEncoding ,\r\n                optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ,\r\n                                  optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  }): XtbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n                    FORMAT_XMB,\r\n                    optionalMaster.xmlContent,\r\n                    optionalMaster.path,\r\n                    optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format(\r\n                        '%s trans units found in master, but this file has %s. Check if it is the correct master',\r\n                        numberInMaster, myNumber));\r\n                }\r\n            } catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit: ITransUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, <AbstractTransUnit> masterUnit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XTB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XTB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['translation'];\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!(<AbstractTransUnit> foreignTransUnit).isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: BufferEncoding ,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: BufferEncoding }): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: BufferEncoding ,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: BufferEncoding }): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: BufferEncoding ,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: BufferEncoding ,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n","/*\r\n * Public API Surface of ngx-i18nsupport-lib\r\n */\r\n\r\n// The module is here only because ng-packagr needs it\r\nexport * from './lib/ngx-i18nsupport-lib.module';\r\nexport * from './api';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["TEXT","isNullOrUndefined"],"mappings":"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"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { format, isNullOrUndefined as isNullOrUndefined$1 } from 'util';\nimport { XMLSerializer, DOMParser } from 'xmldom';\nimport { isNullOrUndefined, isString } from 'is-what';\nimport Tokenizr from 'tokenizr';\n\nclass NgxI18nsupportLibModule {\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NgxI18nsupportLibModule.ɵfac = function NgxI18nsupportLibModule_Factory(t) { return new (t || NgxI18nsupportLibModule)(); };\r\n/** @nocollapse */ /** @nocollapse */ NgxI18nsupportLibModule.ɵmod = /** @pureOrBreakMyCode */ i0.ɵɵdefineNgModule({ type: NgxI18nsupportLibModule });\r\n/** @nocollapse */ /** @nocollapse */ NgxI18nsupportLibModule.ɵinj = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjector({ imports: [[]] });\r\n(function () {\r\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxI18nsupportLibModule, [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [],\r\n                    declarations: [],\r\n                    exports: []\r\n                }]\r\n        }], null, null);\r\n})();\n\n/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n/**\r\n * supported file formats\r\n */\r\nconst FORMAT_XLIFF12 = 'xlf';\r\nconst FORMAT_XLIFF20 = 'xlf2';\r\nconst FORMAT_XMB = 'xmb';\r\nconst FORMAT_XTB = 'xtb';\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nconst FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nconst FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nconst FILETYPE_XMB = 'XMB';\r\nconst FILETYPE_XTB = 'XTB';\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nconst STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nconst STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nconst STATE_FINAL = 'final';\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nconst NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nconst NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\n\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\nclass DOMUtilities {\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    static getFirstElementByTagName(element, tagName) {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    static getElementByTagNameAndId(element, tagName, id) {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    static getElementFollowingSibling(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    static getElementPrecedingSibling(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    static getXMLContent(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    static getPCDATA(element) {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    static replaceContentWithXMLContent(element, pcdata) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    static getPreviousElementSibling(element) {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    static createFollowingSibling(elementNameToCreate, previousSibling) {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    static insertAfter(newElement, previousSibling) {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        }\r\n        else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    static insertBefore(newElement, nextSibling) {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\n\n/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\nconst DEFAULT_INDENT_STRING = '  ';\r\nclass XmlSerializer {\r\n    constructor() {\r\n    }\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document, options) {\r\n        const buf = [];\r\n        let visibleNamespaces = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    { namespace: uri, prefix: null }\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    doSerializeToString(node, options, buf, indentLevel, partOfMixedContent, visibleNamespaces) {\r\n        let child;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode = node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<', nodeName);\r\n                }\r\n                else {\r\n                    this.outputIndented(options, buf, indentLevel, '<', nodeName);\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });\r\n                    }\r\n                    else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({ prefix: '', namespace: attr.value });\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({ prefix: prefix, namespace: uri });\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = elementNode.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({ prefix: prefix, namespace: uri });\r\n                }\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1, partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    }\r\n                    else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                }\r\n                else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                }\r\n                else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                }\r\n                else {\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = node;\r\n                return buf.push('<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n    needNamespaceDefine(node, visibleNamespaces) {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _xmlEncoder(c) {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n    outputIndented(options, buf, indentLevel, ...outputParts) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n    indentationString(options, indentLevel) {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    isMixedContentElement(tagName, options) {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    containsOnlyWhiteSpace(text) {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\nclass AbstractTranslationMessagesFile {\r\n    constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    parseContent(xmlString, path, encoding, optionalMaster) {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n    lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n    warnings() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    numberOfTransUnits() {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfTransUnitsWithMissingId() {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    forEachTransUnit(callback) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    transUnitWithId(id) {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    setNewTransUnitTargetPraefix(targetPraefix) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix() {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    setNewTransUnitTargetSuffix(targetSuffix) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix() {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    removeTransUnitWithId(id) {\r\n        const tuNode = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    filename() {\r\n        return this._filename;\r\n    }\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    encoding() {\r\n        return this._encoding;\r\n    }\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    editedContent(beautifyOutput) {\r\n        const options = {};\r\n        if (beautifyOutput === true) {\r\n            options.beautify = true;\r\n            options.indentString = '  ';\r\n            options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        }\r\n        else {\r\n            return result;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\nclass AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        this._element = _element;\r\n        this._id = _id;\r\n        this._translationMessagesFile = _translationMessagesFile;\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile() {\r\n        return this._translationMessagesFile;\r\n    }\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent() {\r\n        return true;\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    sourceContentNormalized() {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    targetState() {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            this.translationMessagesFile().countNumbers();\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceReferences() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetDescriptionAndMeaning() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    checkNotes(newNotes) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    asXmlElement() {\r\n        return this._element;\r\n    }\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    translate(translation) {\r\n        let translationNative;\r\n        if (isString(translation)) {\r\n            translationNative = translation;\r\n        }\r\n        else {\r\n            translationNative = translation.asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    isICUMessage(message) {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\nvar ParsedMessagePartType;\r\n(function (ParsedMessagePartType) {\r\n    ParsedMessagePartType[ParsedMessagePartType[\"TEXT\"] = 0] = \"TEXT\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"PLACEHOLDER\"] = 1] = \"PLACEHOLDER\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"START_TAG\"] = 2] = \"START_TAG\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"END_TAG\"] = 3] = \"END_TAG\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"EMPTY_TAG\"] = 4] = \"EMPTY_TAG\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"ICU_MESSAGE\"] = 5] = \"ICU_MESSAGE\";\r\n    ParsedMessagePartType[ParsedMessagePartType[\"ICU_MESSAGE_REF\"] = 6] = \"ICU_MESSAGE_REF\";\r\n})(ParsedMessagePartType || (ParsedMessagePartType = {}));\r\nclass ParsedMessagePart {\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\nclass ParsedMessagePartText extends ParsedMessagePart {\r\n    constructor(text) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n    asDisplayString(format) {\r\n        return this.text;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\nclass ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n    constructor(index, disp) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n    asDisplayString(format) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    index() {\r\n        return this._index;\r\n    }\r\n    disp() {\r\n        return this._disp;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\nclass ParsedMessagePartStartTag extends ParsedMessagePart {\r\n    constructor(tagname, idcounter) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n    asDisplayString(format) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        }\r\n        else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n    tagName() {\r\n        return this._tagname;\r\n    }\r\n    idCounter() {\r\n        return this._idcounter;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\nclass ParsedMessagePartEndTag extends ParsedMessagePart {\r\n    constructor(tagname) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n    asDisplayString(format) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n    tagName() {\r\n        return this._tagname;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n// Tokens\r\nconst TEXT$1 = 'TEXT';\r\nconst CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nconst CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nconst COMMA = 'COMMA';\r\nconst PLURAL = 'PLURAL';\r\nconst SELECT = 'SELECT';\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\nclass ICUMessageTokenizer {\r\n    getLexer() {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT$1) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT$1, plaintext);\r\n                    plaintext = '';\r\n                }\r\n                else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT$1, plaintext);\r\n            }\r\n        });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            }\r\n            else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            }\r\n            else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT$1);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n            else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                }\r\n                else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT$1, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            }\r\n            else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT$1);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT$1);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT$1);\r\n        return lexer;\r\n    }\r\n    containsNonWhiteSpace(text) {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    tokenize(normalizedMessage) {\r\n        const lexer = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n    input(normalizedMessage) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n    next() {\r\n        return this.lexer.token();\r\n    }\r\n    peek() {\r\n        return this.lexer.peek();\r\n    }\r\n}\n\nclass MessageCategory {\r\n    constructor(_category, _message) {\r\n        this._category = _category;\r\n        this._message = _message;\r\n    }\r\n    getCategory() {\r\n        return this._category;\r\n    }\r\n    getMessageNormalized() {\r\n        return this._message;\r\n    }\r\n}\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nclass ICUMessage {\r\n    constructor(_parser, isPluralMessage) {\r\n        this._parser = _parser;\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n    addCategory(category, message) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    asNativeString() {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage() {\r\n        return this._isPluralMessage;\r\n    }\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage() {\r\n        return !this._isPluralMessage;\r\n    }\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories() {\r\n        return this._categories;\r\n    }\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation) {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories = new Set();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage;\r\n            const translationForCategory = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            }\r\n            else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(translationForCategory, null);\r\n            }\r\n            else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)', categoryName));\r\n                }\r\n                else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    const translatedMessage = this._parser.parseNormalizedString(translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    checkValidPluralCategory(categoryName) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\n\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\nclass ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n    constructor(icuMessageText, _parser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        this._parser = _parser;\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText) {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n    asDisplayString(displayFormat) {\r\n        return '<ICU-Message/>';\r\n    }\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    getICUMessage() {\r\n        return this._message;\r\n    }\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    parseICUMessage(text) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT$1); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        }\r\n        else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT$1).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT$1).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    looksLikeICUMessage(text) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT$1); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        }\r\n        catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    expectNext(tokentype) {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)', tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    parseNativeSubMessage(message) {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\nclass ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n    constructor(index, disp) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n    asDisplayString(format) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n    index() {\r\n        return this._index;\r\n    }\r\n    disp() {\r\n        return this._disp;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\nclass ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n    constructor(tagname, idcounter) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n    asDisplayString(format) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        }\r\n        else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n    tagName() {\r\n        return this._tagname;\r\n    }\r\n    idCounter() {\r\n        return this._idcounter;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nclass ParsedMessage {\r\n    constructor(parser, sourceMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser() {\r\n        return this._parser;\r\n    }\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString) {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(normalizedString, this);\r\n        }\r\n        else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")', normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation) {\r\n        const icuMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")', icuTranslation, this.asNativeString()));\r\n        }\r\n        else {\r\n            const translatedICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString) {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    asDisplayString(displayFormat) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString() {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        }\r\n        else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    validate() {\r\n        let hasErrors = false;\r\n        const errors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings() {\r\n        let hasWarnings = false;\r\n        const warnings = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n    /**\r\n     * Test wether this message is an ICU message.\r\n     * @return true, if it is an ICU message.\r\n     */\r\n    isICUMessage() {\r\n        return this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE;\r\n    }\r\n    /**\r\n     * Test wether this message contains an ICU message reference.\r\n     * ICU message references are something like <x ID=\"ICU\"../>.\r\n     * @return true, if there is an ICU message reference in the message.\r\n     */\r\n    containsICUMessageRef() {\r\n        return this._parts.findIndex(part => part.type === ParsedMessagePartType.ICU_MESSAGE_REF) >= 0;\r\n    }\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    getICUMessage() {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkPlaceholderAdded() {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkPlaceholderRemoved() {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkICUMessageRefAdded() {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkICUMessageRefRemoved() {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        }\r\n        else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    allPlaceholders() {\r\n        const result = new Set();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = part.index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    getPlaceholderDisp(index) {\r\n        let placeHolder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart = part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    allICUMessageRefs() {\r\n        const result = new Set();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = part.index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    getICUMessageRefDisp(index) {\r\n        let icuMessageRefPart = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart = part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkTagAdded() {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        }\r\n        else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    checkTagRemoved() {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        }\r\n        else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    allTags() {\r\n        const result = new Set();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = part.tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    parts() {\r\n        return this._parts;\r\n    }\r\n    setXmlRepresentation(xmlRepresentation) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n    addText(text) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n    addPlaceholder(index, disp) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n    addStartTag(tagname, idcounter) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n    addEndTag(tagname) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")', tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n    addEmptyTag(tagname, idcounter) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n    addICUMessageRef(index, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n    addICUMessage(text) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    calculateOpenTagName() {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push(part.tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = part.tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")', tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\n\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n// Tokens\r\nconst TEXT = 'TEXT';\r\nconst START_TAG = 'START_TAG';\r\nconst END_TAG = 'END_TAG';\r\nconst EMPTY_TAG = 'EMPTY_TAG';\r\nconst PLACEHOLDER = 'PLACEHOLDER';\r\nconst ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nconst ICU_MESSAGE = 'ICU_MESSAGE';\r\nclass ParsedMesageTokenizer {\r\n    getLexer() {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, { text: plaintext });\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, { text: plaintext });\r\n            }\r\n        });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, { name: match[1], idcounter: idcount });\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, { name: match[1], idcounter: idcount });\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, { name: match[1] });\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, { idcounter: parseInt(match[1], 10) });\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, { idcounter: parseInt(match[1], 10) });\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, { message: match[0] });\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n    tokenize(normalizedMessage) {\r\n        const lexer = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nclass AbstractMessageParser {\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXML(xmlElement, sourceMessage) {\r\n        const message = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString, sourceMessage) {\r\n        const doc = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement = doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    addPartsOfNodeToMessage(node, message, includeSelf) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                }\r\n                catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(node, message);\r\n        }\r\n    }\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    getICUMessageText(node) {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(node);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    isICUMessageStart(text) {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n        //        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    parseNormalizedString(normalizedString, sourceMessage) {\r\n        const message = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens;\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        }\r\n        catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token) => {\r\n            let disp = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString, sourceMessage) {\r\n        const message = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    parseIdCountFromName(name) {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        }\r\n        else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    createXmlRepresentation(message) {\r\n        const root = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n    createXmlRepresentationOfTextPart(part, rootElem) {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\nclass TagMapping {\r\n    getStartTagPlaceholderName(tag, id) {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n    getCloseTagPlaceholderName(tag) {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n    getEmptyTagPlaceholderName(tag, id) {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n    getCtypeForTag(tag) {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n    getTagnameFromStartTagPlaceholderName(placeholderName) {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        }\r\n        else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n    getTagnameFromCloseTagPlaceholderName(placeholderName) {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        }\r\n        else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    isEmptyTagPlaceholderName(placeholderName) {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        }\r\n        else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    getTagnameFromEmptyTagPlaceholderName(placeholderName) {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        }\r\n        else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    stripCounter(placeholderName) {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    counterString(id) {\r\n        if (id === 0) {\r\n            return '';\r\n        }\r\n        else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nclass XliffMessageParser extends AbstractMessageParser {\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    processStartElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            }\r\n            else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            }\r\n            else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n            else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            }\r\n            else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    processEndElement(elementNode, message) {\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    parsePlaceholderIndexFromId(id) {\r\n        let indexString = '';\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    parseICUMessageRefIndexFromId(id) {\r\n        let indexString = '';\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    addXmlRepresentationToRoot(message, rootElem) {\r\n        message.parts().forEach((part) => {\r\n            let child;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart(part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart(part, rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfStartTagPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEndTagPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEmptyTagPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfPlaceholderPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\nclass XliffTransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n    sourceContent() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new XliffMessageParser();\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    nativeTargetState() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        switch (state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' + state);\r\n        }\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        switch (nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({ sourcefile: sourcefile, linenumber: linenumber });\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n    removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    description() {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    findNoteElementWithFromAttribute(attrValue) {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    findAllAdditionalNoteElements() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    createNoteElementWithFromAttribute(fromAttrValue, content) {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    removeNoteElementWithFromAttribute(attrValue) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    meaning() {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    notes() {\r\n        const noteElememts = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    setNotes(newNotes) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        const element = this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        }\r\n        else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        }\r\n        else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\nclass XliffFile extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString, path, encoding) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        }\r\n        else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s', path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = foreignTransUnit.cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        }\r\n        else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            }\r\n            else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        }\r\n        else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit) => {\r\n            transUnit.useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nclass XmbMessageParser extends AbstractMessageParser {\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    processStartElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            }\r\n            else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            }\r\n            else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            }\r\n            else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            }\r\n            else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        }\r\n        else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    getICUMessageText(node) {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || child.tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                }\r\n                else {\r\n                    return messageText;\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    processEndElement(elementNode, message) {\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    parsePlaceholderIndexFromName(name) {\r\n        let indexString = '';\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    parseICUMessageIndexFromName(name) {\r\n        let indexString = '';\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        }\r\n        else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    parseTagnameFromPhElement(phElement) {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            }\r\n            else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    addXmlRepresentationToRoot(message, rootElem) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n    createXmlRepresentationOfPart(part, rootElem) {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart(part, rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart(part, rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart(part, rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart(part, rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart(part, rootElem);\r\n        }\r\n    }\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfStartTagPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEndTagPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEmptyTagPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfPlaceholderPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\nclass XmbTransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    static parseSourceAndPos(sourceAndPos) {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n    static parseLineNumber(lineNumberString) {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    sourceContent() {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        // not supported\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new XmbMessageParser();\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    nativeTargetState() {\r\n        return null; // not supported in xmb\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        return state;\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        return nativeState;\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        // not supported for xmb\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n    removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    description() {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    meaning() {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetDescriptionAndMeaning() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    notes() {\r\n        return [];\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    setNotes(newNotes) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        return this;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        // do nothing\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n}\n\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nconst XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\nclass XmbFile extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(_translationMessageFileFactory, xmlString, path, encoding) {\r\n        super();\r\n        this._translationMessageFileFactory = _translationMessageFileFactory;\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XMB;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XMB;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['message'];\r\n    }\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    guessLanguageFromFilename() {\r\n        if (this._filename) {\r\n            const parts = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        const translationbundleXMLSource = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XTB, translationbundleXMLSource, filename, this.encoding(), { xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding() });\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\n\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nclass Xliff2MessageParser extends AbstractMessageParser {\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    processStartElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            }\r\n            else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                }\r\n                else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            }\r\n            else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                }\r\n                else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            }\r\n            else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            }\r\n            else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            }\r\n            else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        }\r\n        else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    processEndElement(elementNode, message) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    tagNameFromPCElement(pcNode) {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    addXmlRepresentationToRoot(message, rootElem) {\r\n        const stack = [{ element: rootElem, tagName: 'root' }];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfTextPart(part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfPlaceholderPart(part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(this.createXmlRepresentationOfICUMessageRefPart(part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({ element: newTagElem, tagName: part.tagName() });\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = part.tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    createXmlRepresentationOfStartTagPart(part, rootElem, id) {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfEndTagPart(part, rootElem) {\r\n        // not used\r\n        return null;\r\n    }\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    createXmlRepresentationOfEmptyTagPart(part, rootElem, id) {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n    getTypeForTag(tag) {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    createXmlRepresentationOfPlaceholderPart(part, rootElem, id) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    createXmlRepresentationOfICUMessageRefPart(part, rootElem) {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\nclass Xliff2TransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n    sourceContent() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new Xliff2MessageParser();\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    nativeTargetState() {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        switch (state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' + state);\r\n        }\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        switch (nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    parseSourceAndPos(sourceAndPos) {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n    parseLineNumber(lineNumberString) {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined$1(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined$1(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n    removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => { elem.parentNode.removeChild(elem); });\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    description() {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined$1(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined$1(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    findNoteElementWithCategoryAttribute(attrValue) {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    findAllAdditionalNoteElements() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    createNoteElementWithCategoryAttribute(attrValue, content) {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined$1(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n    removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    removeNoteElementWithCategoryAttribute(attrValue) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    meaning() {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined$1(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            }\r\n            else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndefined$1(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    notes() {\r\n        const noteElememts = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    setNotes(newNotes) {\r\n        if (!isNullOrUndefined$1(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined$1(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        const element = this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        }\r\n        else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            }\r\n            else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\nclass Xliff2File extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString, path, encoding) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        }\r\n        else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s', path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = foreignTransUnit.cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        }\r\n        else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            }\r\n            else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        }\r\n        else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit) => {\r\n            transUnit.useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\nclass XtbTransUnit extends AbstractTransUnit {\r\n    constructor(_element, _id, _translationMessagesFile, _sourceTransUnitFromMaster) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    sourceContent() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    setSourceContent(newContent) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    messageParser() {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    createSourceContentNormalized() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    targetContent() {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized() {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    nativeTargetState() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            }\r\n            else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    mapStateToNativeState(state) {\r\n        return state;\r\n    }\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    mapNativeStateToState(nativeState) {\r\n        return nativeState;\r\n    }\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    setNativeTargetState(nativeState) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    sourceReferences() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceReferences() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    setSourceReferences(sourceRefs) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    description() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    meaning() {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetDescriptionAndMeaning() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    setDescription(description) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    setMeaning(meaning) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    notes() {\r\n        return [];\r\n    }\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetNotes() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    setNotes(newNotes) {\r\n        // not supported, do nothing\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    cloneWithSourceAsTarget(isDefaultLang, copyContent, targetFile) {\r\n        return this;\r\n    }\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    useSourceAsTarget(isDefaultLang, copyContent) {\r\n        // do nothing\r\n    }\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    translateNative(translation) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined$1(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\nclass XtbFile extends AbstractTranslationMessagesFile {\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(_translationMessageFileFactory, xmlString, path, encoding, optionalMaster) {\r\n        super();\r\n        this._translationMessageFileFactory = _translationMessageFileFactory;\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n    initializeFromContent(xmlString, path, encoding, optionalMaster) {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(FORMAT_XMB, optionalMaster.xmlContent, optionalMaster.path, optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format('%s trans units found in master, but this file has %s. Check if it is the correct master', numberInMaster, myNumber));\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, masterUnit));\r\n        }\r\n    }\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    i18nFormat() {\r\n        return FORMAT_XTB;\r\n    }\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    fileType() {\r\n        return FILETYPE_XTB;\r\n    }\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    elementsWithMixedContent() {\r\n        return ['translation'];\r\n    }\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    sourceLanguage() {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    setSourceLanguage(language) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    targetLanguage() {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    setTargetLanguage(language) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit, isDefaultLang, copyContent, importAfterElement) {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = foreignTransUnit.cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!foreignTransUnit.isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        }\r\n        else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            }\r\n            else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        }\r\n        else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    createTranslationFileForLang(lang, filename, isDefaultLang, copyContent) {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\n\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nclass TranslationMessagesFileFactory {\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    static fromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster) {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    static fromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster) {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster) {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n    }\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster) {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            }\r\n            catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n}\n\n/*\r\n * Public API Surface of ngx-i18nsupport-lib\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { FILETYPE_XLIFF12, FILETYPE_XLIFF20, FILETYPE_XMB, FILETYPE_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB, NORMALIZATION_FORMAT_DEFAULT, NORMALIZATION_FORMAT_NGXTRANSLATE, NgxI18nsupportLibModule, STATE_FINAL, STATE_NEW, STATE_TRANSLATED, TranslationMessagesFileFactory };\n//# sourceMappingURL=ngx-i18nsupport-ngx-i18nsupport-lib.mjs.map\n","map":{"version":3,"file":"ngx-i18nsupport-ngx-i18nsupport-lib.mjs","sources":["../../../projects/ngx-i18nsupport-lib/src/lib/ngx-i18nsupport-lib.module.ts","../../../projects/ngx-i18nsupport-lib/src/api/constants.ts","../../../projects/ngx-i18nsupport-lib/src/impl/dom-utilities.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xml-serializer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-translation-messages-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-text.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-placeholder.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-start-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-end-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/icu-message-tokenizer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/icu-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-icu-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-icu-message-ref.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-empty-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-tokenizer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/tag-mapping.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xtb-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xtb-file.ts","../../../projects/ngx-i18nsupport-lib/src/api/translation-messages-file-factory.ts","../../../projects/ngx-i18nsupport-lib/src/public_api.ts","../../../projects/ngx-i18nsupport-lib/src/ngx-i18nsupport-ngx-i18nsupport-lib.ts"],"sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class NgxI18nsupportLibModule { }\r\n","/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n\r\n/**\r\n * supported file formats\r\n */\r\nexport const FORMAT_XLIFF12 = 'xlf';\r\nexport const FORMAT_XLIFF20 = 'xlf2';\r\nexport const FORMAT_XMB = 'xmb';\r\nexport const FORMAT_XTB = 'xtb';\r\n\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nexport const FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nexport const FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nexport const FILETYPE_XMB = 'XMB';\r\nexport const FILETYPE_XTB = 'XTB';\r\n\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nexport const STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nexport const STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nexport const STATE_FINAL = 'final';\r\n\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\r\n","import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n","/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = elementNode.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {isNullOrUndefined} from 'is-what';\r\nimport {DOMParser} from 'xmldom';\r\nimport {XmlSerializer, XmlSerializerOptions} from './xml-serializer';\r\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\n\r\nexport abstract class AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    protected _filename: string;\r\n\r\n    protected _encoding: BufferEncoding ;\r\n\r\n    protected _parsedDocument: Document;\r\n\r\n    protected _fileEndsWithEOL: boolean;\r\n\r\n    // trans-unit elements and their id from the file\r\n    protected transUnits: ITransUnit[];\r\n\r\n    protected _warnings: string[];\r\n\r\n    protected _numberOfTransUnitsWithMissingId: number;\r\n\r\n    protected _numberOfUntranslatedTransUnits: number;\r\n\r\n    protected _numberOfReviewedTransUnits: number;\r\n\r\n    protected targetPraefix: string;\r\n\r\n    protected targetSuffix: string;\r\n\r\n    protected constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    protected parseContent(\r\n        xmlString: string,\r\n        path: string, encoding: BufferEncoding ,\r\n        optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  })\r\n        : void {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n\r\n    abstract i18nFormat(): string;\r\n\r\n    abstract fileType(): string;\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected abstract elementsWithMixedContent(): string[];\r\n\r\n    /**\r\n     * Read all trans units from xml content.\r\n     * Puts the found units into transUnits.\r\n     * Puts warnings for missing ids.\r\n     */\r\n    protected abstract initializeTransUnits();\r\n\r\n    protected lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    public countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu: ITransUnit) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n\r\n    public warnings(): string[] {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    public numberOfTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    public numberOfTransUnitsWithMissingId(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    abstract sourceLanguage(): string;\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    abstract targetLanguage(): string;\r\n\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    public forEachTransUnit(callback: ((transunit: ITransUnit) => void)) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public transUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Edit functions following her\r\n     */\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    abstract setSourceLanguage(language: string);\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    abstract setTargetLanguage(language: string);\r\n\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    public setNewTransUnitTargetPraefix(targetPraefix: string) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix(): string {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    public setNewTransUnitTargetSuffix(targetSuffix: string) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix(): string {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    abstract importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit;\r\n\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    public removeTransUnitWithId(id: string) {\r\n        const tuNode: Node = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    public filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    public encoding(): BufferEncoding {\r\n        return this._encoding;\r\n    }\r\n\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public editedContent(beautifyOutput?: boolean): string {\r\n        const options: XmlSerializerOptions = {};\r\n        if (beautifyOutput === true) {\r\n           options.beautify = true;\r\n           options.indentString = '  ';\r\n           options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    abstract createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile;\r\n}\r\n","import {STATE_TRANSLATED, ITranslationMessagesFile, INormalizedMessage, ITransUnit, INote} from './internalapi';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {isNullOrUndefined, isString} from 'is-what';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\n\r\nexport abstract class AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceContentNormalized: ParsedMessage;\r\n\r\n    protected constructor(protected _element: Element,\r\n                          protected _id: string,\r\n                          protected _translationMessagesFile: ITranslationMessagesFile) {\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile(): ITranslationMessagesFile {\r\n        return this._translationMessagesFile;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract sourceContent(): string;\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    abstract setSourceContent(newContent: string);\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public sourceContentNormalized(): ParsedMessage {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    abstract createSourceContentNormalized(): ParsedMessage;\r\n\r\n    /**\r\n     * The translated value.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract targetContent(): string;\r\n\r\n    /**\r\n     * The translated value as normalized message.\r\n     * All placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    abstract targetContentNormalized(): INormalizedMessage;\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    abstract nativeTargetState(): string;\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    public targetState(): string {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected abstract mapStateToNativeState(state: string): string;\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract mapNativeStateToState(nativeState: string): string;\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract setNativeTargetState(nativeState: string);\r\n\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState: string) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            (<AbstractTranslationMessagesFile> this.translationMessagesFile()).countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    abstract sourceReferences(): {sourcefile: string, linenumber: number}[];\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    abstract setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]);\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     */\r\n    abstract description(): string;\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     */\r\n    abstract meaning(): string;\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    abstract setDescription(description: string);\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    abstract setMeaning(meaning: string);\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    abstract notes(): INote[];\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    abstract supportsSetNotes(): boolean;\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains descpription or meaning as from attribute.\r\n     */\r\n    abstract setNotes(newNotes: INote[]);\r\n\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    protected checkNotes(newNotes: INote[]) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    public asXmlElement(): Element {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    abstract cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit;\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    abstract useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean);\r\n\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    public translate(translation: string | INormalizedMessage) {\r\n        let translationNative: string;\r\n        if (isString(translation)) {\r\n            translationNative = <string> translation;\r\n        } else {\r\n            translationNative = (<INormalizedMessage> translation).asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected abstract messageParser(): AbstractMessageParser;\r\n\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    public isICUMessage(message: string): boolean {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected abstract translateNative(translation: string);\r\n}\r\n","/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\n\r\nexport enum ParsedMessagePartType {\r\n    TEXT,\r\n    PLACEHOLDER,\r\n    START_TAG,\r\n    END_TAG,\r\n    EMPTY_TAG,\r\n    ICU_MESSAGE,\r\n    ICU_MESSAGE_REF\r\n}\r\n\r\nexport abstract class ParsedMessagePart {\r\n\r\n    constructor(public type: ParsedMessagePartType) {\r\n\r\n    }\r\n\r\n    /**\r\n     * String representation of the part.\r\n     * @param format optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public abstract asDisplayString(format?: string): string;\r\n\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\n\r\nexport class ParsedMessagePartText extends ParsedMessagePart {\r\n\r\n    private text: string;\r\n\r\n    constructor(text: string) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return this.text;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\n\r\nexport class ParsedMessagePartStartTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\n\r\nexport class ParsedMessagePartEndTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n\r\n    constructor(tagname: string) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n}\r\n","import Tokenizr from 'tokenizr';\r\n\r\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nexport const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nexport const COMMA = 'COMMA';\r\nexport const PLURAL = 'PLURAL';\r\nexport const SELECT = 'SELECT';\r\n\r\nexport interface ICUToken {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\n\r\nexport class ICUMessageTokenizer {\r\n    private lexer: Tokenizr;\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                } else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT, plaintext);\r\n            }\r\n         });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            } else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            } else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            } else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                } else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            } else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    private containsNonWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): ICUToken[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n    input(normalizedMessage: string) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n\r\n    next(): ICUToken {\r\n        return this.lexer.token();\r\n    }\r\n\r\n    peek(): ICUToken {\r\n        return this.lexer.peek();\r\n    }\r\n}\r\n","import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined, isString} from 'is-what';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    const translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\n\r\nexport class ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {INormalizedMessage, ValidationErrors} from '../api/i-normalized-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from 'is-what';\r\nimport {IICUMessage, IICUMessageTranslation} from '../api/i-icu-message';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ICUMessage} from './icu-message';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nexport class ParsedMessage implements INormalizedMessage {\r\n\r\n    /**\r\n     * Parser that created this message (determines the native format).\r\n     */\r\n    private _parser: IMessageParser;\r\n\r\n    /**\r\n     * The message where this one stems from as translation.\r\n     * Optional, set only for messages created by calling translate.\r\n     */\r\n    private sourceMessage: ParsedMessage;\r\n\r\n    /**\r\n     * The parts of the message.\r\n     */\r\n    private _parts: ParsedMessagePart[];\r\n\r\n    /**\r\n     * messages xml representation.\r\n     */\r\n    private _xmlRepresentation: Element;\r\n\r\n    constructor(parser: IMessageParser, sourceMessage: ParsedMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser(): IMessageParser {\r\n        return this._parser;\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString: string): INormalizedMessage {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(<string> normalizedString, this);\r\n        } else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")',\r\n                normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation: IICUMessageTranslation): INormalizedMessage {\r\n        const icuMessage: IICUMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")',\r\n                icuTranslation,  this.asNativeString()));\r\n        } else {\r\n            const translatedICUMessage: IICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public asDisplayString(displayFormat?: string) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString(): string {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        } else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    public validate(): ValidationErrors | null {\r\n        let hasErrors = false;\r\n        const errors: ValidationErrors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings(): ValidationErrors | null {\r\n        let hasWarnings = false;\r\n        const warnings: ValidationErrors = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message is an ICU message.\r\n     * @return true, if it is an ICU message.\r\n     */\r\n    isICUMessage(): boolean {\r\n        return this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message contains an ICU message reference.\r\n     * ICU message references are something like <x ID=\"ICU\"../>.\r\n     * @return true, if there is an ICU message reference in the message.\r\n     */\r\n    containsICUMessageRef(): boolean {\r\n        return this._parts.findIndex(part => part.type === ParsedMessagePartType.ICU_MESSAGE_REF) >= 0;\r\n    }\r\n\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = <ParsedMessagePartICUMessage> this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderRemoved(): any {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefRemoved(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    private allPlaceholders(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = (<ParsedMessagePartPlaceholder> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    public getPlaceholderDisp(index: number): string {\r\n        let placeHolder: ParsedMessagePartPlaceholder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart: ParsedMessagePartPlaceholder = <ParsedMessagePartPlaceholder> part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    private allICUMessageRefs(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = (<ParsedMessagePartICUMessageRef> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    public getICUMessageRefDisp(index: number): string {\r\n        let icuMessageRefPart: ParsedMessagePartICUMessageRef = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart: ParsedMessagePartICUMessageRef = <ParsedMessagePartICUMessageRef> part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagAdded(): any {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagRemoved(): any {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    private allTags(): Set<string> {\r\n        const result = new Set<string>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = (<ParsedMessagePartStartTag> part).tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    public parts(): ParsedMessagePart[] {\r\n        return this._parts;\r\n    }\r\n\r\n    setXmlRepresentation(xmlRepresentation: Element) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n\r\n    addText(text: string) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n\r\n    addPlaceholder(index: number, disp: string) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n\r\n    addStartTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n\r\n    addEndTag(tagname: string) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n\r\n    addEmptyTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n\r\n    addICUMessageRef(index: number, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n\r\n    addICUMessage(text: string) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    private calculateOpenTagName(): string {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push((<ParsedMessagePartStartTag> part).tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                            tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\r\n","import Tokenizr from 'tokenizr';\r\nimport {isNullOrUndefined} from 'is-what';\r\n\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const START_TAG = 'START_TAG';\r\nexport const END_TAG = 'END_TAG';\r\nexport const EMPTY_TAG = 'EMPTY_TAG';\r\nexport const PLACEHOLDER = 'PLACEHOLDER';\r\nexport const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nexport const ICU_MESSAGE = 'ICU_MESSAGE';\r\n\r\nexport interface Token {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\nexport class ParsedMesageTokenizer {\r\n\r\n    private getLexer(): Tokenizr {\r\n        const lexer = new Tokenizr();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n            }\r\n         });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, {name: match[1], idcounter: idcount});\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, {name: match[1], idcounter: idcount});\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, {name: match[1]});\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, {idcounter: parseInt(match[1], 10)});\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, {idcounter: parseInt(match[1], 10)});\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, {message: match[0]});\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): Token[] {\r\n        const lexer: Tokenizr = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n}\r\n","import {ParsedMessage} from './parsed-message';\r\nimport {\r\n    EMPTY_TAG,\r\n    END_TAG, ICU_MESSAGE, ICU_MESSAGE_REF, ParsedMesageTokenizer, PLACEHOLDER, START_TAG, TEXT,\r\n    Token\r\n} from './parsed-message-tokenizer';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {DOMParser} from 'xmldom';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from 'is-what';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nexport abstract class AbstractMessageParser implements IMessageParser {\r\n\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    public createNormalizedMessageFromXML(xmlElement: Element, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const doc: Document = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement: Element = <Element> doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    private addPartsOfNodeToMessage(node: Node, message: ParsedMessage, includeSelf: boolean) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(<Element> node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                } catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(<Element> node, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(<Element> node);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    public isICUMessageStart(text: string): boolean {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n//        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n\r\n    /**\r\n     * Handle this node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected abstract processStartElement(elementNode: Element, message: ParsedMessage): boolean;\r\n\r\n    /**\r\n     * Handle end of this node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected abstract processEndElement(elementNode: Element, message: ParsedMessage);\r\n\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    public parseNormalizedString(normalizedString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens: Token[];\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        } catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token: Token) => {\r\n            let disp: string = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    protected parseIdCountFromName(name: string): number {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        } else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    protected createXmlRepresentation(message: ParsedMessage): Element {\r\n        const root: Document = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem: Element = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n\r\n    protected abstract addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element);\r\n\r\n    protected createXmlRepresentationOfTextPart(part: ParsedMessagePartText, rootElem: Element): Node {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node;\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node;\r\n}\r\n","/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\n\r\nexport class TagMapping {\r\n\r\n    public getStartTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n\r\n    public getCloseTagPlaceholderName(tag: string): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n\r\n    public getEmptyTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName =  TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n\r\n    public getCtypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n\r\n    public getTagnameFromStartTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public getTagnameFromCloseTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public isEmptyTagPlaceholderName(placeholderName: string): boolean {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public getTagnameFromEmptyTagPlaceholderName(placeholderName: string): string {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    private stripCounter(placeholderName: string): string {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    private counterString(id: number) {\r\n        if (id === 0) {\r\n            return '';\r\n        } else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nexport class XliffMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            } else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            } else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            } else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            } else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    private parsePlaceholderIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageRefIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            let child: Node;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XliffMessageParser} from './xliff-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'is-what';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\n\r\nexport class XliffTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XliffMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({sourcefile: sourcefile, linenumber: linenumber});\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n           if (isNullOrUndefined(noteElem)) {\r\n               // create it\r\n               noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n           } else {\r\n               DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n           }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithFromAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithFromAttribute(fromAttrValue: string, content: string): Element {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithFromAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n     }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        } else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF12, FILETYPE_XLIFF12} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {XliffTransUnit} from './xliff-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class XliffFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: BufferEncoding ) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ): XliffFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n         return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nexport class XmbMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            } else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        } else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || (<Element> child).tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(<Element> node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource: RegExp = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                } else {\r\n                    return messageText;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parsePlaceholderIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    private parseTagnameFromPhElement(phElement: Element): string {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            } else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected createXmlRepresentationOfPart(part: ParsedMessagePart, rootElem: Element): Node {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\r\n","import {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\n\r\nexport class XmbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    private static parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private static parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    public sourceContent(): string {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem: RegExp = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // not supported\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    public nativeTargetState(): string {\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // not supported for xmb\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos: string = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    public description(): string {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XMB, FILETYPE_XMB, FORMAT_XTB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {XmbTransUnit} from './xmb-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\n\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nexport const XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\n\r\nexport class XmbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(\r\n        private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n        xmlString: string, path: string, encoding: BufferEncoding ) {\r\n\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ): XmbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XMB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XMB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['message'];\r\n    }\r\n\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    private guessLanguageFromFilename(): string {\r\n        if (this._filename) {\r\n            const parts: string[] = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationbundleXMLSource =\r\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n            FORMAT_XTB,\r\n            translationbundleXMLSource, filename, this.encoding(),\r\n            {xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding()});\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF20, FILETYPE_XLIFF20} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {Xliff2TransUnit} from './xliff2-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class Xliff2File extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: BufferEncoding ) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ): Xliff2File {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XTB, FILETYPE_XTB, FORMAT_XMB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {XtbTransUnit} from './xtb-trans-unit';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\n\r\nexport class XtbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    // attached master file, if any\r\n    // used as source to determine state ...\r\n    private _masterFile: ITranslationMessagesFile; // an xmb-file\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n                xmlString: string, path: string, encoding: BufferEncoding ,\r\n                optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: BufferEncoding ,\r\n                                  optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  }): XtbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n                    FORMAT_XMB,\r\n                    optionalMaster.xmlContent,\r\n                    optionalMaster.path,\r\n                    optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format(\r\n                        '%s trans units found in master, but this file has %s. Check if it is the correct master',\r\n                        numberInMaster, myNumber));\r\n                }\r\n            } catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit: ITransUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, <AbstractTransUnit> masterUnit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XTB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XTB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['translation'];\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!(<AbstractTransUnit> foreignTransUnit).isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean)\r\n        : ITranslationMessagesFile {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: BufferEncoding ,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: BufferEncoding }): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: BufferEncoding ,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: BufferEncoding }): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: BufferEncoding ,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: BufferEncoding ,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: BufferEncoding  })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n","/*\r\n * Public API Surface of ngx-i18nsupport-lib\r\n */\r\n\r\n// The module is here only because ng-packagr needs it\r\nexport * from './lib/ngx-i18nsupport-lib.module';\r\nexport * from './api';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["TEXT","isNullOrUndefined"],"mappings":"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"}}}