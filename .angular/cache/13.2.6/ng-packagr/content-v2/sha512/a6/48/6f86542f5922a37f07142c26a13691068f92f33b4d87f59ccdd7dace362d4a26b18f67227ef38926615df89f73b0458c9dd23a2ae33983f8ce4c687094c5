{"hash":"162e5434706e2fea8f8d42b8b2480d8f91e98d5f","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { Writable } from 'stream';\nimport chalk from 'chalk';\nimport { format } from 'util';\nimport * as fs from 'fs';\nimport { NORMALIZATION_FORMAT_NGXTRANSLATE, TranslationMessagesFileFactory, STATE_NEW, FORMAT_XMB, FORMAT_XTB, STATE_FINAL, STATE_TRANSLATED, NORMALIZATION_FORMAT_DEFAULT } from '@ngx-i18nsupport/ngx-i18nsupport-lib';\nimport * as path from 'path';\nimport { isAbsolute, join, dirname } from 'path';\nimport { of, throwError, forkJoin, Observable } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport * as entityDecoderLib from 'he';\nimport * as request from 'request';\n\n// not used, only there to make ng-packagr happy\r\nclass XliffmergeModule {\r\n}\r\n/** @nocollapse */ /** @nocollapse */ XliffmergeModule.ɵfac = function XliffmergeModule_Factory(t) { return new (t || XliffmergeModule)(); };\r\n/** @nocollapse */ /** @nocollapse */ XliffmergeModule.ɵmod = /** @pureOrBreakMyCode */ i0.ɵɵdefineNgModule({ type: XliffmergeModule });\r\n/** @nocollapse */ /** @nocollapse */ XliffmergeModule.ɵinj = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjector({ imports: [[]] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(XliffmergeModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [],\r\n                declarations: [],\r\n                exports: []\r\n            }]\r\n    }], null, null); })();\n\n/**\r\n * Collection of utility functions that are deprecated in nodes util.\r\n */\r\n/**\r\n * Replaces node isNullOrUndefined.\r\n */\r\nfunction isNullOrUndefined(value) {\r\n    return value === undefined || value === null;\r\n}\r\n/**\r\n * Replaces node isString.\r\n */\r\nfunction isString(value) {\r\n    return typeof value === 'string';\r\n}\r\n/**\r\n * Replaces node isBoolean.\r\n */\r\nfunction isBoolean(value) {\r\n    return typeof value === 'boolean';\r\n}\r\n/**\r\n * Replaces node isNumber.\r\n */\r\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\r\n/**\r\n * Replaces node isArray.\r\n */\r\nfunction isArray(value) {\r\n    return Array.isArray(value);\r\n}\n\n/**\r\n * Created by martin on 20.02.2017.\r\n * A helper class for testing.\r\n * Can be used as a WritableStream and writes everything (synchronously) into a string,\r\n * that can easily be read by the tests.\r\n */\r\nclass WriterToString extends Writable {\r\n    constructor() {\r\n        super();\r\n        this.resultString = '';\r\n    }\r\n    _write(chunk, encoding, callback) {\r\n        let chunkString;\r\n        if (isString(chunk)) {\r\n            chunkString = chunk;\r\n        }\r\n        else if (chunk instanceof Buffer) {\r\n            chunkString = chunk.toString();\r\n        }\r\n        else {\r\n            chunkString = Buffer.alloc(chunk).toString(encoding);\r\n        }\r\n        this.resultString = this.resultString + chunkString;\r\n        callback();\r\n    }\r\n    /**\r\n     * Returns a string of everything, that was written to the stream so far.\r\n     * @return written data\r\n     */\r\n    writtenData() {\r\n        return this.resultString;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * Very simple class to control the output of a command.\r\n * Output can be errors, warnings, infos and debug-Outputs.\r\n * The output can be controlled via 2 flags, quiet and verbose.\r\n * If quit is enabled only error messages are shown.\r\n * If verbose is enabled, everything is shown.\r\n * If both are not enabled (the default) errors, warnings and infos are shown.\r\n * If not are enabled (strange), we assumed the default.\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\r\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\r\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\r\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\r\n})(LogLevel || (LogLevel = {}));\r\nclass CommandOutput {\r\n    constructor(stdout) {\r\n        this._quiet = false;\r\n        this._verbose = false;\r\n        if (stdout) {\r\n            this.outputStream = stdout;\r\n        }\r\n        else {\r\n            this.outputStream = process.stdout;\r\n        }\r\n    }\r\n    setVerbose() {\r\n        this._verbose = true;\r\n    }\r\n    setQuiet() {\r\n        this._quiet = true;\r\n    }\r\n    /**\r\n     * Test, wether verbose is enabled.\r\n     * @return wether verbose is enabled.\r\n     */\r\n    verbose() {\r\n        return this._verbose;\r\n    }\r\n    /**\r\n     * Test, wether quiet is enabled.\r\n     * @return wether quiet is enabled.\r\n     */\r\n    quiet() {\r\n        return this._quiet;\r\n    }\r\n    error(msg, ...params) {\r\n        this.log(LogLevel.ERROR, msg, params);\r\n    }\r\n    warn(msg, ...params) {\r\n        this.log(LogLevel.WARN, msg, params);\r\n    }\r\n    info(msg, ...params) {\r\n        this.log(LogLevel.INFO, msg, params);\r\n    }\r\n    debug(msg, ...params) {\r\n        this.log(LogLevel.DEBUG, msg, params);\r\n    }\r\n    log(level, msg, params) {\r\n        if (!this.isOutputEnabled(level)) {\r\n            return;\r\n        }\r\n        let coloredMessage;\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                coloredMessage = chalk.red('ERROR: ' + msg);\r\n                break;\r\n            case LogLevel.WARN:\r\n                coloredMessage = chalk.magenta('WARNING: ' + msg);\r\n                break;\r\n            default:\r\n                coloredMessage = chalk.gray('* ' + msg);\r\n                break;\r\n        }\r\n        const outMsg = format(coloredMessage, ...params);\r\n        this.outputStream.write(outMsg + '\\n');\r\n    }\r\n    isOutputEnabled(level) {\r\n        let quietEnabled, verboseEnabled;\r\n        if (this._quiet && this._verbose) {\r\n            quietEnabled = false;\r\n            verboseEnabled = false;\r\n        }\r\n        else {\r\n            quietEnabled = this._quiet;\r\n            verboseEnabled = this._verbose;\r\n        }\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                return true; // always output errors\r\n            case LogLevel.WARN:\r\n                return (!quietEnabled);\r\n            case LogLevel.INFO:\r\n                return (verboseEnabled && !quietEnabled);\r\n            case LogLevel.DEBUG:\r\n                return verboseEnabled;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n */\r\nclass XliffMergeError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, XliffMergeError.prototype);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * Some (a few) simple utils for file operations.\r\n * Just for convenience.\r\n */\r\nclass FileUtil {\r\n    /**\r\n     * Check for existence.\r\n     * @param filename filename\r\n     * @return wether file exists\r\n     */\r\n    static exists(filename) {\r\n        return fs.existsSync(filename);\r\n    }\r\n    /**\r\n     * Read a file.\r\n     * @param filename filename\r\n     * @param encoding encoding\r\n     * @return content of file\r\n     */\r\n    static read(filename, encoding) {\r\n        return fs.readFileSync(filename, encoding);\r\n    }\r\n    /**\r\n     * Write a file with given content.\r\n     * @param filename filename\r\n     * @param newContent newContent\r\n     * @param encoding encoding\r\n     */\r\n    static replaceContent(filename, newContent, encoding) {\r\n        fs.writeFileSync(filename, newContent, { encoding: encoding });\r\n    }\r\n    static copy(srcFile, destFile) {\r\n        const BUF_LENGTH = 64 * 1024;\r\n        const buff = Buffer.alloc(BUF_LENGTH);\r\n        const fdr = fs.openSync(srcFile, 'r');\r\n        const fdw = fs.openSync(destFile, 'w');\r\n        let bytesRead = 1;\r\n        let pos = 0;\r\n        while (bytesRead > 0) {\r\n            bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);\r\n            fs.writeSync(fdw, buff, 0, bytesRead);\r\n            pos += bytesRead;\r\n        }\r\n        fs.closeSync(fdr);\r\n        fs.closeSync(fdw);\r\n    }\r\n    /**\r\n     * Delete the folder and all of its content (rm -rf).\r\n     * @param path path\r\n     */\r\n    static deleteFolderRecursive(path) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                }\r\n                else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n            fs.rmdirSync(path);\r\n        }\r\n    }\r\n    /**\r\n     * Delete folders content recursively, but do not delete folder.\r\n     * Folder is left empty at the end.\r\n     * @param path path\r\n     */\r\n    static deleteFolderContentRecursive(path) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                }\r\n                else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Delete a file.\r\n     * @param path path\r\n     */\r\n    static deleteFile(path) {\r\n        fs.unlinkSync(path);\r\n    }\r\n}\n\n/**\r\n * Helper class to parse ngx translate extraction pattern\r\n * and to decide wether a given message matches the pattern.\r\n */\r\nclass NgxTranslateExtractionPattern {\r\n    /**\r\n     * Construct the pattern from given description string\r\n     * @param extractionPatternString extractionPatternString\r\n     * @throws an error, if there is a syntax error\r\n     */\r\n    constructor(extractionPatternString) {\r\n        this.extractionPatternString = extractionPatternString;\r\n        const parts = extractionPatternString.split('|');\r\n        this._matchExplicitId = false;\r\n        this._descriptionPatterns = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            if (part === '@@') {\r\n                if (this._matchExplicitId) {\r\n                    throw new Error('extraction pattern must not contain @@ twice');\r\n                }\r\n                this._matchExplicitId = true;\r\n            }\r\n            else {\r\n                const errorString = this.checkValidDescriptionPattern(part);\r\n                if (errorString) {\r\n                    throw new Error(errorString);\r\n                }\r\n                this._descriptionPatterns.push(part);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check, wether an explicitly set id matches the pattern.\r\n     * @param id id\r\n     * @return wether an explicitly set id matches the pattern.\r\n     */\r\n    isExplicitIdMatched(id) {\r\n        return id && this._matchExplicitId;\r\n    }\r\n    /**\r\n     * Check, wether a given description matches the pattern.\r\n     * @param description description\r\n     * @return wether a given description matches the pattern.\r\n     */\r\n    isDescriptionMatched(description) {\r\n        return this._descriptionPatterns.indexOf(description) >= 0;\r\n    }\r\n    checkValidDescriptionPattern(descriptionPattern) {\r\n        if (!descriptionPattern) {\r\n            return 'empty value not allowed';\r\n        }\r\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\r\n            return null; // it is ok\r\n        }\r\n        else {\r\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\r\n        }\r\n    }\r\n}\n\nclass NgxTranslateExtractor {\r\n    constructor(messagesFile, extractionPatternString) {\r\n        this.messagesFile = messagesFile;\r\n        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);\r\n    }\r\n    /**\r\n     * Check, wether extractionPattern has valid syntax.\r\n     * @param extractionPatternString extractionPatternString\r\n     * @return null, if pattern is ok, string describing the error, if it is not ok.\r\n     */\r\n    static checkPattern(extractionPatternString) {\r\n        try {\r\n            if (new NgxTranslateExtractionPattern(extractionPatternString)) {\r\n                return null;\r\n            }\r\n        }\r\n        catch (error) {\r\n            return error.message;\r\n        }\r\n        return null;\r\n    }\r\n    static extract(messagesFile, extractionPattern, outputFile) {\r\n        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);\r\n    }\r\n    /**\r\n     * Extact messages and write them to a file.\r\n     * @param outputFile outputFile\r\n     */\r\n    extractTo(outputFile) {\r\n        const translations = this.toNgxTranslations(this.extract());\r\n        if (translations && Object.keys(translations).length > 0) {\r\n            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'utf-8');\r\n        }\r\n        else {\r\n            if (FileUtil.exists(outputFile)) {\r\n                FileUtil.deleteFile(outputFile);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     *  Extract messages and convert them to ngx translations.\r\n     *  @return the translation objects.\r\n     */\r\n    extract() {\r\n        const result = [];\r\n        this.messagesFile.forEachTransUnit((tu) => {\r\n            const ngxId = this.ngxTranslateIdFromTU(tu);\r\n            if (ngxId) {\r\n                const messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);\r\n                result.push({ id: ngxId, message: messagetext });\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.\r\n     * There are 2 possibilities:\r\n     * 1. description is set to \"ngx-translate\" and meaning contains the id.\r\n     * 2. id is explicitly set to a string.\r\n     * @param tu tu\r\n     * @return an ngx id or null, if this tu should not be extracted.\r\n     */\r\n    ngxTranslateIdFromTU(tu) {\r\n        if (this.isExplicitlySetId(tu.id)) {\r\n            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {\r\n                return tu.id;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        const description = tu.description();\r\n        if (description && this.extractionPattern.isDescriptionMatched(description)) {\r\n            return tu.meaning();\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether ID was explicitly set (via i18n=\"@myid).\r\n     * Just heuristic, an ID is explicitly, if it does not look like a generated one.\r\n     * @param id id\r\n     * @return wether ID was explicitly set (via i18n=\"@myid).\r\n     */\r\n    isExplicitlySetId(id) {\r\n        if (isNullOrUndefined(id)) {\r\n            return false;\r\n        }\r\n        // generated IDs are either decimal or sha1 hex\r\n        const reForGeneratedId = /^[0-9a-f]{11,}$/;\r\n        return !reForGeneratedId.test(id);\r\n    }\r\n    /**\r\n     * Convert list of relevant TUs to ngx translations object.\r\n     * @param msgList msgList\r\n     */\r\n    toNgxTranslations(msgList) {\r\n        const translationObject = {};\r\n        msgList.forEach((msg) => {\r\n            this.putInTranslationObject(translationObject, msg);\r\n        });\r\n        return translationObject;\r\n    }\r\n    /**\r\n     * Put a new messages into the translation data object.\r\n     * If you add, e.g. \"{id: 'myapp.example', message: 'test'}\",\r\n     * the translation object will then contain an object myapp that has property example:\r\n     * {myapp: {\r\n     *   example: 'test'\r\n     *   }}\r\n     * @param translationObject translationObject\r\n     * @param msg msg\r\n     */\r\n    putInTranslationObject(translationObject, msg) {\r\n        let firstPartOfId;\r\n        let restOfId;\r\n        const indexOfDot = msg.id.indexOf('.');\r\n        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {\r\n            throw new Error('bad nxg-translate id \"' + msg.id + '\"');\r\n        }\r\n        if (indexOfDot < 0) {\r\n            firstPartOfId = msg.id;\r\n            restOfId = '';\r\n        }\r\n        else {\r\n            firstPartOfId = msg.id.substring(0, indexOfDot);\r\n            restOfId = msg.id.substring(indexOfDot + 1);\r\n        }\r\n        let object = translationObject[firstPartOfId];\r\n        if (isNullOrUndefined(object)) {\r\n            if (restOfId === '') {\r\n                translationObject[firstPartOfId] = msg.message;\r\n                return;\r\n            }\r\n            object = {};\r\n            translationObject[firstPartOfId] = object;\r\n        }\r\n        else {\r\n            if (restOfId === '') {\r\n                throw new Error('duplicate id praefix \"' + msg.id + '\"');\r\n            }\r\n        }\r\n        this.putInTranslationObject(object, { id: restOfId, message: msg.message });\r\n    }\r\n}\r\nNgxTranslateExtractor.DefaultExtractionPattern = '@@|ngx-translate';\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * Collection of all parameters used by the tool.\r\n * The parameters are read form the profile or defaults are used.\r\n */\r\nconst PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];\r\nclass XliffMergeParameters {\r\n    constructor() {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n    }\r\n    /**\r\n     * Create Parameters.\r\n     * @param options command options\r\n     * @param profileContent given profile (if not, it is read from the profile path from options).\r\n     */\r\n    static createFromOptions(options, profileContent) {\r\n        const parameters = new XliffMergeParameters();\r\n        parameters.configure(options, profileContent);\r\n        return parameters;\r\n    }\r\n    /**\r\n     * Read potential profile.\r\n     * To be a candidate, file must exist and contain property \"xliffmergeOptions\".\r\n     * @param profilePath path of profile\r\n     * @return parsed content of file or null, if file does not exist or is not a profile candidate.\r\n     */\r\n    static readProfileCandidate(profilePath) {\r\n        let content;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        const parsedContent = JSON.parse(content);\r\n        if (parsedContent && parsedContent.xliffmergeOptions) {\r\n            return parsedContent;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize me from the profile content.\r\n     * (public only for test usage).\r\n     * @param options options given at runtime via command line\r\n     * @param profileContent if null, read it from profile.\r\n     */\r\n    configure(options, profileContent) {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n        if (!profileContent) {\r\n            profileContent = this.readProfile(options);\r\n        }\r\n        const validProfile = (!!profileContent);\r\n        if (options.quiet) {\r\n            this._quiet = options.quiet;\r\n        }\r\n        if (options.verbose) {\r\n            this._verbose = options.verbose;\r\n        }\r\n        if (validProfile) {\r\n            this.initializeFromConfig(profileContent);\r\n            // if languages are given as parameters, they ovveride everything said in profile\r\n            if (!!options.languages && options.languages.length > 0) {\r\n                this._languages = options.languages;\r\n                if (!this._defaultLanguage) {\r\n                    this._defaultLanguage = this._languages[0];\r\n                }\r\n            }\r\n            this.checkParameters();\r\n        }\r\n    }\r\n    /**\r\n     * Read profile.\r\n     * @param options program options\r\n     * @return the read profile (empty, if none, null if errors)\r\n     */\r\n    readProfile(options) {\r\n        const profilePath = options.profilePath;\r\n        if (!profilePath) {\r\n            for (const configfilename of PROFILE_CANDIDATES) {\r\n                const profile = XliffMergeParameters.readProfileCandidate(configfilename);\r\n                if (profile) {\r\n                    this.usedProfilePath = configfilename;\r\n                    return profile;\r\n                }\r\n            }\r\n            return {};\r\n        }\r\n        let content;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        }\r\n        catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('could not read profile \"' + profilePath + '\"'));\r\n            return null;\r\n        }\r\n        this.usedProfilePath = profilePath;\r\n        const profileContent = JSON.parse(content);\r\n        // replace all pathes in options by absolute paths\r\n        const xliffmergeOptions = profileContent.xliffmergeOptions;\r\n        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);\r\n        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);\r\n        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);\r\n        return profileContent;\r\n    }\r\n    adjustPathToProfilePath(profilePath, pathToAdjust) {\r\n        if (!pathToAdjust || isAbsolute(pathToAdjust)) {\r\n            return pathToAdjust;\r\n        }\r\n        return join(dirname(profilePath), pathToAdjust).replace(/\\\\/g, '/');\r\n    }\r\n    initializeFromConfig(profileContent) {\r\n        if (!profileContent) {\r\n            return;\r\n        }\r\n        const profile = profileContent.xliffmergeOptions;\r\n        if (profile) {\r\n            if (!isNullOrUndefined(profile.quiet)) {\r\n                this._quiet = profile.quiet;\r\n            }\r\n            if (!isNullOrUndefined(profile.verbose)) {\r\n                this._verbose = profile.verbose;\r\n            }\r\n            if (!isNullOrUndefined(profile.allowIdChange)) {\r\n                this._allowIdChange = profile.allowIdChange;\r\n            }\r\n            if (profile.defaultLanguage) {\r\n                this._defaultLanguage = profile.defaultLanguage;\r\n            }\r\n            if (profile.languages) {\r\n                this._languages = profile.languages;\r\n            }\r\n            if (profile.srcDir) {\r\n                this._srcDir = profile.srcDir;\r\n            }\r\n            if (profile.angularCompilerOptions) {\r\n                if (profile.angularCompilerOptions.genDir) {\r\n                    this._genDir = profile.angularCompilerOptions.genDir;\r\n                }\r\n            }\r\n            if (profile.genDir) {\r\n                // this must be after angularCompilerOptions to be preferred\r\n                this._genDir = profile.genDir;\r\n            }\r\n            if (profile.i18nBaseFile) {\r\n                this._i18nBaseFile = profile.i18nBaseFile;\r\n            }\r\n            if (profile.i18nFile) {\r\n                this._i18nFile = profile.i18nFile;\r\n            }\r\n            if (profile.i18nFormat) {\r\n                this._i18nFormat = profile.i18nFormat;\r\n            }\r\n            if (profile.encoding) {\r\n                this._encoding = profile.encoding;\r\n            }\r\n            if (!isNullOrUndefined(profile.removeUnusedIds)) {\r\n                this._removeUnusedIds = profile.removeUnusedIds;\r\n            }\r\n            if (!isNullOrUndefined(profile.supportNgxTranslate)) {\r\n                this._supportNgxTranslate = profile.supportNgxTranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {\r\n                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;\r\n            }\r\n            if (!isNullOrUndefined(profile.useSourceAsTarget)) {\r\n                this._useSourceAsTarget = profile.useSourceAsTarget;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetPraefix)) {\r\n                this._targetPraefix = profile.targetPraefix;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetSuffix)) {\r\n                this._targetSuffix = profile.targetSuffix;\r\n            }\r\n            if (!isNullOrUndefined(profile.autotranslate)) {\r\n                this._autotranslate = profile.autotranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.beautifyOutput)) {\r\n                this._beautifyOutput = profile.beautifyOutput;\r\n            }\r\n            if (!isNullOrUndefined(profile.preserveOrder)) {\r\n                this._preserveOrder = profile.preserveOrder;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikey)) {\r\n                this._apikey = profile.apikey;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikeyfile)) {\r\n                this._apikeyfile = profile.apikeyfile;\r\n            }\r\n        }\r\n        else {\r\n            this.warningsFound.push('did not find \"xliffmergeOptions\" in profile, using defaults');\r\n        }\r\n    }\r\n    /**\r\n     * Check all Parameters, wether they are complete and consistent.\r\n     * if something is wrong with the parameters, it is collected in errorsFound.\r\n     */\r\n    checkParameters() {\r\n        this.checkLanguageSyntax(this.defaultLanguage());\r\n        if (this.languages().length === 0) {\r\n            this.errorsFound.push(new XliffMergeError('no languages specified'));\r\n        }\r\n        this.languages().forEach((lang) => {\r\n            this.checkLanguageSyntax(lang);\r\n        });\r\n        let stats;\r\n        let err;\r\n        // srcDir should exists\r\n        try {\r\n            stats = fs.statSync(this.srcDir());\r\n        }\r\n        catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('srcDir \"' + this.srcDir() + '\" is not a directory'));\r\n        }\r\n        // genDir should exists\r\n        try {\r\n            stats = fs.statSync(this.genDir());\r\n        }\r\n        catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('genDir \"' + this.genDir() + '\" is not a directory'));\r\n        }\r\n        // master file MUST exist\r\n        try {\r\n            fs.accessSync(this.i18nFile(), fs.constants.R_OK);\r\n        }\r\n        catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFile \"' + this.i18nFile() + '\" is not readable'));\r\n        }\r\n        // i18nFormat must be xlf xlf2 or xmb\r\n        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFormat \"' + this.i18nFormat() + '\" invalid, must be \"xlf\" or \"xlf2\" or \"xmb\"'));\r\n        }\r\n        // autotranslate requires api key\r\n        if (this.autotranslate() && !this.apikey()) {\r\n            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));\r\n        }\r\n        // autotranslated languages must be in list of all languages\r\n        this.autotranslatedLanguages().forEach((lang) => {\r\n            if (this.languages().indexOf(lang) < 0) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" is not in list of languages'));\r\n            }\r\n            if (lang === this.defaultLanguage()) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" cannot be translated, because it is the source language'));\r\n            }\r\n        });\r\n        // ngx translate pattern check\r\n        if (this.supportNgxTranslate()) {\r\n            const checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());\r\n            if (!isNullOrUndefined(checkResult)) {\r\n                this.errorsFound.push(new XliffMergeError('ngxTranslateExtractionPattern \"' + this.ngxTranslateExtractionPattern() + '\": ' + checkResult));\r\n            }\r\n        }\r\n        // targetPraefix and targetSuffix check\r\n        if (!this.useSourceAsTarget()) {\r\n            if (this.targetPraefix().length > 0) {\r\n                this.warningsFound.push('configured targetPraefix \"' + this.targetPraefix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n            if (this.targetSuffix().length > 0) {\r\n                this.warningsFound.push('configured targetSuffix \"' + this.targetSuffix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check syntax of language.\r\n     * Must be compatible with XML Schema type xsd:language.\r\n     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*\r\n     * @param lang language to check\r\n     */\r\n    checkLanguageSyntax(lang) {\r\n        const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;\r\n        if (!pattern.test(lang)) {\r\n            this.errorsFound.push(new XliffMergeError('language \"' + lang + '\" is not valid'));\r\n        }\r\n    }\r\n    allowIdChange() {\r\n        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;\r\n    }\r\n    verbose() {\r\n        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;\r\n    }\r\n    quiet() {\r\n        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;\r\n    }\r\n    /**\r\n     * Debug output all parameters to commandOutput.\r\n     */\r\n    showAllParameters(commandOutput) {\r\n        commandOutput.debug('xliffmerge Used Parameters:');\r\n        commandOutput.debug('usedProfilePath:\\t\"%s\"', this.usedProfilePath);\r\n        commandOutput.debug('defaultLanguage:\\t\"%s\"', this.defaultLanguage());\r\n        commandOutput.debug('srcDir:\\t\"%s\"', this.srcDir());\r\n        commandOutput.debug('genDir:\\t\"%s\"', this.genDir());\r\n        commandOutput.debug('i18nBaseFile:\\t\"%s\"', this.i18nBaseFile());\r\n        commandOutput.debug('i18nFile:\\t\"%s\"', this.i18nFile());\r\n        commandOutput.debug('languages:\\t%s', this.languages());\r\n        for (const language of this.languages()) {\r\n            commandOutput.debug('outputFile[%s]:\\t%s', language, this.generatedI18nFile(language));\r\n        }\r\n        commandOutput.debug('removeUnusedIds:\\t%s', this.removeUnusedIds());\r\n        commandOutput.debug('supportNgxTranslate:\\t%s', this.supportNgxTranslate());\r\n        if (this.supportNgxTranslate()) {\r\n            commandOutput.debug('ngxTranslateExtractionPattern:\\t%s', this.ngxTranslateExtractionPattern());\r\n        }\r\n        commandOutput.debug('useSourceAsTarget:\\t%s', this.useSourceAsTarget());\r\n        if (this.useSourceAsTarget()) {\r\n            commandOutput.debug('targetPraefix:\\t\"%s\"', this.targetPraefix());\r\n            commandOutput.debug('targetSuffix:\\t\"%s\"', this.targetSuffix());\r\n        }\r\n        commandOutput.debug('allowIdChange:\\t%s', this.allowIdChange());\r\n        commandOutput.debug('beautifyOutput:\\t%s', this.beautifyOutput());\r\n        commandOutput.debug('preserveOrder:\\t%s', this.preserveOrder());\r\n        commandOutput.debug('autotranslate:\\t%s', this.autotranslate());\r\n        if (this.autotranslate()) {\r\n            commandOutput.debug('autotranslated languages:\\t%s', this.autotranslatedLanguages());\r\n            commandOutput.debug('apikey:\\t%s', this.apikey() ? '****' : 'NOT SET');\r\n            commandOutput.debug('apikeyfile:\\t%s', this.apikeyfile());\r\n        }\r\n    }\r\n    /**\r\n     * Default-Language, default en.\r\n     * @return default language\r\n     */\r\n    defaultLanguage() {\r\n        return this._defaultLanguage ? this._defaultLanguage : 'en';\r\n    }\r\n    /**\r\n     * Liste der zu bearbeitenden Sprachen.\r\n     * @return languages\r\n     */\r\n    languages() {\r\n        return this._languages ? this._languages : [];\r\n    }\r\n    /**\r\n     * src directory, where the master xlif is located.\r\n     * @return srcDir\r\n     */\r\n    srcDir() {\r\n        return this._srcDir ? this._srcDir : '.';\r\n    }\r\n    /**\r\n     * The base file name of the xlif file for input and output.\r\n     * Default is messages\r\n     * @return base file\r\n     */\r\n    i18nBaseFile() {\r\n        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';\r\n    }\r\n    /**\r\n     * The master xlif file (the one generated by ng-xi18n).\r\n     * Default is <srcDir>/<i18nBaseFile>.xlf.\r\n     * @return master file\r\n     */\r\n    i18nFile() {\r\n        return join(this.srcDir(), (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())).replace(/\\\\/g, '/');\r\n    }\r\n    /**\r\n     * Format of the master xlif file.\r\n     * Default is \"xlf\", possible are \"xlf\" or \"xlf2\" or \"xmb\".\r\n     * @return format\r\n     */\r\n    i18nFormat() {\r\n        return (this._i18nFormat ? this._i18nFormat : 'xlf');\r\n    }\r\n    /**\r\n     * potentially to be generated I18n-File with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    generatedI18nFile(lang) {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\\\/g, '/');\r\n    }\r\n    suffixForGeneratedI18nFile() {\r\n        switch (this.i18nFormat()) {\r\n            case 'xlf':\r\n                return 'xlf';\r\n            case 'xlf2':\r\n                return 'xlf';\r\n            case 'xmb':\r\n                return 'xtb';\r\n        }\r\n    }\r\n    /**\r\n     * potentially to be generated translate-File for ngx-translate with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    generatedNgxTranslateFile(lang) {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\\\/g, '/');\r\n    }\r\n    /**\r\n     * The encoding used to write new XLIFF-files.\r\n     * @return encoding\r\n     */\r\n    encoding() {\r\n        return this._encoding ? this._encoding : 'utf-8';\r\n    }\r\n    /**\r\n     * Output-Directory, where the output is written to.\r\n     * Default is <srcDir>.\r\n    */\r\n    genDir() {\r\n        return this._genDir ? this._genDir : this.srcDir();\r\n    }\r\n    removeUnusedIds() {\r\n        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;\r\n    }\r\n    supportNgxTranslate() {\r\n        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;\r\n    }\r\n    ngxTranslateExtractionPattern() {\r\n        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?\r\n            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;\r\n    }\r\n    /**\r\n     * Whether source must be used as target for new trans-units\r\n     * Default is true\r\n     */\r\n    useSourceAsTarget() {\r\n        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;\r\n    }\r\n    /**\r\n     * Praefix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    targetPraefix() {\r\n        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;\r\n    }\r\n    /**\r\n     * Suffix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    targetSuffix() {\r\n        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;\r\n    }\r\n    /**\r\n     * If set, run xml result through beautifier (pretty-data).\r\n     */\r\n    beautifyOutput() {\r\n        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;\r\n    }\r\n    /**\r\n     * If set, order of new trans units will be as in master.\r\n     * Otherwise they are added at the end.\r\n     */\r\n    preserveOrder() {\r\n        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;\r\n    }\r\n    /**\r\n     * Whether to use autotranslate for new trans-units\r\n     * Default is false\r\n     */\r\n    autotranslate() {\r\n        if (isNullOrUndefined(this._autotranslate)) {\r\n            return false;\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return this._autotranslate.length > 0;\r\n        }\r\n        return this._autotranslate;\r\n    }\r\n    /**\r\n     * Whether to use autotranslate for a given language.\r\n     * @param lang language code.\r\n     */\r\n    autotranslateLanguage(lang) {\r\n        return this.autotranslatedLanguages().indexOf(lang) >= 0;\r\n    }\r\n    /**\r\n     * Return a list of languages to be autotranslated.\r\n     */\r\n    autotranslatedLanguages() {\r\n        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {\r\n            return [];\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return this._autotranslate;\r\n        }\r\n        return this.languages().slice(1); // first is source language\r\n    }\r\n    /**\r\n     * API key to be used for Google Translate\r\n     * @return api key\r\n     */\r\n    apikey() {\r\n        if (!isNullOrUndefined(this._apikey)) {\r\n            return this._apikey;\r\n        }\r\n        else {\r\n            const apikeyPath = this.apikeyfile();\r\n            if (this.apikeyfile()) {\r\n                if (fs.existsSync(apikeyPath)) {\r\n                    return FileUtil.read(apikeyPath, 'utf-8');\r\n                }\r\n                else {\r\n                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * file name for API key to be used for Google Translate.\r\n     * Explicitly set or read from env var API_KEY_FILE.\r\n     * @return file of api key\r\n     */\r\n    apikeyfile() {\r\n        if (this._apikeyfile) {\r\n            return this._apikeyfile;\r\n        }\r\n        else if (process.env.API_KEY_FILE) {\r\n            return process.env.API_KEY_FILE;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 19.02.2017.\r\n */\r\nlet pkg = null;\r\ntry {\r\n    pkg = require(path.resolve(__dirname, '..', 'package.json'));\r\n}\r\ncatch (e) {\r\n    try {\r\n        pkg = require(path.resolve(__dirname, '..', '..', 'package.json'));\r\n    }\r\n    catch (e) {\r\n        pkg = null;\r\n    }\r\n}\r\nconst VERSION = (pkg ? pkg.version : 'unknown');\n\n/**\r\n * Created by martin on 10.03.2017.\r\n * Helper class to read XMl with a correct encoding.\r\n */\r\nclass XmlReader {\r\n    /**\r\n     * Read an xml-File.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return file content and encoding found in the file.\r\n     */\r\n    static readXmlFileContent(path, encoding) {\r\n        if (!encoding) {\r\n            encoding = XmlReader.DEFAULT_ENCODING;\r\n        }\r\n        let content = FileUtil.read(path, encoding);\r\n        const foundEncoding = XmlReader.encodingFromXml(content);\r\n        if (foundEncoding !== encoding) {\r\n            // read again with the correct encoding\r\n            content = FileUtil.read(path, foundEncoding);\r\n        }\r\n        return {\r\n            content: content,\r\n            encoding: foundEncoding\r\n        };\r\n    }\r\n    /**\r\n     * Read the encoding from the xml.\r\n     * xml File starts with .. encoding=\"..\"\r\n     * @param xmlString xmlString\r\n     * @return encoding\r\n     */\r\n    static encodingFromXml(xmlString) {\r\n        const index = xmlString.indexOf('encoding=\"');\r\n        if (index < 0) {\r\n            return this.DEFAULT_ENCODING; // default in xml if not explicitly set\r\n        }\r\n        const endIndex = xmlString.indexOf('\"', index + 10); // 10 = length of 'encoding=\"'\r\n        return xmlString.substring(index + 10, endIndex);\r\n    }\r\n}\r\nXmlReader.DEFAULT_ENCODING = 'utf-8';\n\n/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\n/**\r\n * Helper class to read translation files depending on format.\r\n */\r\nclass TranslationMessagesFileReader {\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat format\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    static fromFile(i18nFormat, path, encoding, optionalMasterFilePath) {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    static fromUnknownFormatFile(path, encoding, optionalMasterFilePath) {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read master xmb file\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @param encoding encoding\r\n     * @return content and encoding of file\r\n     */\r\n    static masterFileContent(optionalMasterFilePath, encoding) {\r\n        if (optionalMasterFilePath) {\r\n            const masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);\r\n            return {\r\n                xmlContent: masterXmlContent.content,\r\n                path: optionalMasterFilePath,\r\n                encoding: masterXmlContent.encoding\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Save edited file.\r\n     * @param messagesFile messagesFile\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    static save(messagesFile, beautifyOutput) {\r\n        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding());\r\n    }\r\n}\n\nconst MAX_SEGMENTS = 128;\r\nclass AutoTranslateService {\r\n    constructor(apiKey) {\r\n        this._request = request;\r\n        this._apiKey = apiKey;\r\n        this._rootUrl = 'https://translation.googleapis.com/';\r\n    }\r\n    /**\r\n     * Strip region code and convert to lower\r\n     * @param lang lang\r\n     * @return lang without region code and in lower case.\r\n     */\r\n    static stripRegioncode(lang) {\r\n        const langLower = lang.toLowerCase();\r\n        for (let i = 0; i < langLower.length; i++) {\r\n            const c = langLower.charAt(i);\r\n            if (c < 'a' || c > 'z') {\r\n                return langLower.substring(0, i);\r\n            }\r\n        }\r\n        return langLower;\r\n    }\r\n    /**\r\n     * Change API key (just for tests).\r\n     * @param apikey apikey\r\n     */\r\n    setApiKey(apikey) {\r\n        this._apiKey = apikey;\r\n    }\r\n    /**\r\n     * Translate an array of messages at once.\r\n     * @param messages the messages to be translated\r\n     * @param from source language code\r\n     * @param to target language code\r\n     * @return Observable with translated messages or error\r\n     */\r\n    translateMultipleStrings(messages, from, to) {\r\n        // empty array needs no translation and always works ... (#78)\r\n        if (messages.length === 0) {\r\n            return of([]);\r\n        }\r\n        if (!this._apiKey) {\r\n            return throwError('cannot autotranslate: no api key');\r\n        }\r\n        if (!from || !to) {\r\n            return throwError('cannot autotranslate: source and target language must be set');\r\n        }\r\n        from = AutoTranslateService.stripRegioncode(from);\r\n        to = AutoTranslateService.stripRegioncode(to);\r\n        const allRequests = this.splitMessagesToGoogleLimit(messages).map((partialMessages) => {\r\n            return this.limitedTranslateMultipleStrings(partialMessages, from, to);\r\n        });\r\n        return forkJoin(allRequests).pipe(map((allTranslations) => {\r\n            let all = [];\r\n            for (let i = 0; i < allTranslations.length; i++) {\r\n                all = all.concat(allTranslations[i]);\r\n            }\r\n            return all;\r\n        }));\r\n    }\r\n    splitMessagesToGoogleLimit(messages) {\r\n        if (messages.length <= MAX_SEGMENTS) {\r\n            return [messages];\r\n        }\r\n        const result = [];\r\n        let currentPackage = [];\r\n        let packageSize = 0;\r\n        for (let i = 0; i < messages.length; i++) {\r\n            currentPackage.push(messages[i]);\r\n            packageSize++;\r\n            if (packageSize >= MAX_SEGMENTS) {\r\n                result.push(currentPackage);\r\n                currentPackage = [];\r\n                packageSize = 0;\r\n            }\r\n        }\r\n        if (currentPackage.length > 0) {\r\n            result.push(currentPackage);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Return translation request, but messages must be limited to google limits.\r\n     * Not more that 128 single messages.\r\n     * @param messages messages\r\n     * @param from from\r\n     * @param to to\r\n     * @return the translated strings\r\n     */\r\n    limitedTranslateMultipleStrings(messages, from, to) {\r\n        const realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;\r\n        const translateRequest = {\r\n            q: messages,\r\n            target: to,\r\n            source: from,\r\n        };\r\n        const options = {\r\n            url: realUrl,\r\n            body: translateRequest,\r\n            json: true,\r\n            //            proxy: 'http://127.0.0.1:8888' To set a proxy use env var HTTPS_PROXY\r\n        };\r\n        return this.post(realUrl, options).pipe(map((data) => {\r\n            const body = data.body;\r\n            if (!body) {\r\n                throw new Error('no result received');\r\n            }\r\n            if (body.error) {\r\n                if (body.error.code === 400) {\r\n                    if (body.error.message === 'Invalid Value') {\r\n                        throw new Error(format('Translation from \"%s\" to \"%s\" not supported', from, to));\r\n                    }\r\n                    throw new Error(format('Invalid request: %s', body.error.message));\r\n                }\r\n                else {\r\n                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));\r\n                }\r\n            }\r\n            const result = body.data;\r\n            return result.translations.map((translation) => {\r\n                return translation.translatedText;\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * Function to do a POST HTTP request\r\n     *\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     */\r\n    post(uri, options) {\r\n        return this._call.apply(this, [].concat('post', uri, Object.assign({}, options || {})));\r\n    }\r\n    /**\r\n     * Function to do a HTTP request for given method\r\n     *\r\n     * @param method method\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     *\r\n     */\r\n    _call(method, uri, options) {\r\n        return Observable.create((observer) => {\r\n            // build params array\r\n            const params = [].concat(uri, Object.assign({}, options || {}), (error, response, body) => {\r\n                if (error) {\r\n                    return observer.error(error);\r\n                }\r\n                observer.next(Object.assign({}, {\r\n                    response: response,\r\n                    body: body\r\n                }));\r\n                observer.complete();\r\n            });\r\n            // _call request method\r\n            try {\r\n                this._request[method].apply(this._request, params);\r\n            }\r\n            catch (error) {\r\n                observer.error(error);\r\n            }\r\n        });\r\n    }\r\n}\n\n/**\r\n * Created by martin on 29.06.2017.\r\n */\r\nclass AutoTranslateResult {\r\n    constructor(_success, _details) {\r\n        this._success = _success;\r\n        this._details = _details;\r\n    }\r\n    success() {\r\n        return this._success;\r\n    }\r\n}\n\n/**\r\n * A report about a run of Google Translate over all untranslated unit.\r\n * * Created by martin on 29.06.2017.\r\n */\r\nclass AutoTranslateSummaryReport {\r\n    constructor(from, to) {\r\n        this._from = from;\r\n        this._to = to;\r\n        this._total = 0;\r\n        this._ignored = 0;\r\n        this._success = 0;\r\n        this._failed = 0;\r\n    }\r\n    /**\r\n     * Set error if total call failed (e.g. \"invalid api key\" or \"no connection\" ...)\r\n     * @param error error\r\n     * @param total total\r\n     */\r\n    setError(error, total) {\r\n        this._error = error;\r\n        this._total = total;\r\n        this._failed = total;\r\n    }\r\n    error() {\r\n        return this._error;\r\n    }\r\n    setIgnored(ignored) {\r\n        this._total += ignored;\r\n        this._ignored = ignored;\r\n    }\r\n    /**\r\n     * Add a single result to the summary.\r\n     * @param tu tu\r\n     * @param result result\r\n     */\r\n    addSingleResult(tu, result) {\r\n        this._total++;\r\n        if (result.success()) {\r\n            this._success++;\r\n        }\r\n        else {\r\n            this._failed++;\r\n        }\r\n    }\r\n    /**\r\n     * Merge another summary into this one.\r\n     * @param anotherSummary anotherSummary\r\n     */\r\n    merge(anotherSummary) {\r\n        if (!this._error) {\r\n            this._error = anotherSummary._error;\r\n        }\r\n        this._total += anotherSummary.total();\r\n        this._ignored += anotherSummary.ignored();\r\n        this._success += anotherSummary.success();\r\n        this._failed += anotherSummary.failed();\r\n    }\r\n    total() {\r\n        return this._total;\r\n    }\r\n    ignored() {\r\n        return this._ignored;\r\n    }\r\n    success() {\r\n        return this._success;\r\n    }\r\n    failed() {\r\n        return this._failed;\r\n    }\r\n    /**\r\n     * Human readable version of report\r\n     */\r\n    content() {\r\n        let result;\r\n        if (this._error) {\r\n            result = format('Auto translation from \"%s\" to \"%s\" failed: \"%s\", failed units: %s', this._from, this._to, this._error, this._failed);\r\n        }\r\n        else {\r\n            result = format('Auto translation from \"%s\" to \"%s\", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s', this._from, this._to, this._total, this._ignored, this._success, this._failed);\r\n        }\r\n        return result;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 07.07.2017.\r\n * Service to autotranslate Transunits via Google Translate.\r\n */\r\nclass XliffMergeAutoTranslateService {\r\n    constructor(apikey) {\r\n        this.autoTranslateService = new AutoTranslateService(apikey);\r\n    }\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    autoTranslate(from, to, languageSpecificMessagesFile) {\r\n        return forkJoin([\r\n            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile),\r\n            ...this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)\r\n        ])\r\n            .pipe(map((summaries) => {\r\n            const summary = summaries[0];\r\n            for (let i = 1; i < summaries.length; i++) {\r\n                summary.merge(summaries[i]);\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n    /**\r\n     * Collect all units that are untranslated.\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return all untranslated units\r\n     */\r\n    allUntranslatedTUs(languageSpecificMessagesFile) {\r\n        // collect all units, that should be auto translated\r\n        const allUntranslated = [];\r\n        languageSpecificMessagesFile.forEachTransUnit((tu) => {\r\n            if (tu.targetState() === STATE_NEW) {\r\n                allUntranslated.push(tu);\r\n            }\r\n        });\r\n        return allUntranslated;\r\n    }\r\n    doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile) {\r\n        const allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatable = allUntranslated.filter((tu) => isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        const allMessages = allTranslatable.map((tu) => {\r\n            return tu.sourceContentNormalized().asDisplayString();\r\n        });\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n        // #94 google translate might return &#.. entity refs, that must be decoded\r\n        map((translations) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))), map((translations) => {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(allUntranslated.length - allTranslatable.length);\r\n            for (let i = 0; i < translations.length; i++) {\r\n                const tu = allTranslatable[i];\r\n                const translationText = translations[i];\r\n                const result = this.autoTranslateNonICUUnit(tu, translationText);\r\n                summary.addSingleResult(tu, result);\r\n            }\r\n            return summary;\r\n        }), catchError((err) => {\r\n            const failSummary = new AutoTranslateSummaryReport(from, to);\r\n            failSummary.setError(err.message, allMessages.length);\r\n            return of(failSummary);\r\n        }));\r\n    }\r\n    doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile) {\r\n        const allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatableICU = allUntranslated.filter((tu) => !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        return allTranslatableICU.map((tu) => {\r\n            return this.doAutoTranslateICUMessage(from, to, tu);\r\n        });\r\n    }\r\n    /**\r\n     * Translate single ICU Messages.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tu transunit to translate (must contain ICU Message)\r\n     * @return summary report\r\n     */\r\n    doAutoTranslateICUMessage(from, to, tu) {\r\n        const icuMessage = tu.sourceContentNormalized().getICUMessage();\r\n        const categories = icuMessage.getCategories();\r\n        // check for nested ICUs, we do not support that\r\n        if (categories.find((category) => !isNullOrUndefined(category.getMessageNormalized().getICUMessage()))) {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(1);\r\n            return of(summary);\r\n        }\r\n        const allMessages = categories.map((category) => category.getMessageNormalized().asDisplayString());\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n        // #94 google translate might return &#.. entity refs, that must be decoded\r\n        map((translations) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))), map((translations) => {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            const icuTranslation = {};\r\n            for (let i = 0; i < translations.length; i++) {\r\n                icuTranslation[categories[i].getCategory()] = translations[i];\r\n            }\r\n            const result = this.autoTranslateICUUnit(tu, icuTranslation);\r\n            summary.addSingleResult(tu, result);\r\n            return summary;\r\n        }), catchError((err) => {\r\n            const failSummary = new AutoTranslateSummaryReport(from, to);\r\n            failSummary.setError(err.message, allMessages.length);\r\n            return of(failSummary);\r\n        }));\r\n    }\r\n    autoTranslateNonICUUnit(tu, translatedMessage) {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));\r\n    }\r\n    autoTranslateICUUnit(tu, translation) {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));\r\n    }\r\n    autoTranslateUnit(tu, translatedMessage) {\r\n        const errors = translatedMessage.validate();\r\n        const warnings = translatedMessage.validateWarnings();\r\n        if (!isNullOrUndefined(errors)) {\r\n            return new AutoTranslateResult(false, 'errors detected, not translated');\r\n        }\r\n        else if (!isNullOrUndefined(warnings)) {\r\n            return new AutoTranslateResult(false, 'warnings detected, not translated');\r\n        }\r\n        else {\r\n            tu.translate(translatedMessage);\r\n            return new AutoTranslateResult(true, null); // success\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.\r\n *\r\n */\r\nclass XliffMerge {\r\n    constructor(commandOutput, options) {\r\n        this.commandOutput = commandOutput;\r\n        this.options = options;\r\n        this.parameters = null;\r\n    }\r\n    static main(argv) {\r\n        const options = XliffMerge.parseArgs(argv);\r\n        if (options) {\r\n            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {\r\n                process.exit(result);\r\n            });\r\n        }\r\n    }\r\n    static parseArgs(argv) {\r\n        const options = {\r\n            languages: []\r\n        };\r\n        for (let i = 1; i < argv.length; i++) {\r\n            const arg = argv[i];\r\n            if (arg === '--version' || arg === '-version') {\r\n                console.log('xliffmerge ' + VERSION);\r\n            }\r\n            else if (arg === '--verbose' || arg === '-v') {\r\n                options.verbose = true;\r\n            }\r\n            else if (arg === '--profile' || arg === '-p') {\r\n                i++;\r\n                if (i >= argv.length) {\r\n                    console.log('missing config file');\r\n                    XliffMerge.showUsage();\r\n                    return null;\r\n                }\r\n                else {\r\n                    options.profilePath = argv[i];\r\n                }\r\n            }\r\n            else if (arg === '--quiet' || arg === '-q') {\r\n                options.quiet = true;\r\n            }\r\n            else if (arg === '--help' || arg === '-help' || arg === '-h') {\r\n                XliffMerge.showUsage();\r\n            }\r\n            else if (arg.length > 0 && arg.charAt(0) === '-') {\r\n                console.log('unknown option');\r\n                return null;\r\n            }\r\n            else {\r\n                options.languages.push(arg);\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n    static showUsage() {\r\n        console.log('usage: xliffmerge <option>* <language>*');\r\n        console.log('Options');\r\n        console.log('\\t-p|--profile a json configuration file containing all relevant parameters.');\r\n        console.log('\\t\\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');\r\n        console.log('\\t-v|--verbose show some output for debugging purposes');\r\n        console.log('\\t-q|--quiet only show errors, nothing else');\r\n        console.log('\\t-version|--version show version string');\r\n        console.log('');\r\n        console.log('\\t<language> has to be a valid language short string, e,g. \"en\", \"de\", \"de-ch\"');\r\n    }\r\n    /**\r\n     * For Tests, create instance with given profile\r\n     * @param commandOutput commandOutput\r\n     * @param options options\r\n     * @param profileContent profileContent\r\n     */\r\n    static createFromOptions(commandOutput, options, profileContent) {\r\n        const instance = new XliffMerge(commandOutput, options);\r\n        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);\r\n        return instance;\r\n    }\r\n    /**\r\n     * Run the command.\r\n     * This runs async.\r\n     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.\r\n     * @param errorFunction callbackFunction for error handling\r\n     */\r\n    run(callbackFunction, errorFunction) {\r\n        this.runAsync()\r\n            .subscribe((retcode) => {\r\n            if (!isNullOrUndefined(callbackFunction)) {\r\n                callbackFunction(retcode);\r\n            }\r\n        }, (error) => {\r\n            if (!isNullOrUndefined(errorFunction)) {\r\n                errorFunction(error);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Execute merge-Process.\r\n     * @return Async operation, on completion returns retcode 0=ok, other = error.\r\n     */\r\n    runAsync() {\r\n        if (this.options && this.options.quiet) {\r\n            this.commandOutput.setQuiet();\r\n        }\r\n        if (this.options && this.options.verbose) {\r\n            this.commandOutput.setVerbose();\r\n        }\r\n        if (!this.parameters) {\r\n            this.parameters = XliffMergeParameters.createFromOptions(this.options);\r\n        }\r\n        this.commandOutput.info('xliffmerge version %s', VERSION);\r\n        if (this.parameters.verbose()) {\r\n            this.parameters.showAllParameters(this.commandOutput);\r\n        }\r\n        if (this.parameters.errorsFound.length > 0) {\r\n            for (const err of this.parameters.errorsFound) {\r\n                this.commandOutput.error(err.message);\r\n            }\r\n            return of(-1);\r\n        }\r\n        if (this.parameters.warningsFound.length > 0) {\r\n            for (const warn of this.parameters.warningsFound) {\r\n                this.commandOutput.warn(warn);\r\n            }\r\n        }\r\n        this.readMaster();\r\n        if (this.parameters.autotranslate()) {\r\n            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());\r\n        }\r\n        const executionForAllLanguages = [];\r\n        this.parameters.languages().forEach((lang) => {\r\n            executionForAllLanguages.push(this.processLanguage(lang));\r\n        });\r\n        return forkJoin(executionForAllLanguages).pipe(map((retcodes) => this.totalRetcode(retcodes)));\r\n    }\r\n    /**\r\n     * Give an array of retcodes for the different languages, return the total retcode.\r\n     * If all are 0, it is 0, otherwise the first non zero.\r\n     * @param retcodes retcodes\r\n     * @return number\r\n     */\r\n    totalRetcode(retcodes) {\r\n        for (let i = 0; i < retcodes.length; i++) {\r\n            if (retcodes[i] !== 0) {\r\n                return retcodes[i];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Return the name of the generated file for given lang.\r\n     * @param lang language\r\n     * @return name of generated file\r\n     */\r\n    generatedI18nFile(lang) {\r\n        return this.parameters.generatedI18nFile(lang);\r\n    }\r\n    /**\r\n     * Return the name of the generated ngx-translation file for given lang.\r\n     * @param lang language\r\n     * @return name of translate file\r\n     */\r\n    generatedNgxTranslateFile(lang) {\r\n        return this.parameters.generatedNgxTranslateFile(lang);\r\n    }\r\n    /**\r\n     * Warnings found during the run.\r\n     * @return warnings\r\n     */\r\n    warnings() {\r\n        return this.parameters.warningsFound;\r\n    }\r\n    readMaster() {\r\n        try {\r\n            this.master = TranslationMessagesFileReader.fromFile(this.parameters.i18nFormat(), this.parameters.i18nFile(), this.parameters.encoding());\r\n            this.master.warnings().forEach((warning) => {\r\n                this.commandOutput.warn(warning);\r\n            });\r\n            const count = this.master.numberOfTransUnits();\r\n            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();\r\n            this.commandOutput.info('master contains %s trans-units', count);\r\n            if (missingIdCount > 0) {\r\n                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);\r\n            }\r\n            const sourceLang = this.master.sourceLanguage();\r\n            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {\r\n                this.commandOutput.warn('master says to have source-language=\"%s\", should be \"%s\" (your defaultLanguage)', sourceLang, this.parameters.defaultLanguage());\r\n                this.master.setSourceLanguage(this.parameters.defaultLanguage());\r\n                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());\r\n                this.commandOutput.warn('changed master source-language=\"%s\" to \"%s\"', sourceLang, this.parameters.defaultLanguage());\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            }\r\n            else {\r\n                // unhandled\r\n                const currentFilename = this.parameters.i18nFile();\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Process the given language.\r\n     * Async operation.\r\n     * @param lang language\r\n     * @return on completion 0 for ok, other for error\r\n     */\r\n    processLanguage(lang) {\r\n        this.commandOutput.debug('processing language %s', lang);\r\n        const languageXliffFile = this.parameters.generatedI18nFile(lang);\r\n        const currentFilename = languageXliffFile;\r\n        let result;\r\n        if (!FileUtil.exists(languageXliffFile)) {\r\n            result = this.createUntranslatedXliff(lang, languageXliffFile);\r\n        }\r\n        else {\r\n            result = this.mergeMasterTo(lang, languageXliffFile);\r\n        }\r\n        return result\r\n            .pipe(map(() => {\r\n            if (this.parameters.supportNgxTranslate()) {\r\n                const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFile, this.parameters.encoding(), this.master.filename());\r\n                NgxTranslateExtractor.extract(languageSpecificMessagesFile, this.parameters.ngxTranslateExtractionPattern(), this.parameters.generatedNgxTranslateFile(lang));\r\n            }\r\n            return 0;\r\n        }), catchError((err) => {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            }\r\n            else {\r\n                // unhandled\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * create a new file for the language, which contains no translations, but all keys.\r\n     * in principle, this is just a copy of the master with target-language set.\r\n     * @param lang language\r\n     * @param languageXliffFilePath name of file\r\n     */\r\n    createUntranslatedXliff(lang, languageXliffFilePath) {\r\n        // copy master ...\r\n        // and set target-language\r\n        // and copy source to target if necessary\r\n        const isDefaultLang = (lang === this.parameters.defaultLanguage());\r\n        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        const languageSpecificMessagesFile = this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());\r\n        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(map(( /* summary */) => {\r\n            // write it to file\r\n            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n            this.commandOutput.info('created new file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n            if (!isDefaultLang) {\r\n                this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n    /**\r\n     * Map the input format to the format of the translation.\r\n     * Normally they are the same but for xmb the translation format is xtb.\r\n     * @param i18nFormat format\r\n     */\r\n    translationFormat(i18nFormat) {\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return FORMAT_XTB;\r\n        }\r\n        else {\r\n            return i18nFormat;\r\n        }\r\n    }\r\n    /**\r\n     * Merge all\r\n     * @param lang language\r\n     * @param languageXliffFilePath filename\r\n     */\r\n    mergeMasterTo(lang, languageXliffFilePath) {\r\n        // read lang specific file\r\n        const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFilePath, this.parameters.encoding());\r\n        const isDefaultLang = (lang === this.parameters.defaultLanguage());\r\n        let newCount = 0;\r\n        let correctSourceContentCount = 0;\r\n        let correctSourceRefCount = 0;\r\n        let correctDescriptionOrMeaningCount = 0;\r\n        let idChangedCount = 0;\r\n        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        let lastProcessedUnit = null;\r\n        this.master.forEachTransUnit((masterTransUnit) => {\r\n            const transUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);\r\n            if (!transUnit) {\r\n                // oops, no translation, must be a new key, so add it\r\n                let newUnit;\r\n                if (this.parameters.allowIdChange()\r\n                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {\r\n                    lastProcessedUnit = newUnit;\r\n                    idChangedCount++;\r\n                }\r\n                else {\r\n                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, isDefaultLang, this.parameters.useSourceAsTarget(), (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n                    newCount++;\r\n                }\r\n            }\r\n            else {\r\n                // check for changed source content and change it if needed\r\n                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.\r\n                if (transUnit.supportsSetSourceContent() && !this.areSourcesNearlyEqual(masterTransUnit, transUnit)) {\r\n                    transUnit.setSourceContent(masterTransUnit.sourceContent());\r\n                    if (isDefaultLang) {\r\n                        // #81 changed source must be copied to target for default lang\r\n                        transUnit.translate(masterTransUnit.sourceContent());\r\n                        transUnit.setTargetState(STATE_FINAL);\r\n                    }\r\n                    else {\r\n                        if (transUnit.targetState() === STATE_FINAL) {\r\n                            // source is changed, so translation has to be checked again\r\n                            transUnit.setTargetState(STATE_TRANSLATED);\r\n                        }\r\n                    }\r\n                    correctSourceContentCount++;\r\n                }\r\n                // check for missing or changed source ref and add it if needed\r\n                if (transUnit.supportsSetSourceReferences()\r\n                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {\r\n                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());\r\n                    correctSourceRefCount++;\r\n                }\r\n                // check for changed description or meaning\r\n                if (transUnit.supportsSetDescriptionAndMeaning()) {\r\n                    let changed = false;\r\n                    if (transUnit.description() !== masterTransUnit.description()) {\r\n                        transUnit.setDescription(masterTransUnit.description());\r\n                        changed = true;\r\n                    }\r\n                    if (transUnit.meaning() !== masterTransUnit.meaning()) {\r\n                        transUnit.setMeaning(masterTransUnit.meaning());\r\n                        changed = true;\r\n                    }\r\n                    if (changed) {\r\n                        correctDescriptionOrMeaningCount++;\r\n                    }\r\n                }\r\n                lastProcessedUnit = transUnit;\r\n            }\r\n        });\r\n        if (newCount > 0) {\r\n            this.commandOutput.warn('merged %s trans-units from master to \"%s\"', newCount, lang);\r\n        }\r\n        if (correctSourceContentCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed source content from master to \"%s\"', correctSourceContentCount, lang);\r\n        }\r\n        if (correctSourceRefCount > 0) {\r\n            this.commandOutput.warn('transferred %s source references from master to \"%s\"', correctSourceRefCount, lang);\r\n        }\r\n        if (idChangedCount > 0) {\r\n            this.commandOutput.warn('found %s changed id\\'s in \"%s\"', idChangedCount, lang);\r\n        }\r\n        if (correctDescriptionOrMeaningCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed descriptions/meanings from master to \"%s\"', correctDescriptionOrMeaningCount, lang);\r\n        }\r\n        // remove all elements that are no longer used\r\n        let removeCount = 0;\r\n        languageSpecificMessagesFile.forEachTransUnit((transUnit) => {\r\n            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));\r\n            if (!existsInMaster) {\r\n                if (this.parameters.removeUnusedIds()) {\r\n                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);\r\n                }\r\n                removeCount++;\r\n            }\r\n        });\r\n        if (removeCount > 0) {\r\n            if (this.parameters.removeUnusedIds()) {\r\n                this.commandOutput.warn('removed %s unused trans-units in \"%s\"', removeCount, lang);\r\n            }\r\n            else {\r\n                this.commandOutput.warn('keeping %s unused trans-units in \"%s\", because removeUnused is disabled', removeCount, lang);\r\n            }\r\n        }\r\n        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0\r\n            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {\r\n            this.commandOutput.info('file for \"%s\" was up to date', lang);\r\n            return of(null);\r\n        }\r\n        else {\r\n            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)\r\n                .pipe(map(() => {\r\n                // write it to file\r\n                TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n                this.commandOutput.info('updated file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n                if (newCount > 0 && !isDefaultLang) {\r\n                    this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n                }\r\n                return null;\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Handle the case of changed id due to small white space changes.\r\n     * @param masterTransUnit unit in master file\r\n     * @param languageSpecificMessagesFile translation file\r\n     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.\r\n     * @return processed unit, if done, null if no changed unit found\r\n     */\r\n    processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit) {\r\n        let changedTransUnit = null;\r\n        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {\r\n            if (this.areSourcesNearlyEqual(languageTransUnit, masterTransUnit)) {\r\n                changedTransUnit = languageTransUnit;\r\n            }\r\n        });\r\n        if (!changedTransUnit) {\r\n            return null;\r\n        }\r\n        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, false, false, (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n        const translatedContent = changedTransUnit.targetContent();\r\n        if (translatedContent) { // issue #68 set translated only, if it is really translated\r\n            mergedTransUnit.translate(translatedContent);\r\n            mergedTransUnit.setTargetState(STATE_TRANSLATED);\r\n        }\r\n        return mergedTransUnit;\r\n    }\r\n    /**\r\n     * test wether the sources of 2 trans units are equal ignoring white spaces.\r\n     * @param tu1 tu1\r\n     * @param tu2 tu2\r\n     */\r\n    areSourcesNearlyEqual(tu1, tu2) {\r\n        if ((tu1 && !tu2) || (tu2 && !tu1)) {\r\n            return false;\r\n        }\r\n        const tu1Normalized = tu1.sourceContentNormalized();\r\n        const tu2Normalized = tu2.sourceContentNormalized();\r\n        if (tu1Normalized.isICUMessage()) {\r\n            if (tu2Normalized.isICUMessage()) {\r\n                const icu1Normalized = tu1Normalized.getICUMessage().asNativeString().trim();\r\n                const icu2Normalized = tu2Normalized.getICUMessage().asNativeString().trim();\r\n                return icu1Normalized === icu2Normalized;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        if (tu1Normalized.containsICUMessageRef()) {\r\n            const icuref1Normalized = tu1Normalized.asNativeString().trim();\r\n            const icuref2Normalized = tu2Normalized.asNativeString().trim();\r\n            return icuref1Normalized === icuref2Normalized;\r\n        }\r\n        const s1Normalized = tu1Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        const s2Normalized = tu2Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        return s1Normalized === s2Normalized;\r\n    }\r\n    areSourceReferencesEqual(ref1, ref2) {\r\n        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {\r\n            return false;\r\n        }\r\n        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {\r\n            return true;\r\n        }\r\n        // bot refs are set now, convert to set to compare them\r\n        const set1 = new Set();\r\n        ref1.forEach((ref) => { set1.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        const set2 = new Set();\r\n        ref2.forEach((ref) => { set2.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        if (set1.size !== set2.size) {\r\n            return false;\r\n        }\r\n        let match = true;\r\n        set2.forEach((ref) => {\r\n            if (!set1.has(ref)) {\r\n                match = false;\r\n            }\r\n        });\r\n        return match;\r\n    }\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    autoTranslate(from, to, languageSpecificMessagesFile) {\r\n        let serviceCall;\r\n        const autotranslateEnabled = this.parameters.autotranslateLanguage(to);\r\n        if (autotranslateEnabled) {\r\n            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);\r\n        }\r\n        else {\r\n            serviceCall = of(new AutoTranslateSummaryReport(from, to));\r\n        }\r\n        return serviceCall.pipe(map((summary) => {\r\n            if (autotranslateEnabled) {\r\n                if (summary.error() || summary.failed() > 0) {\r\n                    this.commandOutput.error(summary.content());\r\n                }\r\n                else {\r\n                    this.commandOutput.warn(summary.content());\r\n                }\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n}\n\n/*\r\n * Public API Surface of xliffmerge\r\n * In principle, there is only the bin file xliffmerge,\r\n * because this is not mentioned as a library.\r\n * But the tooling uses the configuration file type.\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CommandOutput, WriterToString, XliffMerge, XliffmergeModule };\n//# sourceMappingURL=ngx-i18nsupport-ngx-i18nsupport.mjs.map\n","map":{"version":3,"file":"ngx-i18nsupport-ngx-i18nsupport.mjs","sources":["../../../projects/xliffmerge/src/lib/xliffmerge.module.ts","../../../projects/xliffmerge/src/common/util.ts","../../../projects/xliffmerge/src/common/writer-to-string.ts","../../../projects/xliffmerge/src/common/command-output.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge-error.ts","../../../projects/xliffmerge/src/common/file-util.ts","../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extraction-pattern.ts","../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extractor.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge-parameters.ts","../../../projects/xliffmerge/src/xliffmerge/version.ts","../../../projects/xliffmerge/src/xliffmerge/xml-reader.ts","../../../projects/xliffmerge/src/xliffmerge/translation-messages-file-reader.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-service.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-result.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-summary-report.ts","../../../projects/xliffmerge/src/autotranslate/xliff-merge-auto-translate-service.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge.ts","../../../projects/xliffmerge/src/public_api.ts","../../../projects/xliffmerge/src/ngx-i18nsupport-ngx-i18nsupport.ts"],"sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n// not used, only there to make ng-packagr happy\r\n@NgModule({\r\n    imports: [\r\n    ],\r\n    declarations: [],\r\n    exports: []\r\n})\r\nexport class XliffmergeModule { }\r\n","/**\r\n * Collection of utility functions that are deprecated in nodes util.\r\n */\r\n\r\n/**\r\n * Replaces node isNullOrUndefined.\r\n */\r\nexport function isNullOrUndefined(value: any) {\r\n    return value === undefined || value === null;\r\n}\r\n\r\n/**\r\n * Replaces node isString.\r\n */\r\nexport function isString(value: any) {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Replaces node isBoolean.\r\n */\r\nexport function isBoolean(value: any) {\r\n    return typeof value === 'boolean';\r\n}\r\n\r\n/**\r\n * Replaces node isNumber.\r\n */\r\nexport function isNumber(value: any) {\r\n    return typeof value === 'number';\r\n}\r\n\r\n/**\r\n * Replaces node isArray.\r\n */\r\nexport function isArray(value: any) {\r\n    return Array.isArray(value);\r\n}\r\n","import {Writable} from 'stream';\r\nimport {isString} from './util';\r\n/**\r\n * Created by martin on 20.02.2017.\r\n * A helper class for testing.\r\n * Can be used as a WritableStream and writes everything (synchronously) into a string,\r\n * that can easily be read by the tests.\r\n */\r\n\r\nexport class WriterToString extends Writable {\r\n\r\n    private resultString: string;\r\n\r\n    constructor() {\r\n        super();\r\n        this.resultString = '';\r\n    }\r\n\r\n    public _write(chunk: any, encoding: BufferEncoding, callback: Function): void {\r\n        let chunkString;\r\n        if (isString(chunk)) {\r\n            chunkString = chunk;\r\n        } else if (chunk instanceof Buffer) {\r\n            chunkString = chunk.toString();\r\n        } else {\r\n            chunkString = Buffer.alloc(chunk).toString(encoding);\r\n        }\r\n        this.resultString = this.resultString + chunkString;\r\n        callback();\r\n    }\r\n\r\n    /**\r\n     * Returns a string of everything, that was written to the stream so far.\r\n     * @return written data\r\n     */\r\n    public writtenData(): string {\r\n        return this.resultString;\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Very simple class to control the output of a command.\r\n * Output can be errors, warnings, infos and debug-Outputs.\r\n * The output can be controlled via 2 flags, quiet and verbose.\r\n * If quit is enabled only error messages are shown.\r\n * If verbose is enabled, everything is shown.\r\n * If both are not enabled (the default) errors, warnings and infos are shown.\r\n * If not are enabled (strange), we assumed the default.\r\n */\r\n\r\nimport chalk from 'chalk';\r\nimport WritableStream = NodeJS.WritableStream;\r\nimport {format} from 'util';\r\n\r\nenum LogLevel {\r\n    'ERROR',\r\n    'WARN',\r\n    'INFO',\r\n    'DEBUG'\r\n}\r\n\r\nexport class CommandOutput {\r\n\r\n    /**\r\n     * verbose enables output of everything.\r\n     */\r\n    public _verbose: boolean;\r\n\r\n    /**\r\n     * quiet disables output of everything but errors.\r\n     */\r\n    public _quiet: boolean;\r\n\r\n    private outputStream: WritableStream;\r\n\r\n    constructor(stdout?: WritableStream) {\r\n        this._quiet = false;\r\n        this._verbose = false;\r\n        if (stdout) {\r\n            this.outputStream = stdout;\r\n        } else {\r\n            this.outputStream = process.stdout;\r\n        }\r\n    }\r\n\r\n    public setVerbose() {\r\n        this._verbose = true;\r\n    }\r\n\r\n    public setQuiet() {\r\n        this._quiet = true;\r\n    }\r\n\r\n    /**\r\n     * Test, wether verbose is enabled.\r\n     * @return wether verbose is enabled.\r\n     */\r\n    public verbose(): boolean {\r\n        return this._verbose;\r\n    }\r\n\r\n    /**\r\n     * Test, wether quiet is enabled.\r\n     * @return wether quiet is enabled.\r\n     */\r\n    public quiet(): boolean {\r\n        return this._quiet;\r\n    }\r\n\r\n    public error(msg, ...params: any[]) {\r\n        this.log(LogLevel.ERROR, msg, params);\r\n    }\r\n\r\n    public warn(msg, ...params: any[]) {\r\n        this.log(LogLevel.WARN, msg, params);\r\n    }\r\n\r\n    public info(msg, ...params: any[]) {\r\n        this.log(LogLevel.INFO, msg, params);\r\n    }\r\n\r\n    public debug(msg, ...params: any[]) {\r\n        this.log(LogLevel.DEBUG, msg, params);\r\n    }\r\n\r\n    private log(level: LogLevel, msg, params: any[]) {\r\n        if (!this.isOutputEnabled(level)) {\r\n            return;\r\n        }\r\n        let coloredMessage;\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                coloredMessage = chalk.red('ERROR: ' + msg);\r\n                break;\r\n            case LogLevel.WARN:\r\n                coloredMessage = chalk.magenta('WARNING: ' + msg);\r\n                break;\r\n            default:\r\n                coloredMessage = chalk.gray('* ' + msg);\r\n                break;\r\n        }\r\n        const outMsg = format(coloredMessage, ...params);\r\n        this.outputStream.write(outMsg + '\\n');\r\n    }\r\n\r\n    private isOutputEnabled(level: LogLevel): boolean {\r\n        let quietEnabled, verboseEnabled: boolean;\r\n        if (this._quiet && this._verbose) {\r\n            quietEnabled = false;\r\n            verboseEnabled = false;\r\n        } else {\r\n            quietEnabled = this._quiet;\r\n            verboseEnabled = this._verbose;\r\n        }\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                return true;    // always output errors\r\n            case LogLevel.WARN:\r\n                return (!quietEnabled);\r\n            case LogLevel.INFO:\r\n                return (verboseEnabled && !quietEnabled);\r\n            case LogLevel.DEBUG:\r\n                return verboseEnabled;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n */\r\n\r\nexport class XliffMergeError extends Error {\r\n\r\n    constructor(msg: string) {\r\n        super(msg);\r\n\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, XliffMergeError.prototype);\r\n    }\r\n}\r\n","import * as fs from 'fs';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * Some (a few) simple utils for file operations.\r\n * Just for convenience.\r\n */\r\n\r\nexport class FileUtil {\r\n\r\n    /**\r\n     * Check for existence.\r\n     * @param filename filename\r\n     * @return wether file exists\r\n     */\r\n    public static exists(filename: string) {\r\n        return fs.existsSync(filename);\r\n    }\r\n\r\n    /**\r\n     * Read a file.\r\n     * @param filename filename\r\n     * @param encoding encoding\r\n     * @return content of file\r\n     */\r\n    public static read(filename: string, encoding: BufferEncoding) {\r\n        return fs.readFileSync(filename, encoding);\r\n    }\r\n\r\n    /**\r\n     * Write a file with given content.\r\n     * @param filename filename\r\n     * @param newContent newContent\r\n     * @param encoding encoding\r\n     */\r\n    public static replaceContent(filename: string, newContent: string, encoding: BufferEncoding) {\r\n        fs.writeFileSync(filename, newContent, {encoding: encoding});\r\n    }\r\n\r\n    public static copy(srcFile: string, destFile: string) {\r\n        const BUF_LENGTH = 64 * 1024;\r\n        const buff = Buffer.alloc(BUF_LENGTH);\r\n        const fdr = fs.openSync(srcFile, 'r');\r\n        const fdw = fs.openSync(destFile, 'w');\r\n        let bytesRead = 1;\r\n        let pos = 0;\r\n        while (bytesRead > 0) {\r\n            bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);\r\n            fs.writeSync(fdw, buff, 0, bytesRead);\r\n            pos += bytesRead;\r\n        }\r\n        fs.closeSync(fdr);\r\n        fs.closeSync(fdw);\r\n    }\r\n\r\n    /**\r\n     * Delete the folder and all of its content (rm -rf).\r\n     * @param path path\r\n     */\r\n    public static deleteFolderRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n            fs.rmdirSync(path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete folders content recursively, but do not delete folder.\r\n     * Folder is left empty at the end.\r\n     * @param path path\r\n     */\r\n    public static deleteFolderContentRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a file.\r\n     * @param path path\r\n     */\r\n    public static deleteFile(path: string) {\r\n        fs.unlinkSync(path);\r\n    }\r\n}\r\n","/**\r\n * Helper class to parse ngx translate extraction pattern\r\n * and to decide wether a given message matches the pattern.\r\n */\r\nexport class NgxTranslateExtractionPattern {\r\n\r\n    private _matchExplicitId: boolean;\r\n    private _descriptionPatterns: string[];\r\n\r\n    /**\r\n     * Construct the pattern from given description string\r\n     * @param extractionPatternString extractionPatternString\r\n     * @throws an error, if there is a syntax error\r\n     */\r\n    constructor(private extractionPatternString: string) {\r\n        const parts = extractionPatternString.split('|');\r\n        this._matchExplicitId = false;\r\n        this._descriptionPatterns = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            if (part === '@@') {\r\n                if (this._matchExplicitId) {\r\n                    throw new Error('extraction pattern must not contain @@ twice');\r\n                }\r\n                this._matchExplicitId = true;\r\n            } else {\r\n                const errorString = this.checkValidDescriptionPattern(part);\r\n                if (errorString) {\r\n                    throw new Error(errorString);\r\n                }\r\n                this._descriptionPatterns.push(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check, wether an explicitly set id matches the pattern.\r\n     * @param id id\r\n     * @return wether an explicitly set id matches the pattern.\r\n     */\r\n    public isExplicitIdMatched(id: string): boolean {\r\n        return id && this._matchExplicitId;\r\n    }\r\n\r\n    /**\r\n     * Check, wether a given description matches the pattern.\r\n     * @param description description\r\n     * @return wether a given description matches the pattern.\r\n     */\r\n    public isDescriptionMatched(description: string): boolean {\r\n        return this._descriptionPatterns.indexOf(description) >= 0;\r\n    }\r\n\r\n    private checkValidDescriptionPattern(descriptionPattern: string): string {\r\n        if (!descriptionPattern) {\r\n            return 'empty value not allowed';\r\n        }\r\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\r\n            return null; // it is ok\r\n        } else {\r\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\r\n        }\r\n    }\r\n}\r\n","import {ITranslationMessagesFile, ITransUnit, NORMALIZATION_FORMAT_NGXTRANSLATE} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {NgxTranslateExtractionPattern} from './ngx-translate-extraction-pattern';\r\n/**\r\n * Created by roobm on 15.03.2017.\r\n * A tool for extracting messages in ngx-translate format.\r\n * Generates a json-file to be used with ngx-translate.\r\n */\r\n\r\n/**\r\n * The interface used for translations in ngx-translate.\r\n * A hash that contains either the translation or another hash.\r\n */\r\ninterface NgxTranslations {\r\n    [id: string]: NgxTranslations | string;\r\n}\r\n\r\n/**\r\n * internal,\r\n * a message with id (a dot-separated string).\r\n */\r\ninterface NgxMessage {\r\n    id: string; // dot separated name, e.g. \"myapp.service1.message1\"\r\n    message: string; // the message, placeholder are in {{n}} syntax, e.g. \"a test with value: {{0}}\r\n}\r\n\r\nexport class NgxTranslateExtractor {\r\n\r\n    public static DefaultExtractionPattern = '@@|ngx-translate';\r\n    private extractionPattern: NgxTranslateExtractionPattern;\r\n\r\n    /**\r\n     * Check, wether extractionPattern has valid syntax.\r\n     * @param extractionPatternString extractionPatternString\r\n     * @return null, if pattern is ok, string describing the error, if it is not ok.\r\n     */\r\n    public static checkPattern(extractionPatternString: string): string {\r\n        try {\r\n          if (new NgxTranslateExtractionPattern(extractionPatternString)) {\r\n              return null;\r\n          }\r\n        } catch (error) {\r\n            return error.message;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static extract(messagesFile: ITranslationMessagesFile, extractionPattern: string, outputFile: string) {\r\n        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);\r\n    }\r\n\r\n    constructor(private messagesFile: ITranslationMessagesFile, extractionPatternString: string) {\r\n        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);\r\n    }\r\n\r\n    /**\r\n     * Extact messages and write them to a file.\r\n     * @param outputFile outputFile\r\n     */\r\n    public extractTo(outputFile: string) {\r\n        const translations: NgxTranslations = this.toNgxTranslations(this.extract());\r\n        if (translations && Object.keys(translations).length > 0) {\r\n            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'utf-8');\r\n        } else {\r\n            if (FileUtil.exists(outputFile)) {\r\n                FileUtil.deleteFile(outputFile);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Extract messages and convert them to ngx translations.\r\n     *  @return the translation objects.\r\n     */\r\n    private extract(): NgxMessage[] {\r\n        const result: NgxMessage[] = [];\r\n        this.messagesFile.forEachTransUnit((tu: ITransUnit) => {\r\n            const ngxId = this.ngxTranslateIdFromTU(tu);\r\n            if (ngxId) {\r\n                const messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);\r\n                result.push({id: ngxId, message: messagetext});\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.\r\n     * There are 2 possibilities:\r\n     * 1. description is set to \"ngx-translate\" and meaning contains the id.\r\n     * 2. id is explicitly set to a string.\r\n     * @param tu tu\r\n     * @return an ngx id or null, if this tu should not be extracted.\r\n     */\r\n    private ngxTranslateIdFromTU(tu: ITransUnit): string {\r\n        if (this.isExplicitlySetId(tu.id)) {\r\n            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {\r\n                return tu.id;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        const description = tu.description();\r\n        if (description && this.extractionPattern.isDescriptionMatched(description)) {\r\n            return tu.meaning();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether ID was explicitly set (via i18n=\"@myid).\r\n     * Just heuristic, an ID is explicitly, if it does not look like a generated one.\r\n     * @param id id\r\n     * @return wether ID was explicitly set (via i18n=\"@myid).\r\n     */\r\n    private isExplicitlySetId(id: string): boolean {\r\n        if (isNullOrUndefined(id)) {\r\n            return false;\r\n        }\r\n        // generated IDs are either decimal or sha1 hex\r\n        const reForGeneratedId = /^[0-9a-f]{11,}$/;\r\n        return !reForGeneratedId.test(id);\r\n    }\r\n\r\n    /**\r\n     * Convert list of relevant TUs to ngx translations object.\r\n     * @param msgList msgList\r\n     */\r\n    private toNgxTranslations(msgList: NgxMessage[]): NgxTranslations {\r\n        const translationObject: NgxTranslations = {};\r\n        msgList.forEach((msg: NgxMessage) => {\r\n            this.putInTranslationObject(translationObject, msg);\r\n        });\r\n        return translationObject;\r\n    }\r\n\r\n    /**\r\n     * Put a new messages into the translation data object.\r\n     * If you add, e.g. \"{id: 'myapp.example', message: 'test'}\",\r\n     * the translation object will then contain an object myapp that has property example:\r\n     * {myapp: {\r\n     *   example: 'test'\r\n     *   }}\r\n     * @param translationObject translationObject\r\n     * @param msg msg\r\n     */\r\n    private putInTranslationObject(translationObject: NgxTranslations, msg: NgxMessage) {\r\n        let firstPartOfId: string;\r\n        let restOfId: string;\r\n        const indexOfDot = msg.id.indexOf('.');\r\n        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {\r\n            throw new Error('bad nxg-translate id \"' + msg.id + '\"');\r\n        }\r\n        if (indexOfDot < 0) {\r\n            firstPartOfId = msg.id;\r\n            restOfId = '';\r\n        } else {\r\n            firstPartOfId = msg.id.substring(0, indexOfDot);\r\n            restOfId = msg.id.substring(indexOfDot + 1);\r\n        }\r\n        let object = translationObject[firstPartOfId];\r\n        if (isNullOrUndefined(object)) {\r\n            if (restOfId === '') {\r\n                translationObject[firstPartOfId] = msg.message;\r\n                return;\r\n            }\r\n            object = {};\r\n            translationObject[firstPartOfId] = object;\r\n        } else {\r\n            if (restOfId === '') {\r\n                throw new Error('duplicate id praefix \"' + msg.id + '\"');\r\n            }\r\n        }\r\n        this.putInTranslationObject(<NgxTranslations> object, {id: restOfId, message: msg.message});\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Collection of all parameters used by the tool.\r\n * The parameters are read form the profile or defaults are used.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {Stats} from 'fs';\r\nimport {CommandOutput} from '../common/command-output';\r\nimport {format} from 'util';\r\nimport {isArray, isNullOrUndefined} from '../common/util';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {dirname, isAbsolute, join, normalize} from 'path';\r\n\r\nconst PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];\r\n\r\nexport class XliffMergeParameters {\r\n\r\n    private usedProfilePath: string;\r\n    private _quiet: boolean;\r\n    private _verbose: boolean;\r\n    private _allowIdChange: boolean;\r\n    private _defaultLanguage: string;\r\n    private _srcDir: string;\r\n    private _i18nBaseFile: string;\r\n    private _i18nFile: string;\r\n    private _i18nFormat: string;\r\n    private _encoding: BufferEncoding ;\r\n    private _genDir: string;\r\n    private _languages: string[];\r\n    private _removeUnusedIds: boolean;\r\n    private _supportNgxTranslate: boolean;\r\n    private _ngxTranslateExtractionPattern: string;\r\n    private _useSourceAsTarget: boolean;\r\n    private _targetPraefix: string;\r\n    private _targetSuffix: string;\r\n    private _beautifyOutput: boolean;\r\n    private _preserveOrder: boolean;\r\n    private _autotranslate: boolean|string[];\r\n    private _apikey: string;\r\n    private _apikeyfile: string;\r\n\r\n    public errorsFound: XliffMergeError[];\r\n    public warningsFound: string[];\r\n\r\n    /**\r\n     * Create Parameters.\r\n     * @param options command options\r\n     * @param profileContent given profile (if not, it is read from the profile path from options).\r\n     */\r\n    public static createFromOptions(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const parameters = new XliffMergeParameters();\r\n        parameters.configure(options, profileContent);\r\n        return parameters;\r\n    }\r\n\r\n    private constructor() {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n    }\r\n\r\n    /**\r\n     * Read potential profile.\r\n     * To be a candidate, file must exist and contain property \"xliffmergeOptions\".\r\n     * @param profilePath path of profile\r\n     * @return parsed content of file or null, if file does not exist or is not a profile candidate.\r\n     */\r\n    private static readProfileCandidate(profilePath: string): IConfigFile {\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        } catch (err) {\r\n            return null;\r\n        }\r\n        const parsedContent: IConfigFile = JSON.parse(content);\r\n        if (parsedContent && parsedContent.xliffmergeOptions) {\r\n            return parsedContent;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize me from the profile content.\r\n     * (public only for test usage).\r\n     * @param options options given at runtime via command line\r\n     * @param profileContent if null, read it from profile.\r\n     */\r\n    private configure(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n        if (!profileContent) {\r\n            profileContent = this.readProfile(options);\r\n        }\r\n        const validProfile: boolean = (!!profileContent);\r\n        if (options.quiet) {\r\n            this._quiet = options.quiet;\r\n        }\r\n        if (options.verbose) {\r\n            this._verbose = options.verbose;\r\n        }\r\n        if (validProfile) {\r\n            this.initializeFromConfig(profileContent);\r\n            // if languages are given as parameters, they ovveride everything said in profile\r\n            if (!!options.languages && options.languages.length > 0) {\r\n                this._languages = options.languages;\r\n                if (!this._defaultLanguage) {\r\n                    this._defaultLanguage = this._languages[0];\r\n                }\r\n            }\r\n            this.checkParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read profile.\r\n     * @param options program options\r\n     * @return the read profile (empty, if none, null if errors)\r\n     */\r\n    private readProfile(options: ProgramOptions): IConfigFile {\r\n        const profilePath: string = options.profilePath;\r\n        if (!profilePath) {\r\n            for (const configfilename of PROFILE_CANDIDATES) {\r\n                const profile = XliffMergeParameters.readProfileCandidate(configfilename);\r\n                if (profile) {\r\n                    this.usedProfilePath = configfilename;\r\n                    return profile;\r\n                }\r\n            }\r\n            return {};\r\n        }\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('could not read profile \"' + profilePath + '\"'));\r\n            return null;\r\n        }\r\n        this.usedProfilePath = profilePath;\r\n        const profileContent: IConfigFile = JSON.parse(content);\r\n        // replace all pathes in options by absolute paths\r\n        const xliffmergeOptions = profileContent.xliffmergeOptions;\r\n        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);\r\n        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);\r\n        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);\r\n        return profileContent;\r\n    }\r\n\r\n    private adjustPathToProfilePath(profilePath: string, pathToAdjust: string | undefined): string | undefined {\r\n        if (!pathToAdjust || isAbsolute(pathToAdjust)) {\r\n            return pathToAdjust;\r\n        }\r\n        return join(dirname(profilePath), pathToAdjust).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private initializeFromConfig(profileContent: IConfigFile) {\r\n        if (!profileContent) {\r\n            return;\r\n        }\r\n        const profile = profileContent.xliffmergeOptions;\r\n        if (profile) {\r\n            if (!isNullOrUndefined(profile.quiet)) {\r\n                this._quiet = profile.quiet;\r\n            }\r\n            if (!isNullOrUndefined(profile.verbose)) {\r\n                this._verbose = profile.verbose;\r\n            }\r\n            if (!isNullOrUndefined(profile.allowIdChange)) {\r\n                this._allowIdChange = profile.allowIdChange;\r\n            }\r\n            if (profile.defaultLanguage) {\r\n                this._defaultLanguage = profile.defaultLanguage;\r\n            }\r\n            if (profile.languages) {\r\n                this._languages = profile.languages;\r\n            }\r\n            if (profile.srcDir) {\r\n                this._srcDir = profile.srcDir;\r\n            }\r\n            if (profile.angularCompilerOptions) {\r\n                if (profile.angularCompilerOptions.genDir) {\r\n                    this._genDir = profile.angularCompilerOptions.genDir;\r\n                }\r\n            }\r\n            if (profile.genDir) {\r\n                // this must be after angularCompilerOptions to be preferred\r\n                this._genDir = profile.genDir;\r\n            }\r\n            if (profile.i18nBaseFile) {\r\n                this._i18nBaseFile = profile.i18nBaseFile;\r\n            }\r\n            if (profile.i18nFile) {\r\n                this._i18nFile = profile.i18nFile;\r\n            }\r\n            if (profile.i18nFormat) {\r\n                this._i18nFormat = profile.i18nFormat;\r\n            }\r\n            if (profile.encoding) {\r\n                this._encoding = profile.encoding;\r\n            }\r\n            if (!isNullOrUndefined(profile.removeUnusedIds)) {\r\n                this._removeUnusedIds = profile.removeUnusedIds;\r\n            }\r\n            if (!isNullOrUndefined(profile.supportNgxTranslate)) {\r\n                this._supportNgxTranslate = profile.supportNgxTranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {\r\n                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;\r\n            }\r\n            if (!isNullOrUndefined(profile.useSourceAsTarget)) {\r\n                this._useSourceAsTarget = profile.useSourceAsTarget;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetPraefix)) {\r\n                this._targetPraefix = profile.targetPraefix;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetSuffix)) {\r\n                this._targetSuffix = profile.targetSuffix;\r\n            }\r\n            if (!isNullOrUndefined(profile.autotranslate)) {\r\n                this._autotranslate = profile.autotranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.beautifyOutput)) {\r\n                this._beautifyOutput = profile.beautifyOutput;\r\n            }\r\n            if (!isNullOrUndefined(profile.preserveOrder)) {\r\n                this._preserveOrder = profile.preserveOrder;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikey)) {\r\n                this._apikey = profile.apikey;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikeyfile)) {\r\n                this._apikeyfile = profile.apikeyfile;\r\n            }\r\n        } else {\r\n            this.warningsFound.push('did not find \"xliffmergeOptions\" in profile, using defaults');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check all Parameters, wether they are complete and consistent.\r\n     * if something is wrong with the parameters, it is collected in errorsFound.\r\n     */\r\n    private checkParameters(): void {\r\n        this.checkLanguageSyntax(this.defaultLanguage());\r\n        if (this.languages().length === 0) {\r\n            this.errorsFound.push(new XliffMergeError('no languages specified'));\r\n        }\r\n        this.languages().forEach((lang) => {\r\n            this.checkLanguageSyntax(lang);\r\n        });\r\n        let stats: Stats;\r\n        let err: any;\r\n        // srcDir should exists\r\n        try {\r\n            stats = fs.statSync(this.srcDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('srcDir \"' + this.srcDir() + '\" is not a directory'));\r\n        }\r\n        // genDir should exists\r\n        try {\r\n            stats = fs.statSync(this.genDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('genDir \"' + this.genDir() + '\" is not a directory'));\r\n        }\r\n        // master file MUST exist\r\n        try {\r\n            fs.accessSync(this.i18nFile(), fs.constants.R_OK);\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFile \"' + this.i18nFile() + '\" is not readable'));\r\n        }\r\n        // i18nFormat must be xlf xlf2 or xmb\r\n        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFormat \"' + this.i18nFormat() + '\" invalid, must be \"xlf\" or \"xlf2\" or \"xmb\"'));\r\n        }\r\n        // autotranslate requires api key\r\n        if (this.autotranslate() && !this.apikey()) {\r\n            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));\r\n        }\r\n        // autotranslated languages must be in list of all languages\r\n        this.autotranslatedLanguages().forEach((lang) => {\r\n            if (this.languages().indexOf(lang) < 0) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" is not in list of languages'));\r\n            }\r\n            if (lang === this.defaultLanguage()) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('autotranslate language \"' + lang + '\" cannot be translated, because it is the source language'));\r\n            }\r\n        });\r\n        // ngx translate pattern check\r\n        if (this.supportNgxTranslate()) {\r\n            const checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());\r\n            if (!isNullOrUndefined(checkResult)) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('ngxTranslateExtractionPattern \"' + this.ngxTranslateExtractionPattern() + '\": ' + checkResult));\r\n            }\r\n        }\r\n        // targetPraefix and targetSuffix check\r\n        if (!this.useSourceAsTarget()) {\r\n            if (this.targetPraefix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetPraefix \"' + this.targetPraefix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n            if (this.targetSuffix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetSuffix \"' + this.targetSuffix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n        }\r\n     }\r\n\r\n    /**\r\n     * Check syntax of language.\r\n     * Must be compatible with XML Schema type xsd:language.\r\n     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*\r\n     * @param lang language to check\r\n     */\r\n    private checkLanguageSyntax(lang: string) {\r\n        const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;\r\n        if (!pattern.test(lang)) {\r\n            this.errorsFound.push(new XliffMergeError('language \"' + lang + '\" is not valid'));\r\n        }\r\n    }\r\n\r\n    public allowIdChange(): boolean {\r\n        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;\r\n    }\r\n\r\n    public verbose(): boolean {\r\n        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;\r\n    }\r\n\r\n    public quiet(): boolean {\r\n        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;\r\n    }\r\n\r\n    /**\r\n     * Debug output all parameters to commandOutput.\r\n     */\r\n    public showAllParameters(commandOutput: CommandOutput): void {\r\n        commandOutput.debug('xliffmerge Used Parameters:');\r\n        commandOutput.debug('usedProfilePath:\\t\"%s\"', this.usedProfilePath);\r\n        commandOutput.debug('defaultLanguage:\\t\"%s\"', this.defaultLanguage());\r\n        commandOutput.debug('srcDir:\\t\"%s\"', this.srcDir());\r\n        commandOutput.debug('genDir:\\t\"%s\"', this.genDir());\r\n        commandOutput.debug('i18nBaseFile:\\t\"%s\"', this.i18nBaseFile());\r\n        commandOutput.debug('i18nFile:\\t\"%s\"', this.i18nFile());\r\n        commandOutput.debug('languages:\\t%s', this.languages());\r\n        for (const language of this.languages()) {\r\n            commandOutput.debug('outputFile[%s]:\\t%s', language, this.generatedI18nFile(language));\r\n        }\r\n        commandOutput.debug('removeUnusedIds:\\t%s', this.removeUnusedIds());\r\n        commandOutput.debug('supportNgxTranslate:\\t%s', this.supportNgxTranslate());\r\n        if (this.supportNgxTranslate()) {\r\n            commandOutput.debug('ngxTranslateExtractionPattern:\\t%s', this.ngxTranslateExtractionPattern());\r\n        }\r\n        commandOutput.debug('useSourceAsTarget:\\t%s', this.useSourceAsTarget());\r\n        if (this.useSourceAsTarget()) {\r\n            commandOutput.debug('targetPraefix:\\t\"%s\"', this.targetPraefix());\r\n            commandOutput.debug('targetSuffix:\\t\"%s\"', this.targetSuffix());\r\n        }\r\n        commandOutput.debug('allowIdChange:\\t%s', this.allowIdChange());\r\n        commandOutput.debug('beautifyOutput:\\t%s', this.beautifyOutput());\r\n        commandOutput.debug('preserveOrder:\\t%s', this.preserveOrder());\r\n        commandOutput.debug('autotranslate:\\t%s', this.autotranslate());\r\n        if (this.autotranslate()) {\r\n            commandOutput.debug('autotranslated languages:\\t%s', this.autotranslatedLanguages());\r\n            commandOutput.debug('apikey:\\t%s', this.apikey() ? '****' : 'NOT SET');\r\n            commandOutput.debug('apikeyfile:\\t%s', this.apikeyfile());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Default-Language, default en.\r\n     * @return default language\r\n     */\r\n    public defaultLanguage(): string {\r\n        return this._defaultLanguage ? this._defaultLanguage : 'en';\r\n    }\r\n\r\n    /**\r\n     * Liste der zu bearbeitenden Sprachen.\r\n     * @return languages\r\n     */\r\n    public languages(): string[] {\r\n        return this._languages ? this._languages : [];\r\n    }\r\n\r\n    /**\r\n     * src directory, where the master xlif is located.\r\n     * @return srcDir\r\n     */\r\n    public srcDir(): string {\r\n        return this._srcDir ? this._srcDir : '.';\r\n    }\r\n\r\n    /**\r\n     * The base file name of the xlif file for input and output.\r\n     * Default is messages\r\n     * @return base file\r\n     */\r\n    public i18nBaseFile(): string {\r\n        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';\r\n    }\r\n\r\n    /**\r\n     * The master xlif file (the one generated by ng-xi18n).\r\n     * Default is <srcDir>/<i18nBaseFile>.xlf.\r\n     * @return master file\r\n     */\r\n    public i18nFile(): string {\r\n        return join(this.srcDir(),\r\n            (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())\r\n        ).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * Format of the master xlif file.\r\n     * Default is \"xlf\", possible are \"xlf\" or \"xlf2\" or \"xmb\".\r\n     * @return format\r\n     */\r\n    public i18nFormat(): string {\r\n        return (this._i18nFormat ? this._i18nFormat : 'xlf');\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated I18n-File with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private suffixForGeneratedI18nFile(): string {\r\n        switch (this.i18nFormat()) {\r\n            case 'xlf':\r\n                return 'xlf';\r\n            case 'xlf2':\r\n                return 'xlf';\r\n            case 'xmb':\r\n                return 'xtb';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated translate-File for ngx-translate with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * The encoding used to write new XLIFF-files.\r\n     * @return encoding\r\n     */\r\n    public encoding(): BufferEncoding {\r\n        return this._encoding ? this._encoding : 'utf-8';\r\n    }\r\n\r\n     /**\r\n      * Output-Directory, where the output is written to.\r\n      * Default is <srcDir>.\r\n     */\r\n    public genDir(): string {\r\n        return this._genDir ? this._genDir : this.srcDir();\r\n    }\r\n\r\n    public removeUnusedIds(): boolean {\r\n        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;\r\n    }\r\n\r\n    public supportNgxTranslate(): boolean {\r\n        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;\r\n    }\r\n\r\n    public ngxTranslateExtractionPattern(): string {\r\n        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?\r\n            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;\r\n    }\r\n\r\n    /**\r\n     * Whether source must be used as target for new trans-units\r\n     * Default is true\r\n     */\r\n    public useSourceAsTarget(): boolean {\r\n        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;\r\n    }\r\n\r\n    /**\r\n     * Praefix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetPraefix(): string {\r\n        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Suffix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetSuffix(): string {\r\n        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * If set, run xml result through beautifier (pretty-data).\r\n     */\r\n    public beautifyOutput(): boolean {\r\n        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;\r\n    }\r\n\r\n    /**\r\n     * If set, order of new trans units will be as in master.\r\n     * Otherwise they are added at the end.\r\n     */\r\n    public preserveOrder(): boolean {\r\n        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for new trans-units\r\n     * Default is false\r\n     */\r\n    public autotranslate(): boolean {\r\n        if (isNullOrUndefined(this._autotranslate)) {\r\n            return false;\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate).length > 0;\r\n        }\r\n        return <boolean> this._autotranslate;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for a given language.\r\n     * @param lang language code.\r\n     */\r\n    public autotranslateLanguage(lang: string): boolean {\r\n        return this.autotranslatedLanguages().indexOf(lang) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Return a list of languages to be autotranslated.\r\n     */\r\n    public autotranslatedLanguages(): string[] {\r\n        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {\r\n            return [];\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate);\r\n        }\r\n        return this.languages().slice(1); // first is source language\r\n    }\r\n\r\n    /**\r\n     * API key to be used for Google Translate\r\n     * @return api key\r\n     */\r\n    public apikey(): string {\r\n        if (!isNullOrUndefined(this._apikey)) {\r\n            return this._apikey;\r\n        } else {\r\n            const apikeyPath = this.apikeyfile();\r\n            if (this.apikeyfile()) {\r\n                if (fs.existsSync(apikeyPath)) {\r\n                    return FileUtil.read(apikeyPath, 'utf-8');\r\n                } else {\r\n                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * file name for API key to be used for Google Translate.\r\n     * Explicitly set or read from env var API_KEY_FILE.\r\n     * @return file of api key\r\n     */\r\n    public apikeyfile(): string {\r\n        if (this._apikeyfile) {\r\n            return this._apikeyfile;\r\n        } else if (process.env.API_KEY_FILE) {\r\n            return process.env.API_KEY_FILE;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 19.02.2017.\r\n */\r\nimport * as path from 'path';\r\n\r\nlet pkg = null;\r\ntry {\r\n    pkg = require(path.resolve(__dirname, '..', 'package.json'));\r\n} catch (e) {\r\n    try {\r\n        pkg = require(path.resolve(__dirname, '..', '..', 'package.json'));\r\n    } catch (e) {\r\n        pkg = null;\r\n    }\r\n}\r\n\r\nexport const VERSION = (pkg ? pkg.version : 'unknown');\r\n","import {FileUtil} from '../common/file-util';\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * Helper class to read XMl with a correct encoding.\r\n */\r\n\r\nexport class XmlReader {\r\n    static DEFAULT_ENCODING = 'utf-8' as BufferEncoding;\r\n\r\n    /**\r\n     * Read an xml-File.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return file content and encoding found in the file.\r\n     */\r\n    public static readXmlFileContent(path: string, encoding?: BufferEncoding): {content: string, encoding: BufferEncoding } {\r\n        if (!encoding) {\r\n            encoding = XmlReader.DEFAULT_ENCODING as BufferEncoding;\r\n        }\r\n        let content: string = FileUtil.read(path, encoding);\r\n        const foundEncoding = XmlReader.encodingFromXml(content) as BufferEncoding;\r\n        if (foundEncoding !== encoding) {\r\n            // read again with the correct encoding\r\n            content = FileUtil.read(path, foundEncoding);\r\n        }\r\n        return {\r\n            content: content,\r\n            encoding: foundEncoding\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Read the encoding from the xml.\r\n     * xml File starts with .. encoding=\"..\"\r\n     * @param xmlString xmlString\r\n     * @return encoding\r\n     */\r\n    private static encodingFromXml(xmlString: string): string {\r\n        const index = xmlString.indexOf('encoding=\"');\r\n        if (index < 0) {\r\n            return this.DEFAULT_ENCODING; // default in xml if not explicitly set\r\n        }\r\n        const endIndex = xmlString.indexOf('\"', index + 10); // 10 = length of 'encoding=\"'\r\n        return xmlString.substring(index + 10, endIndex);\r\n    }\r\n\r\n}\r\n\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile, TranslationMessagesFileFactory} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {XmlReader} from './xml-reader';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n */\r\nexport class TranslationMessagesFileReader {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat format\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromFile(i18nFormat: string,\r\n                           path: string,\r\n                           encoding: BufferEncoding,\r\n                           optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromUnknownFormatFile(path: string,\r\n                                        encoding: BufferEncoding,\r\n                                        optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read master xmb file\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @param encoding encoding\r\n     * @return content and encoding of file\r\n     */\r\n    private static masterFileContent(optionalMasterFilePath: string, encoding: BufferEncoding)\r\n        : { xmlContent: string, path: string, encoding: BufferEncoding } {\r\n        if (optionalMasterFilePath) {\r\n            const masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);\r\n            return {\r\n                xmlContent: masterXmlContent.content,\r\n                path: optionalMasterFilePath,\r\n                encoding: masterXmlContent.encoding\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save edited file.\r\n     * @param messagesFile messagesFile\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public static save(messagesFile: ITranslationMessagesFile, beautifyOutput?: boolean) {\r\n        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding() as BufferEncoding);\r\n    }\r\n}\r\n\r\n","import {format} from 'util';\r\nimport * as request from 'request';\r\nimport {Observable} from 'rxjs';\r\nimport {of, forkJoin, throwError} from 'rxjs';\r\nimport {map} from 'rxjs/operators';\r\n\r\n/**\r\n * Created by roobm on 03.07.2017.\r\n * Low Level Service to call Google Translate.\r\n */\r\n\r\n/**\r\n * Types form google translate api.\r\n */\r\n\r\ninterface GetSupportedLanguagesRequest {\r\n    target: string; // The language to use to return localized, human readable names of supported\\nlanguages.\r\n}\r\n\r\ninterface LanguagesResource {\r\n    language: string; // code of the language\r\n    name: string; // human readable name (in target language)\r\n}\r\n\r\ninterface LanguagesListResponse {\r\n    languages: LanguagesResource[];\r\n}\r\n\r\ninterface TranslateTextRequest {\r\n    q: string[];  // The input texts to translate\r\n    target: string; // The language to use for translation of the input text\r\n    source: string; // The language of the source text\r\n    format?: string; // \"html\" (default) or \"text\"\r\n    model?: string; // see public documentation\r\n}\r\n\r\ninterface TranslationsResource {\r\n    detectedSourceLanguage?: string;\r\n    model?: string;\r\n    translatedText: string;\r\n}\r\n\r\ninterface TranslationsListResponse {\r\n    translations: TranslationsResource[];\r\n}\r\n\r\ninterface InternalRequestResponse {\r\n    response: request.RequestResponse;\r\n    body: any;\r\n}\r\n\r\nconst MAX_SEGMENTS = 128;\r\n\r\nexport class AutoTranslateService {\r\n\r\n    private _request: request.RequestAPI<request.Request, request.CoreOptions, request.RequiredUriUrl>;\r\n    _rootUrl: string;\r\n    _apiKey: string;\r\n\r\n    /**\r\n     * Strip region code and convert to lower\r\n     * @param lang lang\r\n     * @return lang without region code and in lower case.\r\n     */\r\n    public static stripRegioncode(lang: string): string {\r\n        const langLower = lang.toLowerCase();\r\n        for (let i = 0; i < langLower.length; i++) {\r\n            const c = langLower.charAt(i);\r\n            if (c < 'a' || c > 'z') {\r\n                return langLower.substring(0, i);\r\n            }\r\n        }\r\n        return langLower;\r\n    }\r\n\r\n    constructor(apiKey: string) {\r\n        this._request = request;\r\n        this._apiKey = apiKey;\r\n        this._rootUrl = 'https://translation.googleapis.com/';\r\n    }\r\n\r\n    /**\r\n     * Change API key (just for tests).\r\n     * @param apikey apikey\r\n     */\r\n    public setApiKey(apikey: string) {\r\n        this._apiKey = apikey;\r\n    }\r\n\r\n    /**\r\n     * Translate an array of messages at once.\r\n     * @param messages the messages to be translated\r\n     * @param from source language code\r\n     * @param to target language code\r\n     * @return Observable with translated messages or error\r\n     */\r\n    public translateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        // empty array needs no translation and always works ... (#78)\r\n        if (messages.length === 0) {\r\n            return of([]);\r\n        }\r\n        if (!this._apiKey) {\r\n            return throwError('cannot autotranslate: no api key');\r\n        }\r\n        if (!from || !to) {\r\n            return throwError('cannot autotranslate: source and target language must be set');\r\n        }\r\n        from = AutoTranslateService.stripRegioncode(from);\r\n        to = AutoTranslateService.stripRegioncode(to);\r\n        const allRequests: Observable<string[]>[] = this.splitMessagesToGoogleLimit(messages).map((partialMessages: string[]) => {\r\n            return this.limitedTranslateMultipleStrings(partialMessages, from, to);\r\n        });\r\n        return forkJoin(allRequests).pipe(\r\n            map((allTranslations: string[][]) => {\r\n                let all = [];\r\n                for (let i = 0; i < allTranslations.length; i++) {\r\n                    all = all.concat(allTranslations[i]);\r\n                }\r\n                return all;\r\n        }));\r\n    }\r\n\r\n    private splitMessagesToGoogleLimit(messages: string[]): string[][] {\r\n        if (messages.length <= MAX_SEGMENTS) {\r\n            return [messages];\r\n        }\r\n        const result = [];\r\n        let currentPackage = [];\r\n        let packageSize = 0;\r\n        for (let i = 0; i < messages.length; i++) {\r\n            currentPackage.push(messages[i]);\r\n            packageSize++;\r\n            if (packageSize >= MAX_SEGMENTS) {\r\n                result.push(currentPackage);\r\n                currentPackage = [];\r\n                packageSize = 0;\r\n            }\r\n        }\r\n        if (currentPackage.length > 0) {\r\n            result.push(currentPackage);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return translation request, but messages must be limited to google limits.\r\n     * Not more that 128 single messages.\r\n     * @param messages messages\r\n     * @param from from\r\n     * @param to to\r\n     * @return the translated strings\r\n     */\r\n    private limitedTranslateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        const realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;\r\n        const translateRequest: TranslateTextRequest = {\r\n            q: messages,\r\n            target: to,\r\n            source: from,\r\n        };\r\n        const options = {\r\n            url: realUrl,\r\n            body: translateRequest,\r\n            json: true,\r\n//            proxy: 'http://127.0.0.1:8888' To set a proxy use env var HTTPS_PROXY\r\n        };\r\n        return this.post(realUrl, options).pipe(\r\n            map((data) => {\r\n            const body: any = data.body;\r\n            if (!body) {\r\n                throw new Error('no result received');\r\n            }\r\n            if (body.error) {\r\n                if (body.error.code === 400) {\r\n                    if (body.error.message === 'Invalid Value') {\r\n                        throw new Error(format('Translation from \"%s\" to \"%s\" not supported', from, to));\r\n                    }\r\n                    throw new Error(format('Invalid request: %s', body.error.message));\r\n                } else {\r\n                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));\r\n                }\r\n            }\r\n            const result = body.data;\r\n            return result.translations.map((translation: TranslationsResource) => {\r\n                return translation.translatedText;\r\n            });\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Function to do a POST HTTP request\r\n     *\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     */\r\n    post(uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> this._call.apply(this, [].concat('post', <string> uri,\r\n            <request.CoreOptions> Object.assign({}, options || {})));\r\n    }\r\n\r\n    /**\r\n     * Function to do a HTTP request for given method\r\n     *\r\n     * @param method method\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     *\r\n     */\r\n    private _call(method: string, uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> Observable.create((observer) => {\r\n            // build params array\r\n            const params = [].concat(<string> uri, <request.CoreOptions> Object.assign({}, options || {}),\r\n                <RequestCallback>(error: any, response: request.RequestResponse, body: any) => {\r\n                    if (error) {\r\n                        return observer.error(error);\r\n                    }\r\n\r\n                    observer.next(<InternalRequestResponse> Object.assign({}, {\r\n                        response: <request.RequestResponse> response,\r\n                        body: <any> body\r\n                    }));\r\n                    observer.complete();\r\n                });\r\n\r\n            // _call request method\r\n            try {\r\n                this._request[<string> method].apply(\r\n                    <request.RequestAPI<request.Request,\r\n                    request.CoreOptions,\r\n                    request.RequiredUriUrl>> this._request,\r\n                    params);\r\n            } catch (error) {\r\n                observer.error(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateResult {\r\n\r\n  constructor(private _success: boolean, private _details: string) {\r\n\r\n  }\r\n\r\n  public success(): boolean {\r\n    return this._success;\r\n  }\r\n}\r\n","import {AutoTranslateResult} from './auto-translate-result';\r\nimport {format} from 'util';\r\nimport {ITransUnit} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\n\r\n/**\r\n * A report about a run of Google Translate over all untranslated unit.\r\n * * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateSummaryReport {\r\n\r\n  private _error: string;\r\n  private _from: string;\r\n  private _to: string;\r\n  private _total: number;\r\n  private _ignored: number;\r\n  private _success: number;\r\n  private _failed: number;\r\n\r\n  constructor(from: string, to: string) {\r\n    this._from = from;\r\n    this._to = to;\r\n    this._total = 0;\r\n    this._ignored = 0;\r\n    this._success = 0;\r\n    this._failed = 0;\r\n  }\r\n\r\n  /**\r\n   * Set error if total call failed (e.g. \"invalid api key\" or \"no connection\" ...)\r\n   * @param error error\r\n   * @param total total\r\n   */\r\n  public setError(error: string, total: number) {\r\n    this._error = error;\r\n    this._total = total;\r\n    this._failed = total;\r\n  }\r\n\r\n  public error(): string {\r\n    return this._error;\r\n  }\r\n\r\n  public setIgnored(ignored: number) {\r\n    this._total += ignored;\r\n    this._ignored = ignored;\r\n  }\r\n\r\n  /**\r\n   * Add a single result to the summary.\r\n   * @param tu tu\r\n   * @param result result\r\n   */\r\n  public addSingleResult(tu: ITransUnit, result: AutoTranslateResult) {\r\n    this._total++;\r\n    if (result.success()) {\r\n      this._success++;\r\n    } else {\r\n      this._failed++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge another summary into this one.\r\n   * @param anotherSummary anotherSummary\r\n   */\r\n  public merge(anotherSummary: AutoTranslateSummaryReport) {\r\n    if (!this._error) {\r\n      this._error = anotherSummary._error;\r\n    }\r\n    this._total += anotherSummary.total();\r\n    this._ignored += anotherSummary.ignored();\r\n    this._success += anotherSummary.success();\r\n    this._failed += anotherSummary.failed();\r\n  }\r\n\r\n  public total(): number {\r\n    return this._total;\r\n  }\r\n\r\n  public ignored(): number {\r\n    return this._ignored;\r\n  }\r\n\r\n  public success(): number {\r\n    return this._success;\r\n  }\r\n\r\n  public failed(): number {\r\n    return this._failed;\r\n  }\r\n\r\n  /**\r\n   * Human readable version of report\r\n   */\r\n  public content(): string {\r\n    let result;\r\n    if (this._error) {\r\n      result = format('Auto translation from \"%s\" to \"%s\" failed: \"%s\", failed units: %s', this._from, this._to, this._error, this._failed);\r\n    } else {\r\n      result = format('Auto translation from \"%s\" to \"%s\", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s',\r\n          this._from, this._to, this._total, this._ignored, this._success, this._failed);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import {isNullOrUndefined} from '../common/util';\r\nimport {Observable, forkJoin, of} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport * as entityDecoderLib from 'he';\r\nimport {\r\n    IICUMessage, IICUMessageTranslation, INormalizedMessage, ITranslationMessagesFile, ITransUnit,\r\n    STATE_NEW\r\n} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {AutoTranslateService} from './auto-translate-service';\r\nimport {AutoTranslateResult} from './auto-translate-result';\r\nimport {AutoTranslateSummaryReport} from './auto-translate-summary-report';\r\n/**\r\n * Created by martin on 07.07.2017.\r\n * Service to autotranslate Transunits via Google Translate.\r\n */\r\n\r\nexport class XliffMergeAutoTranslateService {\r\n\r\n    private autoTranslateService: AutoTranslateService;\r\n\r\n    constructor(apikey: string) {\r\n        this.autoTranslateService = new AutoTranslateService(apikey);\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    public autoTranslate(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        return forkJoin([\r\n            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile),\r\n            ...this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)])\r\n            .pipe(\r\n                map((summaries: AutoTranslateSummaryReport[]) => {\r\n                    const summary = summaries[0];\r\n                    for (let i = 1; i < summaries.length; i++) {\r\n                        summary.merge(summaries[i]);\r\n                    }\r\n                    return summary;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Collect all units that are untranslated.\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return all untranslated units\r\n     */\r\n    private allUntranslatedTUs(languageSpecificMessagesFile: ITranslationMessagesFile): ITransUnit[] {\r\n        // collect all units, that should be auto translated\r\n        const allUntranslated: ITransUnit[] = [];\r\n        languageSpecificMessagesFile.forEachTransUnit((tu) => {\r\n            if (tu.targetState() === STATE_NEW) {\r\n                allUntranslated.push(tu);\r\n            }\r\n        });\r\n        return allUntranslated;\r\n    }\r\n\r\n    private doAutoTranslateNonICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatable = allUntranslated.filter((tu) => isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        const allMessages: string[] = allTranslatable.map((tu) => {\r\n            return tu.sourceContentNormalized().asDisplayString();\r\n        });\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                const summary = new AutoTranslateSummaryReport(from, to);\r\n                summary.setIgnored(allUntranslated.length - allTranslatable.length);\r\n                for (let i = 0; i < translations.length; i++) {\r\n                    const tu = allTranslatable[i];\r\n                    const translationText = translations[i];\r\n                    const result = this.autoTranslateNonICUUnit(tu, translationText);\r\n                    summary.addSingleResult(tu, result);\r\n                }\r\n                return summary;\r\n                }),\r\n                catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private doAutoTranslateICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport>[] {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatableICU = allUntranslated.filter((tu) => !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        return allTranslatableICU.map((tu) => {\r\n            return this.doAutoTranslateICUMessage(from, to, tu);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Translate single ICU Messages.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tu transunit to translate (must contain ICU Message)\r\n     * @return summary report\r\n     */\r\n    private doAutoTranslateICUMessage(from: string, to: string, tu: ITransUnit): Observable<AutoTranslateSummaryReport> {\r\n        const icuMessage: IICUMessage = tu.sourceContentNormalized().getICUMessage();\r\n        const categories = icuMessage.getCategories();\r\n        // check for nested ICUs, we do not support that\r\n        if (categories.find((category) => !isNullOrUndefined(category.getMessageNormalized().getICUMessage()))) {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(1);\r\n            return of(summary);\r\n        }\r\n        const allMessages: string[] = categories.map((category) => category.getMessageNormalized().asDisplayString());\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                    const summary = new AutoTranslateSummaryReport(from, to);\r\n                    const icuTranslation: IICUMessageTranslation = {};\r\n                    for (let i = 0; i < translations.length; i++) {\r\n                        icuTranslation[categories[i].getCategory()] = translations[i];\r\n                    }\r\n                    const result = this.autoTranslateICUUnit(tu, icuTranslation);\r\n                    summary.addSingleResult(tu, result);\r\n                    return summary;\r\n                }), catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private autoTranslateNonICUUnit(tu: ITransUnit, translatedMessage: string): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));\r\n    }\r\n\r\n    private autoTranslateICUUnit(tu: ITransUnit, translation: IICUMessageTranslation): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));\r\n    }\r\n\r\n    private autoTranslateUnit(tu: ITransUnit, translatedMessage: INormalizedMessage): AutoTranslateResult {\r\n        const errors = translatedMessage.validate();\r\n        const warnings = translatedMessage.validateWarnings();\r\n        if (!isNullOrUndefined(errors)) {\r\n            return new AutoTranslateResult(false, 'errors detected, not translated');\r\n        } else if (!isNullOrUndefined(warnings)) {\r\n            return new AutoTranslateResult(false, 'warnings detected, not translated');\r\n        } else {\r\n            tu.translate(translatedMessage);\r\n            return new AutoTranslateResult(true, null); // success\r\n        }\r\n    }\r\n}\r\n","import {CommandOutput} from '../common/command-output';\r\nimport {XliffMergeParameters} from './xliff-merge-parameters';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {VERSION} from './version';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {ITranslationMessagesFile, ITransUnit,\r\n    FORMAT_XMB, FORMAT_XTB,\r\n    NORMALIZATION_FORMAT_DEFAULT, STATE_FINAL, STATE_TRANSLATED} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {TranslationMessagesFileReader} from './translation-messages-file-reader';\r\nimport {Observable, of, forkJoin} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport {XliffMergeAutoTranslateService} from '../autotranslate/xliff-merge-auto-translate-service';\r\nimport {AutoTranslateSummaryReport} from '../autotranslate/auto-translate-summary-report';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.\r\n *\r\n */\r\n\r\nexport class XliffMerge {\r\n\r\n    private readonly commandOutput: CommandOutput;\r\n\r\n    private readonly options: ProgramOptions;\r\n\r\n    private parameters: XliffMergeParameters;\r\n\r\n    /**\r\n     * The read master xlf file.\r\n     */\r\n    private master: ITranslationMessagesFile; // XliffFile or Xliff2File or XmbFile\r\n\r\n    private autoTranslateService: XliffMergeAutoTranslateService;\r\n\r\n    static main(argv: string[]) {\r\n        const options = XliffMerge.parseArgs(argv);\r\n        if (options) {\r\n            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {\r\n                process.exit(result);\r\n            });\r\n        }\r\n    }\r\n\r\n    static parseArgs(argv: string[]): ProgramOptions {\r\n        const options: ProgramOptions = {\r\n            languages: []\r\n        };\r\n        for (let i = 1; i < argv.length; i++) {\r\n            const arg = argv[i];\r\n            if (arg === '--version' || arg === '-version') {\r\n                console.log('xliffmerge ' + VERSION);\r\n            } else if (arg === '--verbose' || arg === '-v') {\r\n                options.verbose = true;\r\n            } else if (arg === '--profile' || arg === '-p') {\r\n                i++;\r\n                if (i >= argv.length) {\r\n                    console.log('missing config file');\r\n                    XliffMerge.showUsage();\r\n                    return null;\r\n                } else {\r\n                    options.profilePath = argv[i];\r\n                }\r\n            } else if (arg === '--quiet' || arg === '-q') {\r\n                options.quiet = true;\r\n            } else if (arg === '--help' || arg === '-help' || arg === '-h') {\r\n                XliffMerge.showUsage();\r\n            } else if (arg.length > 0 && arg.charAt(0) === '-') {\r\n                console.log('unknown option');\r\n                return null;\r\n            } else {\r\n                options.languages.push(arg);\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n\r\n    static showUsage() {\r\n        console.log('usage: xliffmerge <option>* <language>*');\r\n        console.log('Options');\r\n        console.log('\\t-p|--profile a json configuration file containing all relevant parameters.');\r\n        console.log('\\t\\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');\r\n        console.log('\\t-v|--verbose show some output for debugging purposes');\r\n        console.log('\\t-q|--quiet only show errors, nothing else');\r\n        console.log('\\t-version|--version show version string');\r\n        console.log('');\r\n        console.log('\\t<language> has to be a valid language short string, e,g. \"en\", \"de\", \"de-ch\"');\r\n    }\r\n\r\n    /**\r\n     * For Tests, create instance with given profile\r\n     * @param commandOutput commandOutput\r\n     * @param options options\r\n     * @param profileContent profileContent\r\n     */\r\n    public static createFromOptions(commandOutput: CommandOutput, options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const instance = new XliffMerge(commandOutput, options);\r\n        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);\r\n        return instance;\r\n    }\r\n\r\n    constructor(commandOutput: CommandOutput, options: ProgramOptions) {\r\n        this.commandOutput = commandOutput;\r\n        this.options = options;\r\n        this.parameters = null;\r\n    }\r\n\r\n    /**\r\n     * Run the command.\r\n     * This runs async.\r\n     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.\r\n     * @param errorFunction callbackFunction for error handling\r\n     */\r\n    public run(callbackFunction?: ((retcode: number) => any), errorFunction?: ((error: any) => any)) {\r\n        this.runAsync()\r\n            .subscribe((retcode: number) => {\r\n                if (!isNullOrUndefined(callbackFunction)) {\r\n                    callbackFunction(retcode);\r\n                }\r\n            }, (error) => {\r\n                if (!isNullOrUndefined(errorFunction)) {\r\n                    errorFunction(error);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Execute merge-Process.\r\n     * @return Async operation, on completion returns retcode 0=ok, other = error.\r\n     */\r\n    public runAsync(): Observable<number> {\r\n        if (this.options && this.options.quiet) {\r\n            this.commandOutput.setQuiet();\r\n        }\r\n        if (this.options && this.options.verbose) {\r\n            this.commandOutput.setVerbose();\r\n        }\r\n        if (!this.parameters) {\r\n            this.parameters = XliffMergeParameters.createFromOptions(this.options);\r\n        }\r\n        this.commandOutput.info('xliffmerge version %s', VERSION);\r\n        if (this.parameters.verbose()) {\r\n            this.parameters.showAllParameters(this.commandOutput);\r\n        }\r\n        if (this.parameters.errorsFound.length > 0) {\r\n            for (const err of this.parameters.errorsFound) {\r\n                this.commandOutput.error(err.message);\r\n            }\r\n            return of(-1);\r\n        }\r\n        if (this.parameters.warningsFound.length > 0) {\r\n            for (const warn of this.parameters.warningsFound) {\r\n                this.commandOutput.warn(warn);\r\n            }\r\n        }\r\n        this.readMaster();\r\n        if (this.parameters.autotranslate()) {\r\n            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());\r\n        }\r\n        const executionForAllLanguages: Observable<number>[] = [];\r\n        this.parameters.languages().forEach((lang: string) => {\r\n            executionForAllLanguages.push(this.processLanguage(lang));\r\n        });\r\n        return forkJoin(executionForAllLanguages).pipe(\r\n            map((retcodes: number[]) => this.totalRetcode(retcodes)));\r\n    }\r\n\r\n    /**\r\n     * Give an array of retcodes for the different languages, return the total retcode.\r\n     * If all are 0, it is 0, otherwise the first non zero.\r\n     * @param retcodes retcodes\r\n     * @return number\r\n     */\r\n    private totalRetcode(retcodes: number[]): number {\r\n        for (let i = 0; i < retcodes.length; i++) {\r\n            if (retcodes[i] !== 0) {\r\n                return retcodes[i];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated file for given lang.\r\n     * @param lang language\r\n     * @return name of generated file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return this.parameters.generatedI18nFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated ngx-translation file for given lang.\r\n     * @param lang language\r\n     * @return name of translate file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return this.parameters.generatedNgxTranslateFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Warnings found during the run.\r\n     * @return warnings\r\n     */\r\n    public warnings(): string[] {\r\n        return this.parameters.warningsFound;\r\n    }\r\n\r\n    private readMaster() {\r\n        try {\r\n            this.master = TranslationMessagesFileReader.fromFile(\r\n                this.parameters.i18nFormat(),\r\n                this.parameters.i18nFile(),\r\n                this.parameters.encoding() as BufferEncoding);\r\n            this.master.warnings().forEach((warning: string) => {\r\n                this.commandOutput.warn(warning);\r\n            });\r\n            const count = this.master.numberOfTransUnits();\r\n            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();\r\n            this.commandOutput.info('master contains %s trans-units', count);\r\n            if (missingIdCount > 0) {\r\n                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);\r\n            }\r\n            const sourceLang: string = this.master.sourceLanguage();\r\n            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {\r\n                this.commandOutput.warn(\r\n                    'master says to have source-language=\"%s\", should be \"%s\" (your defaultLanguage)',\r\n                    sourceLang,\r\n                    this.parameters.defaultLanguage());\r\n                this.master.setSourceLanguage(this.parameters.defaultLanguage());\r\n                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());\r\n                this.commandOutput.warn('changed master source-language=\"%s\" to \"%s\"', sourceLang, this.parameters.defaultLanguage());\r\n            }\r\n        } catch (err) {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            } else {\r\n                // unhandled\r\n                const currentFilename = this.parameters.i18nFile();\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the given language.\r\n     * Async operation.\r\n     * @param lang language\r\n     * @return on completion 0 for ok, other for error\r\n     */\r\n    private processLanguage(lang: string): Observable<number> {\r\n        this.commandOutput.debug('processing language %s', lang);\r\n        const languageXliffFile = this.parameters.generatedI18nFile(lang);\r\n        const currentFilename = languageXliffFile;\r\n        let result: Observable<void>;\r\n        if (!FileUtil.exists(languageXliffFile)) {\r\n            result = this.createUntranslatedXliff(lang, languageXliffFile);\r\n        } else {\r\n            result = this.mergeMasterTo(lang, languageXliffFile);\r\n        }\r\n        return result\r\n            .pipe(map(() => {\r\n                if (this.parameters.supportNgxTranslate()) {\r\n                    const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n                        TranslationMessagesFileReader.fromFile(\r\n                            this.translationFormat(this.parameters.i18nFormat()),\r\n                            languageXliffFile,\r\n                            this.parameters.encoding(),\r\n                            this.master.filename());\r\n                    NgxTranslateExtractor.extract(\r\n                        languageSpecificMessagesFile,\r\n                        this.parameters.ngxTranslateExtractionPattern(),\r\n                        this.parameters.generatedNgxTranslateFile(lang));\r\n                }\r\n                return 0;\r\n            }), catchError((err) => {\r\n                if (err instanceof XliffMergeError) {\r\n                    this.commandOutput.error(err.message);\r\n                    return of(-1);\r\n                } else {\r\n                    // unhandled\r\n                    const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                    this.commandOutput.error(filenameString + 'oops ' + err);\r\n                    throw err;\r\n                }\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * create a new file for the language, which contains no translations, but all keys.\r\n     * in principle, this is just a copy of the master with target-language set.\r\n     * @param lang language\r\n     * @param languageXliffFilePath name of file\r\n     */\r\n    private createUntranslatedXliff(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // copy master ...\r\n        // and set target-language\r\n        // and copy source to target if necessary\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());\r\n        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(\r\n            map((/* summary */) => {\r\n            // write it to file\r\n            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n            this.commandOutput.info('created new file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n            if (!isDefaultLang) {\r\n                this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Map the input format to the format of the translation.\r\n     * Normally they are the same but for xmb the translation format is xtb.\r\n     * @param i18nFormat format\r\n     */\r\n    private translationFormat(i18nFormat: string): string {\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return FORMAT_XTB;\r\n        } else {\r\n            return i18nFormat;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all\r\n     * @param lang language\r\n     * @param languageXliffFilePath filename\r\n     */\r\n    private mergeMasterTo(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // read lang specific file\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            TranslationMessagesFileReader.fromFile(\r\n                this.translationFormat(this.parameters.i18nFormat()),\r\n                languageXliffFilePath,\r\n                this.parameters.encoding());\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        let newCount = 0;\r\n        let correctSourceContentCount = 0;\r\n        let correctSourceRefCount = 0;\r\n        let correctDescriptionOrMeaningCount = 0;\r\n        let idChangedCount = 0;\r\n        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        let lastProcessedUnit: ITransUnit = null;\r\n        this.master.forEachTransUnit((masterTransUnit) => {\r\n            const transUnit: ITransUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);\r\n\r\n            if (!transUnit) {\r\n                // oops, no translation, must be a new key, so add it\r\n                let newUnit;\r\n                if (this.parameters.allowIdChange()\r\n                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {\r\n                    lastProcessedUnit = newUnit;\r\n                    idChangedCount++;\r\n                } else {\r\n                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n                        masterTransUnit,\r\n                        isDefaultLang,\r\n                        this.parameters.useSourceAsTarget(),\r\n                        (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n                    newCount++;\r\n                }\r\n            } else {\r\n                // check for changed source content and change it if needed\r\n                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.\r\n                if (transUnit.supportsSetSourceContent() && !this.areSourcesNearlyEqual(masterTransUnit, transUnit)) {\r\n                    transUnit.setSourceContent(masterTransUnit.sourceContent());\r\n                    if (isDefaultLang) {\r\n                        // #81 changed source must be copied to target for default lang\r\n                        transUnit.translate(masterTransUnit.sourceContent());\r\n                        transUnit.setTargetState(STATE_FINAL);\r\n                    } else {\r\n                        if (transUnit.targetState() === STATE_FINAL) {\r\n                            // source is changed, so translation has to be checked again\r\n                            transUnit.setTargetState(STATE_TRANSLATED);\r\n                        }\r\n                    }\r\n                    correctSourceContentCount++;\r\n                }\r\n                // check for missing or changed source ref and add it if needed\r\n                if (transUnit.supportsSetSourceReferences()\r\n                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {\r\n                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());\r\n                    correctSourceRefCount++;\r\n                }\r\n                // check for changed description or meaning\r\n                if (transUnit.supportsSetDescriptionAndMeaning()) {\r\n                    let changed = false;\r\n                    if (transUnit.description() !== masterTransUnit.description()) {\r\n                        transUnit.setDescription(masterTransUnit.description());\r\n                        changed = true;\r\n                    }\r\n                    if (transUnit.meaning() !== masterTransUnit.meaning()) {\r\n                        transUnit.setMeaning(masterTransUnit.meaning());\r\n                        changed = true;\r\n                    }\r\n                    if (changed) {\r\n                        correctDescriptionOrMeaningCount++;\r\n                    }\r\n                }\r\n                lastProcessedUnit = transUnit;\r\n            }\r\n        });\r\n        if (newCount > 0) {\r\n            this.commandOutput.warn('merged %s trans-units from master to \"%s\"', newCount, lang);\r\n        }\r\n        if (correctSourceContentCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed source content from master to \"%s\"', correctSourceContentCount, lang);\r\n        }\r\n        if (correctSourceRefCount > 0) {\r\n            this.commandOutput.warn('transferred %s source references from master to \"%s\"', correctSourceRefCount, lang);\r\n        }\r\n        if (idChangedCount > 0) {\r\n            this.commandOutput.warn('found %s changed id\\'s in \"%s\"', idChangedCount, lang);\r\n        }\r\n        if (correctDescriptionOrMeaningCount > 0) {\r\n            this.commandOutput.warn(\r\n                'transferred %s changed descriptions/meanings from master to \"%s\"', correctDescriptionOrMeaningCount, lang);\r\n        }\r\n\r\n        // remove all elements that are no longer used\r\n        let removeCount = 0;\r\n        languageSpecificMessagesFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));\r\n            if (!existsInMaster) {\r\n                if (this.parameters.removeUnusedIds()) {\r\n                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);\r\n                }\r\n                removeCount++;\r\n            }\r\n        });\r\n        if (removeCount > 0) {\r\n            if (this.parameters.removeUnusedIds()) {\r\n                this.commandOutput.warn('removed %s unused trans-units in \"%s\"', removeCount, lang);\r\n            } else {\r\n                this.commandOutput.warn('keeping %s unused trans-units in \"%s\", because removeUnused is disabled', removeCount, lang);\r\n            }\r\n        }\r\n\r\n        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0\r\n            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {\r\n            this.commandOutput.info('file for \"%s\" was up to date', lang);\r\n            return of(null);\r\n        } else {\r\n            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)\r\n                .pipe(map(() => {\r\n                    // write it to file\r\n                    TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n                    this.commandOutput.info('updated file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    if (newCount > 0 && !isDefaultLang) {\r\n                        this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    }\r\n                    return null;\r\n                }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the case of changed id due to small white space changes.\r\n     * @param masterTransUnit unit in master file\r\n     * @param languageSpecificMessagesFile translation file\r\n     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.\r\n     * @return processed unit, if done, null if no changed unit found\r\n     */\r\n    private processChangedIdUnit(\r\n        masterTransUnit: ITransUnit,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile,\r\n        lastProcessedUnit: ITransUnit): ITransUnit {\r\n\r\n        let changedTransUnit: ITransUnit = null;\r\n        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {\r\n             if (this.areSourcesNearlyEqual(languageTransUnit, masterTransUnit)) {\r\n                 changedTransUnit = languageTransUnit;\r\n             }\r\n        });\r\n        if (!changedTransUnit) {\r\n            return null;\r\n        }\r\n        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n            masterTransUnit,\r\n            false,\r\n            false,\r\n            (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n        const translatedContent = changedTransUnit.targetContent();\r\n        if (translatedContent) { // issue #68 set translated only, if it is really translated\r\n            mergedTransUnit.translate(translatedContent);\r\n            mergedTransUnit.setTargetState(STATE_TRANSLATED);\r\n        }\r\n        return mergedTransUnit;\r\n    }\r\n\r\n    /**\r\n     * test wether the sources of 2 trans units are equal ignoring white spaces.\r\n     * @param tu1 tu1\r\n     * @param tu2 tu2\r\n     */\r\n    private areSourcesNearlyEqual(tu1: ITransUnit, tu2: ITransUnit): boolean {\r\n        if ((tu1 && !tu2) || (tu2 && !tu1)) {\r\n            return false;\r\n        }\r\n        const tu1Normalized = tu1.sourceContentNormalized();\r\n        const tu2Normalized = tu2.sourceContentNormalized();\r\n        if (tu1Normalized.isICUMessage()) {\r\n            if (tu2Normalized.isICUMessage()) {\r\n                const icu1Normalized = tu1Normalized.getICUMessage().asNativeString().trim();\r\n                const icu2Normalized = tu2Normalized.getICUMessage().asNativeString().trim();\r\n                return icu1Normalized === icu2Normalized;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        if (tu1Normalized.containsICUMessageRef()) {\r\n            const icuref1Normalized = tu1Normalized.asNativeString().trim();\r\n            const icuref2Normalized = tu2Normalized.asNativeString().trim();\r\n            return icuref1Normalized === icuref2Normalized;\r\n        }\r\n        const s1Normalized = tu1Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        const s2Normalized = tu2Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        return s1Normalized === s2Normalized;\r\n    }\r\n\r\n    private areSourceReferencesEqual(\r\n        ref1: {sourcefile: string; linenumber: number; }[],\r\n        ref2: {sourcefile: string; linenumber: number; }[]): boolean {\r\n\r\n        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {\r\n            return false;\r\n        }\r\n        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {\r\n            return true;\r\n        }\r\n        // bot refs are set now, convert to set to compare them\r\n        const set1: Set<string> = new Set<string>();\r\n        ref1.forEach((ref) => {set1.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        const set2: Set<string> = new Set<string>();\r\n        ref2.forEach((ref) => {set2.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        if (set1.size !== set2.size) {\r\n            return false;\r\n        }\r\n        let match = true;\r\n        set2.forEach((ref) => {\r\n            if (!set1.has(ref)) {\r\n                match = false;\r\n            }\r\n        });\r\n        return match;\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    private autoTranslate(\r\n        from: string,\r\n        to: string,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile): Observable<AutoTranslateSummaryReport> {\r\n\r\n        let serviceCall: Observable<AutoTranslateSummaryReport>;\r\n        const autotranslateEnabled: boolean = this.parameters.autotranslateLanguage(to);\r\n        if (autotranslateEnabled) {\r\n            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);\r\n        } else {\r\n            serviceCall = of(new AutoTranslateSummaryReport(from, to));\r\n        }\r\n        return serviceCall.pipe(map((summary) => {\r\n            if (autotranslateEnabled) {\r\n                if (summary.error() || summary.failed() > 0) {\r\n                    this.commandOutput.error(summary.content());\r\n                } else {\r\n                    this.commandOutput.warn(summary.content());\r\n                }\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n\r\n}\r\n","/*\r\n * Public API Surface of xliffmerge\r\n * In principle, there is only the bin file xliffmerge,\r\n * because this is not mentioned as a library.\r\n * But the tooling uses the configuration file type.\r\n */\r\n\r\n// The module is here only because ng-packagr needs it\r\nexport * from './lib/xliffmerge.module';\r\nexport {IXliffMergeOptions, IConfigFile, ProgramOptions} from './xliffmerge/i-xliff-merge-options';\r\nexport {WriterToString} from './common/writer-to-string';\r\nexport {CommandOutput} from './common/command-output';\r\nexport {XliffMerge} from './xliffmerge/xliff-merge';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":"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"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { Writable } from 'stream';\nimport chalk from 'chalk';\nimport { format } from 'util';\nimport * as fs from 'fs';\nimport { NORMALIZATION_FORMAT_NGXTRANSLATE, TranslationMessagesFileFactory, STATE_NEW, FORMAT_XMB, FORMAT_XTB, STATE_FINAL, STATE_TRANSLATED, NORMALIZATION_FORMAT_DEFAULT } from '@ngx-i18nsupport/ngx-i18nsupport-lib';\nimport * as path from 'path';\nimport { isAbsolute, join, dirname } from 'path';\nimport { of, throwError, forkJoin, Observable } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport * as entityDecoderLib from 'he';\nimport * as request from 'request';\n\n// not used, only there to make ng-packagr happy\r\nclass XliffmergeModule {\r\n}\r\n/** @nocollapse */ /** @nocollapse */ XliffmergeModule.ɵfac = function XliffmergeModule_Factory(t) { return new (t || XliffmergeModule)(); };\r\n/** @nocollapse */ /** @nocollapse */ XliffmergeModule.ɵmod = /** @pureOrBreakMyCode */ i0.ɵɵdefineNgModule({ type: XliffmergeModule });\r\n/** @nocollapse */ /** @nocollapse */ XliffmergeModule.ɵinj = /** @pureOrBreakMyCode */ i0.ɵɵdefineInjector({ imports: [[]] });\r\n(function () {\r\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(XliffmergeModule, [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [],\r\n                    declarations: [],\r\n                    exports: []\r\n                }]\r\n        }], null, null);\r\n})();\n\n/**\r\n * Collection of utility functions that are deprecated in nodes util.\r\n */\r\n/**\r\n * Replaces node isNullOrUndefined.\r\n */\r\nfunction isNullOrUndefined(value) {\r\n    return value === undefined || value === null;\r\n}\r\n/**\r\n * Replaces node isString.\r\n */\r\nfunction isString(value) {\r\n    return typeof value === 'string';\r\n}\r\n/**\r\n * Replaces node isBoolean.\r\n */\r\nfunction isBoolean(value) {\r\n    return typeof value === 'boolean';\r\n}\r\n/**\r\n * Replaces node isNumber.\r\n */\r\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\r\n/**\r\n * Replaces node isArray.\r\n */\r\nfunction isArray(value) {\r\n    return Array.isArray(value);\r\n}\n\n/**\r\n * Created by martin on 20.02.2017.\r\n * A helper class for testing.\r\n * Can be used as a WritableStream and writes everything (synchronously) into a string,\r\n * that can easily be read by the tests.\r\n */\r\nclass WriterToString extends Writable {\r\n    constructor() {\r\n        super();\r\n        this.resultString = '';\r\n    }\r\n    _write(chunk, encoding, callback) {\r\n        let chunkString;\r\n        if (isString(chunk)) {\r\n            chunkString = chunk;\r\n        }\r\n        else if (chunk instanceof Buffer) {\r\n            chunkString = chunk.toString();\r\n        }\r\n        else {\r\n            chunkString = Buffer.alloc(chunk).toString(encoding);\r\n        }\r\n        this.resultString = this.resultString + chunkString;\r\n        callback();\r\n    }\r\n    /**\r\n     * Returns a string of everything, that was written to the stream so far.\r\n     * @return written data\r\n     */\r\n    writtenData() {\r\n        return this.resultString;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * Very simple class to control the output of a command.\r\n * Output can be errors, warnings, infos and debug-Outputs.\r\n * The output can be controlled via 2 flags, quiet and verbose.\r\n * If quit is enabled only error messages are shown.\r\n * If verbose is enabled, everything is shown.\r\n * If both are not enabled (the default) errors, warnings and infos are shown.\r\n * If not are enabled (strange), we assumed the default.\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\r\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\r\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\r\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\r\n})(LogLevel || (LogLevel = {}));\r\nclass CommandOutput {\r\n    constructor(stdout) {\r\n        this._quiet = false;\r\n        this._verbose = false;\r\n        if (stdout) {\r\n            this.outputStream = stdout;\r\n        }\r\n        else {\r\n            this.outputStream = process.stdout;\r\n        }\r\n    }\r\n    setVerbose() {\r\n        this._verbose = true;\r\n    }\r\n    setQuiet() {\r\n        this._quiet = true;\r\n    }\r\n    /**\r\n     * Test, wether verbose is enabled.\r\n     * @return wether verbose is enabled.\r\n     */\r\n    verbose() {\r\n        return this._verbose;\r\n    }\r\n    /**\r\n     * Test, wether quiet is enabled.\r\n     * @return wether quiet is enabled.\r\n     */\r\n    quiet() {\r\n        return this._quiet;\r\n    }\r\n    error(msg, ...params) {\r\n        this.log(LogLevel.ERROR, msg, params);\r\n    }\r\n    warn(msg, ...params) {\r\n        this.log(LogLevel.WARN, msg, params);\r\n    }\r\n    info(msg, ...params) {\r\n        this.log(LogLevel.INFO, msg, params);\r\n    }\r\n    debug(msg, ...params) {\r\n        this.log(LogLevel.DEBUG, msg, params);\r\n    }\r\n    log(level, msg, params) {\r\n        if (!this.isOutputEnabled(level)) {\r\n            return;\r\n        }\r\n        let coloredMessage;\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                coloredMessage = chalk.red('ERROR: ' + msg);\r\n                break;\r\n            case LogLevel.WARN:\r\n                coloredMessage = chalk.magenta('WARNING: ' + msg);\r\n                break;\r\n            default:\r\n                coloredMessage = chalk.gray('* ' + msg);\r\n                break;\r\n        }\r\n        const outMsg = format(coloredMessage, ...params);\r\n        this.outputStream.write(outMsg + '\\n');\r\n    }\r\n    isOutputEnabled(level) {\r\n        let quietEnabled, verboseEnabled;\r\n        if (this._quiet && this._verbose) {\r\n            quietEnabled = false;\r\n            verboseEnabled = false;\r\n        }\r\n        else {\r\n            quietEnabled = this._quiet;\r\n            verboseEnabled = this._verbose;\r\n        }\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                return true; // always output errors\r\n            case LogLevel.WARN:\r\n                return (!quietEnabled);\r\n            case LogLevel.INFO:\r\n                return (verboseEnabled && !quietEnabled);\r\n            case LogLevel.DEBUG:\r\n                return verboseEnabled;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n */\r\nclass XliffMergeError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, XliffMergeError.prototype);\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * Some (a few) simple utils for file operations.\r\n * Just for convenience.\r\n */\r\nclass FileUtil {\r\n    /**\r\n     * Check for existence.\r\n     * @param filename filename\r\n     * @return wether file exists\r\n     */\r\n    static exists(filename) {\r\n        return fs.existsSync(filename);\r\n    }\r\n    /**\r\n     * Read a file.\r\n     * @param filename filename\r\n     * @param encoding encoding\r\n     * @return content of file\r\n     */\r\n    static read(filename, encoding) {\r\n        return fs.readFileSync(filename, encoding);\r\n    }\r\n    /**\r\n     * Write a file with given content.\r\n     * @param filename filename\r\n     * @param newContent newContent\r\n     * @param encoding encoding\r\n     */\r\n    static replaceContent(filename, newContent, encoding) {\r\n        fs.writeFileSync(filename, newContent, { encoding: encoding });\r\n    }\r\n    static copy(srcFile, destFile) {\r\n        const BUF_LENGTH = 64 * 1024;\r\n        const buff = Buffer.alloc(BUF_LENGTH);\r\n        const fdr = fs.openSync(srcFile, 'r');\r\n        const fdw = fs.openSync(destFile, 'w');\r\n        let bytesRead = 1;\r\n        let pos = 0;\r\n        while (bytesRead > 0) {\r\n            bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);\r\n            fs.writeSync(fdw, buff, 0, bytesRead);\r\n            pos += bytesRead;\r\n        }\r\n        fs.closeSync(fdr);\r\n        fs.closeSync(fdw);\r\n    }\r\n    /**\r\n     * Delete the folder and all of its content (rm -rf).\r\n     * @param path path\r\n     */\r\n    static deleteFolderRecursive(path) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                }\r\n                else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n            fs.rmdirSync(path);\r\n        }\r\n    }\r\n    /**\r\n     * Delete folders content recursively, but do not delete folder.\r\n     * Folder is left empty at the end.\r\n     * @param path path\r\n     */\r\n    static deleteFolderContentRecursive(path) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                }\r\n                else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Delete a file.\r\n     * @param path path\r\n     */\r\n    static deleteFile(path) {\r\n        fs.unlinkSync(path);\r\n    }\r\n}\n\n/**\r\n * Helper class to parse ngx translate extraction pattern\r\n * and to decide wether a given message matches the pattern.\r\n */\r\nclass NgxTranslateExtractionPattern {\r\n    /**\r\n     * Construct the pattern from given description string\r\n     * @param extractionPatternString extractionPatternString\r\n     * @throws an error, if there is a syntax error\r\n     */\r\n    constructor(extractionPatternString) {\r\n        this.extractionPatternString = extractionPatternString;\r\n        const parts = extractionPatternString.split('|');\r\n        this._matchExplicitId = false;\r\n        this._descriptionPatterns = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            if (part === '@@') {\r\n                if (this._matchExplicitId) {\r\n                    throw new Error('extraction pattern must not contain @@ twice');\r\n                }\r\n                this._matchExplicitId = true;\r\n            }\r\n            else {\r\n                const errorString = this.checkValidDescriptionPattern(part);\r\n                if (errorString) {\r\n                    throw new Error(errorString);\r\n                }\r\n                this._descriptionPatterns.push(part);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check, wether an explicitly set id matches the pattern.\r\n     * @param id id\r\n     * @return wether an explicitly set id matches the pattern.\r\n     */\r\n    isExplicitIdMatched(id) {\r\n        return id && this._matchExplicitId;\r\n    }\r\n    /**\r\n     * Check, wether a given description matches the pattern.\r\n     * @param description description\r\n     * @return wether a given description matches the pattern.\r\n     */\r\n    isDescriptionMatched(description) {\r\n        return this._descriptionPatterns.indexOf(description) >= 0;\r\n    }\r\n    checkValidDescriptionPattern(descriptionPattern) {\r\n        if (!descriptionPattern) {\r\n            return 'empty value not allowed';\r\n        }\r\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\r\n            return null; // it is ok\r\n        }\r\n        else {\r\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\r\n        }\r\n    }\r\n}\n\nclass NgxTranslateExtractor {\r\n    constructor(messagesFile, extractionPatternString) {\r\n        this.messagesFile = messagesFile;\r\n        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);\r\n    }\r\n    /**\r\n     * Check, wether extractionPattern has valid syntax.\r\n     * @param extractionPatternString extractionPatternString\r\n     * @return null, if pattern is ok, string describing the error, if it is not ok.\r\n     */\r\n    static checkPattern(extractionPatternString) {\r\n        try {\r\n            if (new NgxTranslateExtractionPattern(extractionPatternString)) {\r\n                return null;\r\n            }\r\n        }\r\n        catch (error) {\r\n            return error.message;\r\n        }\r\n        return null;\r\n    }\r\n    static extract(messagesFile, extractionPattern, outputFile) {\r\n        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);\r\n    }\r\n    /**\r\n     * Extact messages and write them to a file.\r\n     * @param outputFile outputFile\r\n     */\r\n    extractTo(outputFile) {\r\n        const translations = this.toNgxTranslations(this.extract());\r\n        if (translations && Object.keys(translations).length > 0) {\r\n            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'utf-8');\r\n        }\r\n        else {\r\n            if (FileUtil.exists(outputFile)) {\r\n                FileUtil.deleteFile(outputFile);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     *  Extract messages and convert them to ngx translations.\r\n     *  @return the translation objects.\r\n     */\r\n    extract() {\r\n        const result = [];\r\n        this.messagesFile.forEachTransUnit((tu) => {\r\n            const ngxId = this.ngxTranslateIdFromTU(tu);\r\n            if (ngxId) {\r\n                const messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);\r\n                result.push({ id: ngxId, message: messagetext });\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.\r\n     * There are 2 possibilities:\r\n     * 1. description is set to \"ngx-translate\" and meaning contains the id.\r\n     * 2. id is explicitly set to a string.\r\n     * @param tu tu\r\n     * @return an ngx id or null, if this tu should not be extracted.\r\n     */\r\n    ngxTranslateIdFromTU(tu) {\r\n        if (this.isExplicitlySetId(tu.id)) {\r\n            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {\r\n                return tu.id;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        const description = tu.description();\r\n        if (description && this.extractionPattern.isDescriptionMatched(description)) {\r\n            return tu.meaning();\r\n        }\r\n    }\r\n    /**\r\n     * Test, wether ID was explicitly set (via i18n=\"@myid).\r\n     * Just heuristic, an ID is explicitly, if it does not look like a generated one.\r\n     * @param id id\r\n     * @return wether ID was explicitly set (via i18n=\"@myid).\r\n     */\r\n    isExplicitlySetId(id) {\r\n        if (isNullOrUndefined(id)) {\r\n            return false;\r\n        }\r\n        // generated IDs are either decimal or sha1 hex\r\n        const reForGeneratedId = /^[0-9a-f]{11,}$/;\r\n        return !reForGeneratedId.test(id);\r\n    }\r\n    /**\r\n     * Convert list of relevant TUs to ngx translations object.\r\n     * @param msgList msgList\r\n     */\r\n    toNgxTranslations(msgList) {\r\n        const translationObject = {};\r\n        msgList.forEach((msg) => {\r\n            this.putInTranslationObject(translationObject, msg);\r\n        });\r\n        return translationObject;\r\n    }\r\n    /**\r\n     * Put a new messages into the translation data object.\r\n     * If you add, e.g. \"{id: 'myapp.example', message: 'test'}\",\r\n     * the translation object will then contain an object myapp that has property example:\r\n     * {myapp: {\r\n     *   example: 'test'\r\n     *   }}\r\n     * @param translationObject translationObject\r\n     * @param msg msg\r\n     */\r\n    putInTranslationObject(translationObject, msg) {\r\n        let firstPartOfId;\r\n        let restOfId;\r\n        const indexOfDot = msg.id.indexOf('.');\r\n        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {\r\n            throw new Error('bad nxg-translate id \"' + msg.id + '\"');\r\n        }\r\n        if (indexOfDot < 0) {\r\n            firstPartOfId = msg.id;\r\n            restOfId = '';\r\n        }\r\n        else {\r\n            firstPartOfId = msg.id.substring(0, indexOfDot);\r\n            restOfId = msg.id.substring(indexOfDot + 1);\r\n        }\r\n        let object = translationObject[firstPartOfId];\r\n        if (isNullOrUndefined(object)) {\r\n            if (restOfId === '') {\r\n                translationObject[firstPartOfId] = msg.message;\r\n                return;\r\n            }\r\n            object = {};\r\n            translationObject[firstPartOfId] = object;\r\n        }\r\n        else {\r\n            if (restOfId === '') {\r\n                throw new Error('duplicate id praefix \"' + msg.id + '\"');\r\n            }\r\n        }\r\n        this.putInTranslationObject(object, { id: restOfId, message: msg.message });\r\n    }\r\n}\r\nNgxTranslateExtractor.DefaultExtractionPattern = '@@|ngx-translate';\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * Collection of all parameters used by the tool.\r\n * The parameters are read form the profile or defaults are used.\r\n */\r\nconst PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];\r\nclass XliffMergeParameters {\r\n    constructor() {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n    }\r\n    /**\r\n     * Create Parameters.\r\n     * @param options command options\r\n     * @param profileContent given profile (if not, it is read from the profile path from options).\r\n     */\r\n    static createFromOptions(options, profileContent) {\r\n        const parameters = new XliffMergeParameters();\r\n        parameters.configure(options, profileContent);\r\n        return parameters;\r\n    }\r\n    /**\r\n     * Read potential profile.\r\n     * To be a candidate, file must exist and contain property \"xliffmergeOptions\".\r\n     * @param profilePath path of profile\r\n     * @return parsed content of file or null, if file does not exist or is not a profile candidate.\r\n     */\r\n    static readProfileCandidate(profilePath) {\r\n        let content;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        const parsedContent = JSON.parse(content);\r\n        if (parsedContent && parsedContent.xliffmergeOptions) {\r\n            return parsedContent;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Initialize me from the profile content.\r\n     * (public only for test usage).\r\n     * @param options options given at runtime via command line\r\n     * @param profileContent if null, read it from profile.\r\n     */\r\n    configure(options, profileContent) {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n        if (!profileContent) {\r\n            profileContent = this.readProfile(options);\r\n        }\r\n        const validProfile = (!!profileContent);\r\n        if (options.quiet) {\r\n            this._quiet = options.quiet;\r\n        }\r\n        if (options.verbose) {\r\n            this._verbose = options.verbose;\r\n        }\r\n        if (validProfile) {\r\n            this.initializeFromConfig(profileContent);\r\n            // if languages are given as parameters, they ovveride everything said in profile\r\n            if (!!options.languages && options.languages.length > 0) {\r\n                this._languages = options.languages;\r\n                if (!this._defaultLanguage) {\r\n                    this._defaultLanguage = this._languages[0];\r\n                }\r\n            }\r\n            this.checkParameters();\r\n        }\r\n    }\r\n    /**\r\n     * Read profile.\r\n     * @param options program options\r\n     * @return the read profile (empty, if none, null if errors)\r\n     */\r\n    readProfile(options) {\r\n        const profilePath = options.profilePath;\r\n        if (!profilePath) {\r\n            for (const configfilename of PROFILE_CANDIDATES) {\r\n                const profile = XliffMergeParameters.readProfileCandidate(configfilename);\r\n                if (profile) {\r\n                    this.usedProfilePath = configfilename;\r\n                    return profile;\r\n                }\r\n            }\r\n            return {};\r\n        }\r\n        let content;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        }\r\n        catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('could not read profile \"' + profilePath + '\"'));\r\n            return null;\r\n        }\r\n        this.usedProfilePath = profilePath;\r\n        const profileContent = JSON.parse(content);\r\n        // replace all pathes in options by absolute paths\r\n        const xliffmergeOptions = profileContent.xliffmergeOptions;\r\n        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);\r\n        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);\r\n        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);\r\n        return profileContent;\r\n    }\r\n    adjustPathToProfilePath(profilePath, pathToAdjust) {\r\n        if (!pathToAdjust || isAbsolute(pathToAdjust)) {\r\n            return pathToAdjust;\r\n        }\r\n        return join(dirname(profilePath), pathToAdjust).replace(/\\\\/g, '/');\r\n    }\r\n    initializeFromConfig(profileContent) {\r\n        if (!profileContent) {\r\n            return;\r\n        }\r\n        const profile = profileContent.xliffmergeOptions;\r\n        if (profile) {\r\n            if (!isNullOrUndefined(profile.quiet)) {\r\n                this._quiet = profile.quiet;\r\n            }\r\n            if (!isNullOrUndefined(profile.verbose)) {\r\n                this._verbose = profile.verbose;\r\n            }\r\n            if (!isNullOrUndefined(profile.allowIdChange)) {\r\n                this._allowIdChange = profile.allowIdChange;\r\n            }\r\n            if (profile.defaultLanguage) {\r\n                this._defaultLanguage = profile.defaultLanguage;\r\n            }\r\n            if (profile.languages) {\r\n                this._languages = profile.languages;\r\n            }\r\n            if (profile.srcDir) {\r\n                this._srcDir = profile.srcDir;\r\n            }\r\n            if (profile.angularCompilerOptions) {\r\n                if (profile.angularCompilerOptions.genDir) {\r\n                    this._genDir = profile.angularCompilerOptions.genDir;\r\n                }\r\n            }\r\n            if (profile.genDir) {\r\n                // this must be after angularCompilerOptions to be preferred\r\n                this._genDir = profile.genDir;\r\n            }\r\n            if (profile.i18nBaseFile) {\r\n                this._i18nBaseFile = profile.i18nBaseFile;\r\n            }\r\n            if (profile.i18nFile) {\r\n                this._i18nFile = profile.i18nFile;\r\n            }\r\n            if (profile.i18nFormat) {\r\n                this._i18nFormat = profile.i18nFormat;\r\n            }\r\n            if (profile.encoding) {\r\n                this._encoding = profile.encoding;\r\n            }\r\n            if (!isNullOrUndefined(profile.removeUnusedIds)) {\r\n                this._removeUnusedIds = profile.removeUnusedIds;\r\n            }\r\n            if (!isNullOrUndefined(profile.supportNgxTranslate)) {\r\n                this._supportNgxTranslate = profile.supportNgxTranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {\r\n                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;\r\n            }\r\n            if (!isNullOrUndefined(profile.useSourceAsTarget)) {\r\n                this._useSourceAsTarget = profile.useSourceAsTarget;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetPraefix)) {\r\n                this._targetPraefix = profile.targetPraefix;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetSuffix)) {\r\n                this._targetSuffix = profile.targetSuffix;\r\n            }\r\n            if (!isNullOrUndefined(profile.autotranslate)) {\r\n                this._autotranslate = profile.autotranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.beautifyOutput)) {\r\n                this._beautifyOutput = profile.beautifyOutput;\r\n            }\r\n            if (!isNullOrUndefined(profile.preserveOrder)) {\r\n                this._preserveOrder = profile.preserveOrder;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikey)) {\r\n                this._apikey = profile.apikey;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikeyfile)) {\r\n                this._apikeyfile = profile.apikeyfile;\r\n            }\r\n        }\r\n        else {\r\n            this.warningsFound.push('did not find \"xliffmergeOptions\" in profile, using defaults');\r\n        }\r\n    }\r\n    /**\r\n     * Check all Parameters, wether they are complete and consistent.\r\n     * if something is wrong with the parameters, it is collected in errorsFound.\r\n     */\r\n    checkParameters() {\r\n        this.checkLanguageSyntax(this.defaultLanguage());\r\n        if (this.languages().length === 0) {\r\n            this.errorsFound.push(new XliffMergeError('no languages specified'));\r\n        }\r\n        this.languages().forEach((lang) => {\r\n            this.checkLanguageSyntax(lang);\r\n        });\r\n        let stats;\r\n        let err;\r\n        // srcDir should exists\r\n        try {\r\n            stats = fs.statSync(this.srcDir());\r\n        }\r\n        catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('srcDir \"' + this.srcDir() + '\" is not a directory'));\r\n        }\r\n        // genDir should exists\r\n        try {\r\n            stats = fs.statSync(this.genDir());\r\n        }\r\n        catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('genDir \"' + this.genDir() + '\" is not a directory'));\r\n        }\r\n        // master file MUST exist\r\n        try {\r\n            fs.accessSync(this.i18nFile(), fs.constants.R_OK);\r\n        }\r\n        catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFile \"' + this.i18nFile() + '\" is not readable'));\r\n        }\r\n        // i18nFormat must be xlf xlf2 or xmb\r\n        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFormat \"' + this.i18nFormat() + '\" invalid, must be \"xlf\" or \"xlf2\" or \"xmb\"'));\r\n        }\r\n        // autotranslate requires api key\r\n        if (this.autotranslate() && !this.apikey()) {\r\n            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));\r\n        }\r\n        // autotranslated languages must be in list of all languages\r\n        this.autotranslatedLanguages().forEach((lang) => {\r\n            if (this.languages().indexOf(lang) < 0) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" is not in list of languages'));\r\n            }\r\n            if (lang === this.defaultLanguage()) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" cannot be translated, because it is the source language'));\r\n            }\r\n        });\r\n        // ngx translate pattern check\r\n        if (this.supportNgxTranslate()) {\r\n            const checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());\r\n            if (!isNullOrUndefined(checkResult)) {\r\n                this.errorsFound.push(new XliffMergeError('ngxTranslateExtractionPattern \"' + this.ngxTranslateExtractionPattern() + '\": ' + checkResult));\r\n            }\r\n        }\r\n        // targetPraefix and targetSuffix check\r\n        if (!this.useSourceAsTarget()) {\r\n            if (this.targetPraefix().length > 0) {\r\n                this.warningsFound.push('configured targetPraefix \"' + this.targetPraefix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n            if (this.targetSuffix().length > 0) {\r\n                this.warningsFound.push('configured targetSuffix \"' + this.targetSuffix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check syntax of language.\r\n     * Must be compatible with XML Schema type xsd:language.\r\n     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*\r\n     * @param lang language to check\r\n     */\r\n    checkLanguageSyntax(lang) {\r\n        const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;\r\n        if (!pattern.test(lang)) {\r\n            this.errorsFound.push(new XliffMergeError('language \"' + lang + '\" is not valid'));\r\n        }\r\n    }\r\n    allowIdChange() {\r\n        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;\r\n    }\r\n    verbose() {\r\n        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;\r\n    }\r\n    quiet() {\r\n        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;\r\n    }\r\n    /**\r\n     * Debug output all parameters to commandOutput.\r\n     */\r\n    showAllParameters(commandOutput) {\r\n        commandOutput.debug('xliffmerge Used Parameters:');\r\n        commandOutput.debug('usedProfilePath:\\t\"%s\"', this.usedProfilePath);\r\n        commandOutput.debug('defaultLanguage:\\t\"%s\"', this.defaultLanguage());\r\n        commandOutput.debug('srcDir:\\t\"%s\"', this.srcDir());\r\n        commandOutput.debug('genDir:\\t\"%s\"', this.genDir());\r\n        commandOutput.debug('i18nBaseFile:\\t\"%s\"', this.i18nBaseFile());\r\n        commandOutput.debug('i18nFile:\\t\"%s\"', this.i18nFile());\r\n        commandOutput.debug('languages:\\t%s', this.languages());\r\n        for (const language of this.languages()) {\r\n            commandOutput.debug('outputFile[%s]:\\t%s', language, this.generatedI18nFile(language));\r\n        }\r\n        commandOutput.debug('removeUnusedIds:\\t%s', this.removeUnusedIds());\r\n        commandOutput.debug('supportNgxTranslate:\\t%s', this.supportNgxTranslate());\r\n        if (this.supportNgxTranslate()) {\r\n            commandOutput.debug('ngxTranslateExtractionPattern:\\t%s', this.ngxTranslateExtractionPattern());\r\n        }\r\n        commandOutput.debug('useSourceAsTarget:\\t%s', this.useSourceAsTarget());\r\n        if (this.useSourceAsTarget()) {\r\n            commandOutput.debug('targetPraefix:\\t\"%s\"', this.targetPraefix());\r\n            commandOutput.debug('targetSuffix:\\t\"%s\"', this.targetSuffix());\r\n        }\r\n        commandOutput.debug('allowIdChange:\\t%s', this.allowIdChange());\r\n        commandOutput.debug('beautifyOutput:\\t%s', this.beautifyOutput());\r\n        commandOutput.debug('preserveOrder:\\t%s', this.preserveOrder());\r\n        commandOutput.debug('autotranslate:\\t%s', this.autotranslate());\r\n        if (this.autotranslate()) {\r\n            commandOutput.debug('autotranslated languages:\\t%s', this.autotranslatedLanguages());\r\n            commandOutput.debug('apikey:\\t%s', this.apikey() ? '****' : 'NOT SET');\r\n            commandOutput.debug('apikeyfile:\\t%s', this.apikeyfile());\r\n        }\r\n    }\r\n    /**\r\n     * Default-Language, default en.\r\n     * @return default language\r\n     */\r\n    defaultLanguage() {\r\n        return this._defaultLanguage ? this._defaultLanguage : 'en';\r\n    }\r\n    /**\r\n     * Liste der zu bearbeitenden Sprachen.\r\n     * @return languages\r\n     */\r\n    languages() {\r\n        return this._languages ? this._languages : [];\r\n    }\r\n    /**\r\n     * src directory, where the master xlif is located.\r\n     * @return srcDir\r\n     */\r\n    srcDir() {\r\n        return this._srcDir ? this._srcDir : '.';\r\n    }\r\n    /**\r\n     * The base file name of the xlif file for input and output.\r\n     * Default is messages\r\n     * @return base file\r\n     */\r\n    i18nBaseFile() {\r\n        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';\r\n    }\r\n    /**\r\n     * The master xlif file (the one generated by ng-xi18n).\r\n     * Default is <srcDir>/<i18nBaseFile>.xlf.\r\n     * @return master file\r\n     */\r\n    i18nFile() {\r\n        return join(this.srcDir(), (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())).replace(/\\\\/g, '/');\r\n    }\r\n    /**\r\n     * Format of the master xlif file.\r\n     * Default is \"xlf\", possible are \"xlf\" or \"xlf2\" or \"xmb\".\r\n     * @return format\r\n     */\r\n    i18nFormat() {\r\n        return (this._i18nFormat ? this._i18nFormat : 'xlf');\r\n    }\r\n    /**\r\n     * potentially to be generated I18n-File with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    generatedI18nFile(lang) {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\\\/g, '/');\r\n    }\r\n    suffixForGeneratedI18nFile() {\r\n        switch (this.i18nFormat()) {\r\n            case 'xlf':\r\n                return 'xlf';\r\n            case 'xlf2':\r\n                return 'xlf';\r\n            case 'xmb':\r\n                return 'xtb';\r\n        }\r\n    }\r\n    /**\r\n     * potentially to be generated translate-File for ngx-translate with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    generatedNgxTranslateFile(lang) {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\\\/g, '/');\r\n    }\r\n    /**\r\n     * The encoding used to write new XLIFF-files.\r\n     * @return encoding\r\n     */\r\n    encoding() {\r\n        return this._encoding ? this._encoding : 'utf-8';\r\n    }\r\n    /**\r\n     * Output-Directory, where the output is written to.\r\n     * Default is <srcDir>.\r\n    */\r\n    genDir() {\r\n        return this._genDir ? this._genDir : this.srcDir();\r\n    }\r\n    removeUnusedIds() {\r\n        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;\r\n    }\r\n    supportNgxTranslate() {\r\n        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;\r\n    }\r\n    ngxTranslateExtractionPattern() {\r\n        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?\r\n            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;\r\n    }\r\n    /**\r\n     * Whether source must be used as target for new trans-units\r\n     * Default is true\r\n     */\r\n    useSourceAsTarget() {\r\n        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;\r\n    }\r\n    /**\r\n     * Praefix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    targetPraefix() {\r\n        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;\r\n    }\r\n    /**\r\n     * Suffix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    targetSuffix() {\r\n        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;\r\n    }\r\n    /**\r\n     * If set, run xml result through beautifier (pretty-data).\r\n     */\r\n    beautifyOutput() {\r\n        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;\r\n    }\r\n    /**\r\n     * If set, order of new trans units will be as in master.\r\n     * Otherwise they are added at the end.\r\n     */\r\n    preserveOrder() {\r\n        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;\r\n    }\r\n    /**\r\n     * Whether to use autotranslate for new trans-units\r\n     * Default is false\r\n     */\r\n    autotranslate() {\r\n        if (isNullOrUndefined(this._autotranslate)) {\r\n            return false;\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return this._autotranslate.length > 0;\r\n        }\r\n        return this._autotranslate;\r\n    }\r\n    /**\r\n     * Whether to use autotranslate for a given language.\r\n     * @param lang language code.\r\n     */\r\n    autotranslateLanguage(lang) {\r\n        return this.autotranslatedLanguages().indexOf(lang) >= 0;\r\n    }\r\n    /**\r\n     * Return a list of languages to be autotranslated.\r\n     */\r\n    autotranslatedLanguages() {\r\n        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {\r\n            return [];\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return this._autotranslate;\r\n        }\r\n        return this.languages().slice(1); // first is source language\r\n    }\r\n    /**\r\n     * API key to be used for Google Translate\r\n     * @return api key\r\n     */\r\n    apikey() {\r\n        if (!isNullOrUndefined(this._apikey)) {\r\n            return this._apikey;\r\n        }\r\n        else {\r\n            const apikeyPath = this.apikeyfile();\r\n            if (this.apikeyfile()) {\r\n                if (fs.existsSync(apikeyPath)) {\r\n                    return FileUtil.read(apikeyPath, 'utf-8');\r\n                }\r\n                else {\r\n                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * file name for API key to be used for Google Translate.\r\n     * Explicitly set or read from env var API_KEY_FILE.\r\n     * @return file of api key\r\n     */\r\n    apikeyfile() {\r\n        if (this._apikeyfile) {\r\n            return this._apikeyfile;\r\n        }\r\n        else if (process.env.API_KEY_FILE) {\r\n            return process.env.API_KEY_FILE;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 19.02.2017.\r\n */\r\nlet pkg = null;\r\ntry {\r\n    pkg = require(path.resolve(__dirname, '..', 'package.json'));\r\n}\r\ncatch (e) {\r\n    try {\r\n        pkg = require(path.resolve(__dirname, '..', '..', 'package.json'));\r\n    }\r\n    catch (e) {\r\n        pkg = null;\r\n    }\r\n}\r\nconst VERSION = (pkg ? pkg.version : 'unknown');\n\n/**\r\n * Created by martin on 10.03.2017.\r\n * Helper class to read XMl with a correct encoding.\r\n */\r\nclass XmlReader {\r\n    /**\r\n     * Read an xml-File.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return file content and encoding found in the file.\r\n     */\r\n    static readXmlFileContent(path, encoding) {\r\n        if (!encoding) {\r\n            encoding = XmlReader.DEFAULT_ENCODING;\r\n        }\r\n        let content = FileUtil.read(path, encoding);\r\n        const foundEncoding = XmlReader.encodingFromXml(content);\r\n        if (foundEncoding !== encoding) {\r\n            // read again with the correct encoding\r\n            content = FileUtil.read(path, foundEncoding);\r\n        }\r\n        return {\r\n            content: content,\r\n            encoding: foundEncoding\r\n        };\r\n    }\r\n    /**\r\n     * Read the encoding from the xml.\r\n     * xml File starts with .. encoding=\"..\"\r\n     * @param xmlString xmlString\r\n     * @return encoding\r\n     */\r\n    static encodingFromXml(xmlString) {\r\n        const index = xmlString.indexOf('encoding=\"');\r\n        if (index < 0) {\r\n            return this.DEFAULT_ENCODING; // default in xml if not explicitly set\r\n        }\r\n        const endIndex = xmlString.indexOf('\"', index + 10); // 10 = length of 'encoding=\"'\r\n        return xmlString.substring(index + 10, endIndex);\r\n    }\r\n}\r\nXmlReader.DEFAULT_ENCODING = 'utf-8';\n\n/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\n/**\r\n * Helper class to read translation files depending on format.\r\n */\r\nclass TranslationMessagesFileReader {\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat format\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    static fromFile(i18nFormat, path, encoding, optionalMasterFilePath) {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    static fromUnknownFormatFile(path, encoding, optionalMasterFilePath) {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n    /**\r\n     * Read master xmb file\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @param encoding encoding\r\n     * @return content and encoding of file\r\n     */\r\n    static masterFileContent(optionalMasterFilePath, encoding) {\r\n        if (optionalMasterFilePath) {\r\n            const masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);\r\n            return {\r\n                xmlContent: masterXmlContent.content,\r\n                path: optionalMasterFilePath,\r\n                encoding: masterXmlContent.encoding\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Save edited file.\r\n     * @param messagesFile messagesFile\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    static save(messagesFile, beautifyOutput) {\r\n        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding());\r\n    }\r\n}\n\nconst MAX_SEGMENTS = 128;\r\nclass AutoTranslateService {\r\n    constructor(apiKey) {\r\n        this._request = request;\r\n        this._apiKey = apiKey;\r\n        this._rootUrl = 'https://translation.googleapis.com/';\r\n    }\r\n    /**\r\n     * Strip region code and convert to lower\r\n     * @param lang lang\r\n     * @return lang without region code and in lower case.\r\n     */\r\n    static stripRegioncode(lang) {\r\n        const langLower = lang.toLowerCase();\r\n        for (let i = 0; i < langLower.length; i++) {\r\n            const c = langLower.charAt(i);\r\n            if (c < 'a' || c > 'z') {\r\n                return langLower.substring(0, i);\r\n            }\r\n        }\r\n        return langLower;\r\n    }\r\n    /**\r\n     * Change API key (just for tests).\r\n     * @param apikey apikey\r\n     */\r\n    setApiKey(apikey) {\r\n        this._apiKey = apikey;\r\n    }\r\n    /**\r\n     * Translate an array of messages at once.\r\n     * @param messages the messages to be translated\r\n     * @param from source language code\r\n     * @param to target language code\r\n     * @return Observable with translated messages or error\r\n     */\r\n    translateMultipleStrings(messages, from, to) {\r\n        // empty array needs no translation and always works ... (#78)\r\n        if (messages.length === 0) {\r\n            return of([]);\r\n        }\r\n        if (!this._apiKey) {\r\n            return throwError('cannot autotranslate: no api key');\r\n        }\r\n        if (!from || !to) {\r\n            return throwError('cannot autotranslate: source and target language must be set');\r\n        }\r\n        from = AutoTranslateService.stripRegioncode(from);\r\n        to = AutoTranslateService.stripRegioncode(to);\r\n        const allRequests = this.splitMessagesToGoogleLimit(messages).map((partialMessages) => {\r\n            return this.limitedTranslateMultipleStrings(partialMessages, from, to);\r\n        });\r\n        return forkJoin(allRequests).pipe(map((allTranslations) => {\r\n            let all = [];\r\n            for (let i = 0; i < allTranslations.length; i++) {\r\n                all = all.concat(allTranslations[i]);\r\n            }\r\n            return all;\r\n        }));\r\n    }\r\n    splitMessagesToGoogleLimit(messages) {\r\n        if (messages.length <= MAX_SEGMENTS) {\r\n            return [messages];\r\n        }\r\n        const result = [];\r\n        let currentPackage = [];\r\n        let packageSize = 0;\r\n        for (let i = 0; i < messages.length; i++) {\r\n            currentPackage.push(messages[i]);\r\n            packageSize++;\r\n            if (packageSize >= MAX_SEGMENTS) {\r\n                result.push(currentPackage);\r\n                currentPackage = [];\r\n                packageSize = 0;\r\n            }\r\n        }\r\n        if (currentPackage.length > 0) {\r\n            result.push(currentPackage);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Return translation request, but messages must be limited to google limits.\r\n     * Not more that 128 single messages.\r\n     * @param messages messages\r\n     * @param from from\r\n     * @param to to\r\n     * @return the translated strings\r\n     */\r\n    limitedTranslateMultipleStrings(messages, from, to) {\r\n        const realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;\r\n        const translateRequest = {\r\n            q: messages,\r\n            target: to,\r\n            source: from,\r\n        };\r\n        const options = {\r\n            url: realUrl,\r\n            body: translateRequest,\r\n            json: true,\r\n            //            proxy: 'http://127.0.0.1:8888' To set a proxy use env var HTTPS_PROXY\r\n        };\r\n        return this.post(realUrl, options).pipe(map((data) => {\r\n            const body = data.body;\r\n            if (!body) {\r\n                throw new Error('no result received');\r\n            }\r\n            if (body.error) {\r\n                if (body.error.code === 400) {\r\n                    if (body.error.message === 'Invalid Value') {\r\n                        throw new Error(format('Translation from \"%s\" to \"%s\" not supported', from, to));\r\n                    }\r\n                    throw new Error(format('Invalid request: %s', body.error.message));\r\n                }\r\n                else {\r\n                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));\r\n                }\r\n            }\r\n            const result = body.data;\r\n            return result.translations.map((translation) => {\r\n                return translation.translatedText;\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * Function to do a POST HTTP request\r\n     *\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     */\r\n    post(uri, options) {\r\n        return this._call.apply(this, [].concat('post', uri, Object.assign({}, options || {})));\r\n    }\r\n    /**\r\n     * Function to do a HTTP request for given method\r\n     *\r\n     * @param method method\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     *\r\n     */\r\n    _call(method, uri, options) {\r\n        return Observable.create((observer) => {\r\n            // build params array\r\n            const params = [].concat(uri, Object.assign({}, options || {}), (error, response, body) => {\r\n                if (error) {\r\n                    return observer.error(error);\r\n                }\r\n                observer.next(Object.assign({}, {\r\n                    response: response,\r\n                    body: body\r\n                }));\r\n                observer.complete();\r\n            });\r\n            // _call request method\r\n            try {\r\n                this._request[method].apply(this._request, params);\r\n            }\r\n            catch (error) {\r\n                observer.error(error);\r\n            }\r\n        });\r\n    }\r\n}\n\n/**\r\n * Created by martin on 29.06.2017.\r\n */\r\nclass AutoTranslateResult {\r\n    constructor(_success, _details) {\r\n        this._success = _success;\r\n        this._details = _details;\r\n    }\r\n    success() {\r\n        return this._success;\r\n    }\r\n}\n\n/**\r\n * A report about a run of Google Translate over all untranslated unit.\r\n * * Created by martin on 29.06.2017.\r\n */\r\nclass AutoTranslateSummaryReport {\r\n    constructor(from, to) {\r\n        this._from = from;\r\n        this._to = to;\r\n        this._total = 0;\r\n        this._ignored = 0;\r\n        this._success = 0;\r\n        this._failed = 0;\r\n    }\r\n    /**\r\n     * Set error if total call failed (e.g. \"invalid api key\" or \"no connection\" ...)\r\n     * @param error error\r\n     * @param total total\r\n     */\r\n    setError(error, total) {\r\n        this._error = error;\r\n        this._total = total;\r\n        this._failed = total;\r\n    }\r\n    error() {\r\n        return this._error;\r\n    }\r\n    setIgnored(ignored) {\r\n        this._total += ignored;\r\n        this._ignored = ignored;\r\n    }\r\n    /**\r\n     * Add a single result to the summary.\r\n     * @param tu tu\r\n     * @param result result\r\n     */\r\n    addSingleResult(tu, result) {\r\n        this._total++;\r\n        if (result.success()) {\r\n            this._success++;\r\n        }\r\n        else {\r\n            this._failed++;\r\n        }\r\n    }\r\n    /**\r\n     * Merge another summary into this one.\r\n     * @param anotherSummary anotherSummary\r\n     */\r\n    merge(anotherSummary) {\r\n        if (!this._error) {\r\n            this._error = anotherSummary._error;\r\n        }\r\n        this._total += anotherSummary.total();\r\n        this._ignored += anotherSummary.ignored();\r\n        this._success += anotherSummary.success();\r\n        this._failed += anotherSummary.failed();\r\n    }\r\n    total() {\r\n        return this._total;\r\n    }\r\n    ignored() {\r\n        return this._ignored;\r\n    }\r\n    success() {\r\n        return this._success;\r\n    }\r\n    failed() {\r\n        return this._failed;\r\n    }\r\n    /**\r\n     * Human readable version of report\r\n     */\r\n    content() {\r\n        let result;\r\n        if (this._error) {\r\n            result = format('Auto translation from \"%s\" to \"%s\" failed: \"%s\", failed units: %s', this._from, this._to, this._error, this._failed);\r\n        }\r\n        else {\r\n            result = format('Auto translation from \"%s\" to \"%s\", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s', this._from, this._to, this._total, this._ignored, this._success, this._failed);\r\n        }\r\n        return result;\r\n    }\r\n}\n\n/**\r\n * Created by martin on 07.07.2017.\r\n * Service to autotranslate Transunits via Google Translate.\r\n */\r\nclass XliffMergeAutoTranslateService {\r\n    constructor(apikey) {\r\n        this.autoTranslateService = new AutoTranslateService(apikey);\r\n    }\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    autoTranslate(from, to, languageSpecificMessagesFile) {\r\n        return forkJoin([\r\n            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile),\r\n            ...this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)\r\n        ])\r\n            .pipe(map((summaries) => {\r\n            const summary = summaries[0];\r\n            for (let i = 1; i < summaries.length; i++) {\r\n                summary.merge(summaries[i]);\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n    /**\r\n     * Collect all units that are untranslated.\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return all untranslated units\r\n     */\r\n    allUntranslatedTUs(languageSpecificMessagesFile) {\r\n        // collect all units, that should be auto translated\r\n        const allUntranslated = [];\r\n        languageSpecificMessagesFile.forEachTransUnit((tu) => {\r\n            if (tu.targetState() === STATE_NEW) {\r\n                allUntranslated.push(tu);\r\n            }\r\n        });\r\n        return allUntranslated;\r\n    }\r\n    doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile) {\r\n        const allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatable = allUntranslated.filter((tu) => isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        const allMessages = allTranslatable.map((tu) => {\r\n            return tu.sourceContentNormalized().asDisplayString();\r\n        });\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n        // #94 google translate might return &#.. entity refs, that must be decoded\r\n        map((translations) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))), map((translations) => {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(allUntranslated.length - allTranslatable.length);\r\n            for (let i = 0; i < translations.length; i++) {\r\n                const tu = allTranslatable[i];\r\n                const translationText = translations[i];\r\n                const result = this.autoTranslateNonICUUnit(tu, translationText);\r\n                summary.addSingleResult(tu, result);\r\n            }\r\n            return summary;\r\n        }), catchError((err) => {\r\n            const failSummary = new AutoTranslateSummaryReport(from, to);\r\n            failSummary.setError(err.message, allMessages.length);\r\n            return of(failSummary);\r\n        }));\r\n    }\r\n    doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile) {\r\n        const allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatableICU = allUntranslated.filter((tu) => !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        return allTranslatableICU.map((tu) => {\r\n            return this.doAutoTranslateICUMessage(from, to, tu);\r\n        });\r\n    }\r\n    /**\r\n     * Translate single ICU Messages.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tu transunit to translate (must contain ICU Message)\r\n     * @return summary report\r\n     */\r\n    doAutoTranslateICUMessage(from, to, tu) {\r\n        const icuMessage = tu.sourceContentNormalized().getICUMessage();\r\n        const categories = icuMessage.getCategories();\r\n        // check for nested ICUs, we do not support that\r\n        if (categories.find((category) => !isNullOrUndefined(category.getMessageNormalized().getICUMessage()))) {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(1);\r\n            return of(summary);\r\n        }\r\n        const allMessages = categories.map((category) => category.getMessageNormalized().asDisplayString());\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n        // #94 google translate might return &#.. entity refs, that must be decoded\r\n        map((translations) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))), map((translations) => {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            const icuTranslation = {};\r\n            for (let i = 0; i < translations.length; i++) {\r\n                icuTranslation[categories[i].getCategory()] = translations[i];\r\n            }\r\n            const result = this.autoTranslateICUUnit(tu, icuTranslation);\r\n            summary.addSingleResult(tu, result);\r\n            return summary;\r\n        }), catchError((err) => {\r\n            const failSummary = new AutoTranslateSummaryReport(from, to);\r\n            failSummary.setError(err.message, allMessages.length);\r\n            return of(failSummary);\r\n        }));\r\n    }\r\n    autoTranslateNonICUUnit(tu, translatedMessage) {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));\r\n    }\r\n    autoTranslateICUUnit(tu, translation) {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));\r\n    }\r\n    autoTranslateUnit(tu, translatedMessage) {\r\n        const errors = translatedMessage.validate();\r\n        const warnings = translatedMessage.validateWarnings();\r\n        if (!isNullOrUndefined(errors)) {\r\n            return new AutoTranslateResult(false, 'errors detected, not translated');\r\n        }\r\n        else if (!isNullOrUndefined(warnings)) {\r\n            return new AutoTranslateResult(false, 'warnings detected, not translated');\r\n        }\r\n        else {\r\n            tu.translate(translatedMessage);\r\n            return new AutoTranslateResult(true, null); // success\r\n        }\r\n    }\r\n}\n\n/**\r\n * Created by martin on 17.02.2017.\r\n * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.\r\n *\r\n */\r\nclass XliffMerge {\r\n    constructor(commandOutput, options) {\r\n        this.commandOutput = commandOutput;\r\n        this.options = options;\r\n        this.parameters = null;\r\n    }\r\n    static main(argv) {\r\n        const options = XliffMerge.parseArgs(argv);\r\n        if (options) {\r\n            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {\r\n                process.exit(result);\r\n            });\r\n        }\r\n    }\r\n    static parseArgs(argv) {\r\n        const options = {\r\n            languages: []\r\n        };\r\n        for (let i = 1; i < argv.length; i++) {\r\n            const arg = argv[i];\r\n            if (arg === '--version' || arg === '-version') {\r\n                console.log('xliffmerge ' + VERSION);\r\n            }\r\n            else if (arg === '--verbose' || arg === '-v') {\r\n                options.verbose = true;\r\n            }\r\n            else if (arg === '--profile' || arg === '-p') {\r\n                i++;\r\n                if (i >= argv.length) {\r\n                    console.log('missing config file');\r\n                    XliffMerge.showUsage();\r\n                    return null;\r\n                }\r\n                else {\r\n                    options.profilePath = argv[i];\r\n                }\r\n            }\r\n            else if (arg === '--quiet' || arg === '-q') {\r\n                options.quiet = true;\r\n            }\r\n            else if (arg === '--help' || arg === '-help' || arg === '-h') {\r\n                XliffMerge.showUsage();\r\n            }\r\n            else if (arg.length > 0 && arg.charAt(0) === '-') {\r\n                console.log('unknown option');\r\n                return null;\r\n            }\r\n            else {\r\n                options.languages.push(arg);\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n    static showUsage() {\r\n        console.log('usage: xliffmerge <option>* <language>*');\r\n        console.log('Options');\r\n        console.log('\\t-p|--profile a json configuration file containing all relevant parameters.');\r\n        console.log('\\t\\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');\r\n        console.log('\\t-v|--verbose show some output for debugging purposes');\r\n        console.log('\\t-q|--quiet only show errors, nothing else');\r\n        console.log('\\t-version|--version show version string');\r\n        console.log('');\r\n        console.log('\\t<language> has to be a valid language short string, e,g. \"en\", \"de\", \"de-ch\"');\r\n    }\r\n    /**\r\n     * For Tests, create instance with given profile\r\n     * @param commandOutput commandOutput\r\n     * @param options options\r\n     * @param profileContent profileContent\r\n     */\r\n    static createFromOptions(commandOutput, options, profileContent) {\r\n        const instance = new XliffMerge(commandOutput, options);\r\n        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);\r\n        return instance;\r\n    }\r\n    /**\r\n     * Run the command.\r\n     * This runs async.\r\n     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.\r\n     * @param errorFunction callbackFunction for error handling\r\n     */\r\n    run(callbackFunction, errorFunction) {\r\n        this.runAsync()\r\n            .subscribe((retcode) => {\r\n            if (!isNullOrUndefined(callbackFunction)) {\r\n                callbackFunction(retcode);\r\n            }\r\n        }, (error) => {\r\n            if (!isNullOrUndefined(errorFunction)) {\r\n                errorFunction(error);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Execute merge-Process.\r\n     * @return Async operation, on completion returns retcode 0=ok, other = error.\r\n     */\r\n    runAsync() {\r\n        if (this.options && this.options.quiet) {\r\n            this.commandOutput.setQuiet();\r\n        }\r\n        if (this.options && this.options.verbose) {\r\n            this.commandOutput.setVerbose();\r\n        }\r\n        if (!this.parameters) {\r\n            this.parameters = XliffMergeParameters.createFromOptions(this.options);\r\n        }\r\n        this.commandOutput.info('xliffmerge version %s', VERSION);\r\n        if (this.parameters.verbose()) {\r\n            this.parameters.showAllParameters(this.commandOutput);\r\n        }\r\n        if (this.parameters.errorsFound.length > 0) {\r\n            for (const err of this.parameters.errorsFound) {\r\n                this.commandOutput.error(err.message);\r\n            }\r\n            return of(-1);\r\n        }\r\n        if (this.parameters.warningsFound.length > 0) {\r\n            for (const warn of this.parameters.warningsFound) {\r\n                this.commandOutput.warn(warn);\r\n            }\r\n        }\r\n        this.readMaster();\r\n        if (this.parameters.autotranslate()) {\r\n            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());\r\n        }\r\n        const executionForAllLanguages = [];\r\n        this.parameters.languages().forEach((lang) => {\r\n            executionForAllLanguages.push(this.processLanguage(lang));\r\n        });\r\n        return forkJoin(executionForAllLanguages).pipe(map((retcodes) => this.totalRetcode(retcodes)));\r\n    }\r\n    /**\r\n     * Give an array of retcodes for the different languages, return the total retcode.\r\n     * If all are 0, it is 0, otherwise the first non zero.\r\n     * @param retcodes retcodes\r\n     * @return number\r\n     */\r\n    totalRetcode(retcodes) {\r\n        for (let i = 0; i < retcodes.length; i++) {\r\n            if (retcodes[i] !== 0) {\r\n                return retcodes[i];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Return the name of the generated file for given lang.\r\n     * @param lang language\r\n     * @return name of generated file\r\n     */\r\n    generatedI18nFile(lang) {\r\n        return this.parameters.generatedI18nFile(lang);\r\n    }\r\n    /**\r\n     * Return the name of the generated ngx-translation file for given lang.\r\n     * @param lang language\r\n     * @return name of translate file\r\n     */\r\n    generatedNgxTranslateFile(lang) {\r\n        return this.parameters.generatedNgxTranslateFile(lang);\r\n    }\r\n    /**\r\n     * Warnings found during the run.\r\n     * @return warnings\r\n     */\r\n    warnings() {\r\n        return this.parameters.warningsFound;\r\n    }\r\n    readMaster() {\r\n        try {\r\n            this.master = TranslationMessagesFileReader.fromFile(this.parameters.i18nFormat(), this.parameters.i18nFile(), this.parameters.encoding());\r\n            this.master.warnings().forEach((warning) => {\r\n                this.commandOutput.warn(warning);\r\n            });\r\n            const count = this.master.numberOfTransUnits();\r\n            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();\r\n            this.commandOutput.info('master contains %s trans-units', count);\r\n            if (missingIdCount > 0) {\r\n                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);\r\n            }\r\n            const sourceLang = this.master.sourceLanguage();\r\n            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {\r\n                this.commandOutput.warn('master says to have source-language=\"%s\", should be \"%s\" (your defaultLanguage)', sourceLang, this.parameters.defaultLanguage());\r\n                this.master.setSourceLanguage(this.parameters.defaultLanguage());\r\n                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());\r\n                this.commandOutput.warn('changed master source-language=\"%s\" to \"%s\"', sourceLang, this.parameters.defaultLanguage());\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            }\r\n            else {\r\n                // unhandled\r\n                const currentFilename = this.parameters.i18nFile();\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Process the given language.\r\n     * Async operation.\r\n     * @param lang language\r\n     * @return on completion 0 for ok, other for error\r\n     */\r\n    processLanguage(lang) {\r\n        this.commandOutput.debug('processing language %s', lang);\r\n        const languageXliffFile = this.parameters.generatedI18nFile(lang);\r\n        const currentFilename = languageXliffFile;\r\n        let result;\r\n        if (!FileUtil.exists(languageXliffFile)) {\r\n            result = this.createUntranslatedXliff(lang, languageXliffFile);\r\n        }\r\n        else {\r\n            result = this.mergeMasterTo(lang, languageXliffFile);\r\n        }\r\n        return result\r\n            .pipe(map(() => {\r\n            if (this.parameters.supportNgxTranslate()) {\r\n                const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFile, this.parameters.encoding(), this.master.filename());\r\n                NgxTranslateExtractor.extract(languageSpecificMessagesFile, this.parameters.ngxTranslateExtractionPattern(), this.parameters.generatedNgxTranslateFile(lang));\r\n            }\r\n            return 0;\r\n        }), catchError((err) => {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            }\r\n            else {\r\n                // unhandled\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * create a new file for the language, which contains no translations, but all keys.\r\n     * in principle, this is just a copy of the master with target-language set.\r\n     * @param lang language\r\n     * @param languageXliffFilePath name of file\r\n     */\r\n    createUntranslatedXliff(lang, languageXliffFilePath) {\r\n        // copy master ...\r\n        // and set target-language\r\n        // and copy source to target if necessary\r\n        const isDefaultLang = (lang === this.parameters.defaultLanguage());\r\n        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        const languageSpecificMessagesFile = this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());\r\n        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(map(( /* summary */) => {\r\n            // write it to file\r\n            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n            this.commandOutput.info('created new file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n            if (!isDefaultLang) {\r\n                this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n    /**\r\n     * Map the input format to the format of the translation.\r\n     * Normally they are the same but for xmb the translation format is xtb.\r\n     * @param i18nFormat format\r\n     */\r\n    translationFormat(i18nFormat) {\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return FORMAT_XTB;\r\n        }\r\n        else {\r\n            return i18nFormat;\r\n        }\r\n    }\r\n    /**\r\n     * Merge all\r\n     * @param lang language\r\n     * @param languageXliffFilePath filename\r\n     */\r\n    mergeMasterTo(lang, languageXliffFilePath) {\r\n        // read lang specific file\r\n        const languageSpecificMessagesFile = TranslationMessagesFileReader.fromFile(this.translationFormat(this.parameters.i18nFormat()), languageXliffFilePath, this.parameters.encoding());\r\n        const isDefaultLang = (lang === this.parameters.defaultLanguage());\r\n        let newCount = 0;\r\n        let correctSourceContentCount = 0;\r\n        let correctSourceRefCount = 0;\r\n        let correctDescriptionOrMeaningCount = 0;\r\n        let idChangedCount = 0;\r\n        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        let lastProcessedUnit = null;\r\n        this.master.forEachTransUnit((masterTransUnit) => {\r\n            const transUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);\r\n            if (!transUnit) {\r\n                // oops, no translation, must be a new key, so add it\r\n                let newUnit;\r\n                if (this.parameters.allowIdChange()\r\n                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {\r\n                    lastProcessedUnit = newUnit;\r\n                    idChangedCount++;\r\n                }\r\n                else {\r\n                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, isDefaultLang, this.parameters.useSourceAsTarget(), (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n                    newCount++;\r\n                }\r\n            }\r\n            else {\r\n                // check for changed source content and change it if needed\r\n                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.\r\n                if (transUnit.supportsSetSourceContent() && !this.areSourcesNearlyEqual(masterTransUnit, transUnit)) {\r\n                    transUnit.setSourceContent(masterTransUnit.sourceContent());\r\n                    if (isDefaultLang) {\r\n                        // #81 changed source must be copied to target for default lang\r\n                        transUnit.translate(masterTransUnit.sourceContent());\r\n                        transUnit.setTargetState(STATE_FINAL);\r\n                    }\r\n                    else {\r\n                        if (transUnit.targetState() === STATE_FINAL) {\r\n                            // source is changed, so translation has to be checked again\r\n                            transUnit.setTargetState(STATE_TRANSLATED);\r\n                        }\r\n                    }\r\n                    correctSourceContentCount++;\r\n                }\r\n                // check for missing or changed source ref and add it if needed\r\n                if (transUnit.supportsSetSourceReferences()\r\n                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {\r\n                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());\r\n                    correctSourceRefCount++;\r\n                }\r\n                // check for changed description or meaning\r\n                if (transUnit.supportsSetDescriptionAndMeaning()) {\r\n                    let changed = false;\r\n                    if (transUnit.description() !== masterTransUnit.description()) {\r\n                        transUnit.setDescription(masterTransUnit.description());\r\n                        changed = true;\r\n                    }\r\n                    if (transUnit.meaning() !== masterTransUnit.meaning()) {\r\n                        transUnit.setMeaning(masterTransUnit.meaning());\r\n                        changed = true;\r\n                    }\r\n                    if (changed) {\r\n                        correctDescriptionOrMeaningCount++;\r\n                    }\r\n                }\r\n                lastProcessedUnit = transUnit;\r\n            }\r\n        });\r\n        if (newCount > 0) {\r\n            this.commandOutput.warn('merged %s trans-units from master to \"%s\"', newCount, lang);\r\n        }\r\n        if (correctSourceContentCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed source content from master to \"%s\"', correctSourceContentCount, lang);\r\n        }\r\n        if (correctSourceRefCount > 0) {\r\n            this.commandOutput.warn('transferred %s source references from master to \"%s\"', correctSourceRefCount, lang);\r\n        }\r\n        if (idChangedCount > 0) {\r\n            this.commandOutput.warn('found %s changed id\\'s in \"%s\"', idChangedCount, lang);\r\n        }\r\n        if (correctDescriptionOrMeaningCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed descriptions/meanings from master to \"%s\"', correctDescriptionOrMeaningCount, lang);\r\n        }\r\n        // remove all elements that are no longer used\r\n        let removeCount = 0;\r\n        languageSpecificMessagesFile.forEachTransUnit((transUnit) => {\r\n            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));\r\n            if (!existsInMaster) {\r\n                if (this.parameters.removeUnusedIds()) {\r\n                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);\r\n                }\r\n                removeCount++;\r\n            }\r\n        });\r\n        if (removeCount > 0) {\r\n            if (this.parameters.removeUnusedIds()) {\r\n                this.commandOutput.warn('removed %s unused trans-units in \"%s\"', removeCount, lang);\r\n            }\r\n            else {\r\n                this.commandOutput.warn('keeping %s unused trans-units in \"%s\", because removeUnused is disabled', removeCount, lang);\r\n            }\r\n        }\r\n        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0\r\n            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {\r\n            this.commandOutput.info('file for \"%s\" was up to date', lang);\r\n            return of(null);\r\n        }\r\n        else {\r\n            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)\r\n                .pipe(map(() => {\r\n                // write it to file\r\n                TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n                this.commandOutput.info('updated file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n                if (newCount > 0 && !isDefaultLang) {\r\n                    this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n                }\r\n                return null;\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Handle the case of changed id due to small white space changes.\r\n     * @param masterTransUnit unit in master file\r\n     * @param languageSpecificMessagesFile translation file\r\n     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.\r\n     * @return processed unit, if done, null if no changed unit found\r\n     */\r\n    processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit) {\r\n        let changedTransUnit = null;\r\n        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {\r\n            if (this.areSourcesNearlyEqual(languageTransUnit, masterTransUnit)) {\r\n                changedTransUnit = languageTransUnit;\r\n            }\r\n        });\r\n        if (!changedTransUnit) {\r\n            return null;\r\n        }\r\n        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, false, false, (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n        const translatedContent = changedTransUnit.targetContent();\r\n        if (translatedContent) { // issue #68 set translated only, if it is really translated\r\n            mergedTransUnit.translate(translatedContent);\r\n            mergedTransUnit.setTargetState(STATE_TRANSLATED);\r\n        }\r\n        return mergedTransUnit;\r\n    }\r\n    /**\r\n     * test wether the sources of 2 trans units are equal ignoring white spaces.\r\n     * @param tu1 tu1\r\n     * @param tu2 tu2\r\n     */\r\n    areSourcesNearlyEqual(tu1, tu2) {\r\n        if ((tu1 && !tu2) || (tu2 && !tu1)) {\r\n            return false;\r\n        }\r\n        const tu1Normalized = tu1.sourceContentNormalized();\r\n        const tu2Normalized = tu2.sourceContentNormalized();\r\n        if (tu1Normalized.isICUMessage()) {\r\n            if (tu2Normalized.isICUMessage()) {\r\n                const icu1Normalized = tu1Normalized.getICUMessage().asNativeString().trim();\r\n                const icu2Normalized = tu2Normalized.getICUMessage().asNativeString().trim();\r\n                return icu1Normalized === icu2Normalized;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        if (tu1Normalized.containsICUMessageRef()) {\r\n            const icuref1Normalized = tu1Normalized.asNativeString().trim();\r\n            const icuref2Normalized = tu2Normalized.asNativeString().trim();\r\n            return icuref1Normalized === icuref2Normalized;\r\n        }\r\n        const s1Normalized = tu1Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        const s2Normalized = tu2Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        return s1Normalized === s2Normalized;\r\n    }\r\n    areSourceReferencesEqual(ref1, ref2) {\r\n        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {\r\n            return false;\r\n        }\r\n        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {\r\n            return true;\r\n        }\r\n        // bot refs are set now, convert to set to compare them\r\n        const set1 = new Set();\r\n        ref1.forEach((ref) => { set1.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        const set2 = new Set();\r\n        ref2.forEach((ref) => { set2.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        if (set1.size !== set2.size) {\r\n            return false;\r\n        }\r\n        let match = true;\r\n        set2.forEach((ref) => {\r\n            if (!set1.has(ref)) {\r\n                match = false;\r\n            }\r\n        });\r\n        return match;\r\n    }\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    autoTranslate(from, to, languageSpecificMessagesFile) {\r\n        let serviceCall;\r\n        const autotranslateEnabled = this.parameters.autotranslateLanguage(to);\r\n        if (autotranslateEnabled) {\r\n            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);\r\n        }\r\n        else {\r\n            serviceCall = of(new AutoTranslateSummaryReport(from, to));\r\n        }\r\n        return serviceCall.pipe(map((summary) => {\r\n            if (autotranslateEnabled) {\r\n                if (summary.error() || summary.failed() > 0) {\r\n                    this.commandOutput.error(summary.content());\r\n                }\r\n                else {\r\n                    this.commandOutput.warn(summary.content());\r\n                }\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n}\n\n/*\r\n * Public API Surface of xliffmerge\r\n * In principle, there is only the bin file xliffmerge,\r\n * because this is not mentioned as a library.\r\n * But the tooling uses the configuration file type.\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CommandOutput, WriterToString, XliffMerge, XliffmergeModule };\n//# sourceMappingURL=ngx-i18nsupport-ngx-i18nsupport.mjs.map\n","map":{"version":3,"file":"ngx-i18nsupport-ngx-i18nsupport.mjs","sources":["../../../projects/xliffmerge/src/lib/xliffmerge.module.ts","../../../projects/xliffmerge/src/common/util.ts","../../../projects/xliffmerge/src/common/writer-to-string.ts","../../../projects/xliffmerge/src/common/command-output.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge-error.ts","../../../projects/xliffmerge/src/common/file-util.ts","../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extraction-pattern.ts","../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extractor.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge-parameters.ts","../../../projects/xliffmerge/src/xliffmerge/version.ts","../../../projects/xliffmerge/src/xliffmerge/xml-reader.ts","../../../projects/xliffmerge/src/xliffmerge/translation-messages-file-reader.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-service.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-result.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-summary-report.ts","../../../projects/xliffmerge/src/autotranslate/xliff-merge-auto-translate-service.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge.ts","../../../projects/xliffmerge/src/public_api.ts","../../../projects/xliffmerge/src/ngx-i18nsupport-ngx-i18nsupport.ts"],"sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n// not used, only there to make ng-packagr happy\r\n@NgModule({\r\n    imports: [\r\n    ],\r\n    declarations: [],\r\n    exports: []\r\n})\r\nexport class XliffmergeModule { }\r\n","/**\r\n * Collection of utility functions that are deprecated in nodes util.\r\n */\r\n\r\n/**\r\n * Replaces node isNullOrUndefined.\r\n */\r\nexport function isNullOrUndefined(value: any) {\r\n    return value === undefined || value === null;\r\n}\r\n\r\n/**\r\n * Replaces node isString.\r\n */\r\nexport function isString(value: any) {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Replaces node isBoolean.\r\n */\r\nexport function isBoolean(value: any) {\r\n    return typeof value === 'boolean';\r\n}\r\n\r\n/**\r\n * Replaces node isNumber.\r\n */\r\nexport function isNumber(value: any) {\r\n    return typeof value === 'number';\r\n}\r\n\r\n/**\r\n * Replaces node isArray.\r\n */\r\nexport function isArray(value: any) {\r\n    return Array.isArray(value);\r\n}\r\n","import {Writable} from 'stream';\r\nimport {isString} from './util';\r\n/**\r\n * Created by martin on 20.02.2017.\r\n * A helper class for testing.\r\n * Can be used as a WritableStream and writes everything (synchronously) into a string,\r\n * that can easily be read by the tests.\r\n */\r\n\r\nexport class WriterToString extends Writable {\r\n\r\n    private resultString: string;\r\n\r\n    constructor() {\r\n        super();\r\n        this.resultString = '';\r\n    }\r\n\r\n    public _write(chunk: any, encoding: BufferEncoding, callback: Function): void {\r\n        let chunkString;\r\n        if (isString(chunk)) {\r\n            chunkString = chunk;\r\n        } else if (chunk instanceof Buffer) {\r\n            chunkString = chunk.toString();\r\n        } else {\r\n            chunkString = Buffer.alloc(chunk).toString(encoding);\r\n        }\r\n        this.resultString = this.resultString + chunkString;\r\n        callback();\r\n    }\r\n\r\n    /**\r\n     * Returns a string of everything, that was written to the stream so far.\r\n     * @return written data\r\n     */\r\n    public writtenData(): string {\r\n        return this.resultString;\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Very simple class to control the output of a command.\r\n * Output can be errors, warnings, infos and debug-Outputs.\r\n * The output can be controlled via 2 flags, quiet and verbose.\r\n * If quit is enabled only error messages are shown.\r\n * If verbose is enabled, everything is shown.\r\n * If both are not enabled (the default) errors, warnings and infos are shown.\r\n * If not are enabled (strange), we assumed the default.\r\n */\r\n\r\nimport chalk from 'chalk';\r\nimport WritableStream = NodeJS.WritableStream;\r\nimport {format} from 'util';\r\n\r\nenum LogLevel {\r\n    'ERROR',\r\n    'WARN',\r\n    'INFO',\r\n    'DEBUG'\r\n}\r\n\r\nexport class CommandOutput {\r\n\r\n    /**\r\n     * verbose enables output of everything.\r\n     */\r\n    public _verbose: boolean;\r\n\r\n    /**\r\n     * quiet disables output of everything but errors.\r\n     */\r\n    public _quiet: boolean;\r\n\r\n    private outputStream: WritableStream;\r\n\r\n    constructor(stdout?: WritableStream) {\r\n        this._quiet = false;\r\n        this._verbose = false;\r\n        if (stdout) {\r\n            this.outputStream = stdout;\r\n        } else {\r\n            this.outputStream = process.stdout;\r\n        }\r\n    }\r\n\r\n    public setVerbose() {\r\n        this._verbose = true;\r\n    }\r\n\r\n    public setQuiet() {\r\n        this._quiet = true;\r\n    }\r\n\r\n    /**\r\n     * Test, wether verbose is enabled.\r\n     * @return wether verbose is enabled.\r\n     */\r\n    public verbose(): boolean {\r\n        return this._verbose;\r\n    }\r\n\r\n    /**\r\n     * Test, wether quiet is enabled.\r\n     * @return wether quiet is enabled.\r\n     */\r\n    public quiet(): boolean {\r\n        return this._quiet;\r\n    }\r\n\r\n    public error(msg, ...params: any[]) {\r\n        this.log(LogLevel.ERROR, msg, params);\r\n    }\r\n\r\n    public warn(msg, ...params: any[]) {\r\n        this.log(LogLevel.WARN, msg, params);\r\n    }\r\n\r\n    public info(msg, ...params: any[]) {\r\n        this.log(LogLevel.INFO, msg, params);\r\n    }\r\n\r\n    public debug(msg, ...params: any[]) {\r\n        this.log(LogLevel.DEBUG, msg, params);\r\n    }\r\n\r\n    private log(level: LogLevel, msg, params: any[]) {\r\n        if (!this.isOutputEnabled(level)) {\r\n            return;\r\n        }\r\n        let coloredMessage;\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                coloredMessage = chalk.red('ERROR: ' + msg);\r\n                break;\r\n            case LogLevel.WARN:\r\n                coloredMessage = chalk.magenta('WARNING: ' + msg);\r\n                break;\r\n            default:\r\n                coloredMessage = chalk.gray('* ' + msg);\r\n                break;\r\n        }\r\n        const outMsg = format(coloredMessage, ...params);\r\n        this.outputStream.write(outMsg + '\\n');\r\n    }\r\n\r\n    private isOutputEnabled(level: LogLevel): boolean {\r\n        let quietEnabled, verboseEnabled: boolean;\r\n        if (this._quiet && this._verbose) {\r\n            quietEnabled = false;\r\n            verboseEnabled = false;\r\n        } else {\r\n            quietEnabled = this._quiet;\r\n            verboseEnabled = this._verbose;\r\n        }\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                return true;    // always output errors\r\n            case LogLevel.WARN:\r\n                return (!quietEnabled);\r\n            case LogLevel.INFO:\r\n                return (verboseEnabled && !quietEnabled);\r\n            case LogLevel.DEBUG:\r\n                return verboseEnabled;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n */\r\n\r\nexport class XliffMergeError extends Error {\r\n\r\n    constructor(msg: string) {\r\n        super(msg);\r\n\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, XliffMergeError.prototype);\r\n    }\r\n}\r\n","import * as fs from 'fs';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * Some (a few) simple utils for file operations.\r\n * Just for convenience.\r\n */\r\n\r\nexport class FileUtil {\r\n\r\n    /**\r\n     * Check for existence.\r\n     * @param filename filename\r\n     * @return wether file exists\r\n     */\r\n    public static exists(filename: string) {\r\n        return fs.existsSync(filename);\r\n    }\r\n\r\n    /**\r\n     * Read a file.\r\n     * @param filename filename\r\n     * @param encoding encoding\r\n     * @return content of file\r\n     */\r\n    public static read(filename: string, encoding: BufferEncoding) {\r\n        return fs.readFileSync(filename, encoding);\r\n    }\r\n\r\n    /**\r\n     * Write a file with given content.\r\n     * @param filename filename\r\n     * @param newContent newContent\r\n     * @param encoding encoding\r\n     */\r\n    public static replaceContent(filename: string, newContent: string, encoding: BufferEncoding) {\r\n        fs.writeFileSync(filename, newContent, {encoding: encoding});\r\n    }\r\n\r\n    public static copy(srcFile: string, destFile: string) {\r\n        const BUF_LENGTH = 64 * 1024;\r\n        const buff = Buffer.alloc(BUF_LENGTH);\r\n        const fdr = fs.openSync(srcFile, 'r');\r\n        const fdw = fs.openSync(destFile, 'w');\r\n        let bytesRead = 1;\r\n        let pos = 0;\r\n        while (bytesRead > 0) {\r\n            bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);\r\n            fs.writeSync(fdw, buff, 0, bytesRead);\r\n            pos += bytesRead;\r\n        }\r\n        fs.closeSync(fdr);\r\n        fs.closeSync(fdw);\r\n    }\r\n\r\n    /**\r\n     * Delete the folder and all of its content (rm -rf).\r\n     * @param path path\r\n     */\r\n    public static deleteFolderRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n            fs.rmdirSync(path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete folders content recursively, but do not delete folder.\r\n     * Folder is left empty at the end.\r\n     * @param path path\r\n     */\r\n    public static deleteFolderContentRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path)) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function (file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a file.\r\n     * @param path path\r\n     */\r\n    public static deleteFile(path: string) {\r\n        fs.unlinkSync(path);\r\n    }\r\n}\r\n","/**\r\n * Helper class to parse ngx translate extraction pattern\r\n * and to decide wether a given message matches the pattern.\r\n */\r\nexport class NgxTranslateExtractionPattern {\r\n\r\n    private _matchExplicitId: boolean;\r\n    private _descriptionPatterns: string[];\r\n\r\n    /**\r\n     * Construct the pattern from given description string\r\n     * @param extractionPatternString extractionPatternString\r\n     * @throws an error, if there is a syntax error\r\n     */\r\n    constructor(private extractionPatternString: string) {\r\n        const parts = extractionPatternString.split('|');\r\n        this._matchExplicitId = false;\r\n        this._descriptionPatterns = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            if (part === '@@') {\r\n                if (this._matchExplicitId) {\r\n                    throw new Error('extraction pattern must not contain @@ twice');\r\n                }\r\n                this._matchExplicitId = true;\r\n            } else {\r\n                const errorString = this.checkValidDescriptionPattern(part);\r\n                if (errorString) {\r\n                    throw new Error(errorString);\r\n                }\r\n                this._descriptionPatterns.push(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check, wether an explicitly set id matches the pattern.\r\n     * @param id id\r\n     * @return wether an explicitly set id matches the pattern.\r\n     */\r\n    public isExplicitIdMatched(id: string): boolean {\r\n        return id && this._matchExplicitId;\r\n    }\r\n\r\n    /**\r\n     * Check, wether a given description matches the pattern.\r\n     * @param description description\r\n     * @return wether a given description matches the pattern.\r\n     */\r\n    public isDescriptionMatched(description: string): boolean {\r\n        return this._descriptionPatterns.indexOf(description) >= 0;\r\n    }\r\n\r\n    private checkValidDescriptionPattern(descriptionPattern: string): string {\r\n        if (!descriptionPattern) {\r\n            return 'empty value not allowed';\r\n        }\r\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\r\n            return null; // it is ok\r\n        } else {\r\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\r\n        }\r\n    }\r\n}\r\n","import {ITranslationMessagesFile, ITransUnit, NORMALIZATION_FORMAT_NGXTRANSLATE} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {NgxTranslateExtractionPattern} from './ngx-translate-extraction-pattern';\r\n/**\r\n * Created by roobm on 15.03.2017.\r\n * A tool for extracting messages in ngx-translate format.\r\n * Generates a json-file to be used with ngx-translate.\r\n */\r\n\r\n/**\r\n * The interface used for translations in ngx-translate.\r\n * A hash that contains either the translation or another hash.\r\n */\r\ninterface NgxTranslations {\r\n    [id: string]: NgxTranslations | string;\r\n}\r\n\r\n/**\r\n * internal,\r\n * a message with id (a dot-separated string).\r\n */\r\ninterface NgxMessage {\r\n    id: string; // dot separated name, e.g. \"myapp.service1.message1\"\r\n    message: string; // the message, placeholder are in {{n}} syntax, e.g. \"a test with value: {{0}}\r\n}\r\n\r\nexport class NgxTranslateExtractor {\r\n\r\n    public static DefaultExtractionPattern = '@@|ngx-translate';\r\n    private extractionPattern: NgxTranslateExtractionPattern;\r\n\r\n    /**\r\n     * Check, wether extractionPattern has valid syntax.\r\n     * @param extractionPatternString extractionPatternString\r\n     * @return null, if pattern is ok, string describing the error, if it is not ok.\r\n     */\r\n    public static checkPattern(extractionPatternString: string): string {\r\n        try {\r\n          if (new NgxTranslateExtractionPattern(extractionPatternString)) {\r\n              return null;\r\n          }\r\n        } catch (error) {\r\n            return error.message;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static extract(messagesFile: ITranslationMessagesFile, extractionPattern: string, outputFile: string) {\r\n        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);\r\n    }\r\n\r\n    constructor(private messagesFile: ITranslationMessagesFile, extractionPatternString: string) {\r\n        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);\r\n    }\r\n\r\n    /**\r\n     * Extact messages and write them to a file.\r\n     * @param outputFile outputFile\r\n     */\r\n    public extractTo(outputFile: string) {\r\n        const translations: NgxTranslations = this.toNgxTranslations(this.extract());\r\n        if (translations && Object.keys(translations).length > 0) {\r\n            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'utf-8');\r\n        } else {\r\n            if (FileUtil.exists(outputFile)) {\r\n                FileUtil.deleteFile(outputFile);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Extract messages and convert them to ngx translations.\r\n     *  @return the translation objects.\r\n     */\r\n    private extract(): NgxMessage[] {\r\n        const result: NgxMessage[] = [];\r\n        this.messagesFile.forEachTransUnit((tu: ITransUnit) => {\r\n            const ngxId = this.ngxTranslateIdFromTU(tu);\r\n            if (ngxId) {\r\n                const messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);\r\n                result.push({id: ngxId, message: messagetext});\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.\r\n     * There are 2 possibilities:\r\n     * 1. description is set to \"ngx-translate\" and meaning contains the id.\r\n     * 2. id is explicitly set to a string.\r\n     * @param tu tu\r\n     * @return an ngx id or null, if this tu should not be extracted.\r\n     */\r\n    private ngxTranslateIdFromTU(tu: ITransUnit): string {\r\n        if (this.isExplicitlySetId(tu.id)) {\r\n            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {\r\n                return tu.id;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        const description = tu.description();\r\n        if (description && this.extractionPattern.isDescriptionMatched(description)) {\r\n            return tu.meaning();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether ID was explicitly set (via i18n=\"@myid).\r\n     * Just heuristic, an ID is explicitly, if it does not look like a generated one.\r\n     * @param id id\r\n     * @return wether ID was explicitly set (via i18n=\"@myid).\r\n     */\r\n    private isExplicitlySetId(id: string): boolean {\r\n        if (isNullOrUndefined(id)) {\r\n            return false;\r\n        }\r\n        // generated IDs are either decimal or sha1 hex\r\n        const reForGeneratedId = /^[0-9a-f]{11,}$/;\r\n        return !reForGeneratedId.test(id);\r\n    }\r\n\r\n    /**\r\n     * Convert list of relevant TUs to ngx translations object.\r\n     * @param msgList msgList\r\n     */\r\n    private toNgxTranslations(msgList: NgxMessage[]): NgxTranslations {\r\n        const translationObject: NgxTranslations = {};\r\n        msgList.forEach((msg: NgxMessage) => {\r\n            this.putInTranslationObject(translationObject, msg);\r\n        });\r\n        return translationObject;\r\n    }\r\n\r\n    /**\r\n     * Put a new messages into the translation data object.\r\n     * If you add, e.g. \"{id: 'myapp.example', message: 'test'}\",\r\n     * the translation object will then contain an object myapp that has property example:\r\n     * {myapp: {\r\n     *   example: 'test'\r\n     *   }}\r\n     * @param translationObject translationObject\r\n     * @param msg msg\r\n     */\r\n    private putInTranslationObject(translationObject: NgxTranslations, msg: NgxMessage) {\r\n        let firstPartOfId: string;\r\n        let restOfId: string;\r\n        const indexOfDot = msg.id.indexOf('.');\r\n        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {\r\n            throw new Error('bad nxg-translate id \"' + msg.id + '\"');\r\n        }\r\n        if (indexOfDot < 0) {\r\n            firstPartOfId = msg.id;\r\n            restOfId = '';\r\n        } else {\r\n            firstPartOfId = msg.id.substring(0, indexOfDot);\r\n            restOfId = msg.id.substring(indexOfDot + 1);\r\n        }\r\n        let object = translationObject[firstPartOfId];\r\n        if (isNullOrUndefined(object)) {\r\n            if (restOfId === '') {\r\n                translationObject[firstPartOfId] = msg.message;\r\n                return;\r\n            }\r\n            object = {};\r\n            translationObject[firstPartOfId] = object;\r\n        } else {\r\n            if (restOfId === '') {\r\n                throw new Error('duplicate id praefix \"' + msg.id + '\"');\r\n            }\r\n        }\r\n        this.putInTranslationObject(<NgxTranslations> object, {id: restOfId, message: msg.message});\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Collection of all parameters used by the tool.\r\n * The parameters are read form the profile or defaults are used.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {Stats} from 'fs';\r\nimport {CommandOutput} from '../common/command-output';\r\nimport {format} from 'util';\r\nimport {isArray, isNullOrUndefined} from '../common/util';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {dirname, isAbsolute, join, normalize} from 'path';\r\n\r\nconst PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];\r\n\r\nexport class XliffMergeParameters {\r\n\r\n    private usedProfilePath: string;\r\n    private _quiet: boolean;\r\n    private _verbose: boolean;\r\n    private _allowIdChange: boolean;\r\n    private _defaultLanguage: string;\r\n    private _srcDir: string;\r\n    private _i18nBaseFile: string;\r\n    private _i18nFile: string;\r\n    private _i18nFormat: string;\r\n    private _encoding: BufferEncoding ;\r\n    private _genDir: string;\r\n    private _languages: string[];\r\n    private _removeUnusedIds: boolean;\r\n    private _supportNgxTranslate: boolean;\r\n    private _ngxTranslateExtractionPattern: string;\r\n    private _useSourceAsTarget: boolean;\r\n    private _targetPraefix: string;\r\n    private _targetSuffix: string;\r\n    private _beautifyOutput: boolean;\r\n    private _preserveOrder: boolean;\r\n    private _autotranslate: boolean|string[];\r\n    private _apikey: string;\r\n    private _apikeyfile: string;\r\n\r\n    public errorsFound: XliffMergeError[];\r\n    public warningsFound: string[];\r\n\r\n    /**\r\n     * Create Parameters.\r\n     * @param options command options\r\n     * @param profileContent given profile (if not, it is read from the profile path from options).\r\n     */\r\n    public static createFromOptions(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const parameters = new XliffMergeParameters();\r\n        parameters.configure(options, profileContent);\r\n        return parameters;\r\n    }\r\n\r\n    private constructor() {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n    }\r\n\r\n    /**\r\n     * Read potential profile.\r\n     * To be a candidate, file must exist and contain property \"xliffmergeOptions\".\r\n     * @param profilePath path of profile\r\n     * @return parsed content of file or null, if file does not exist or is not a profile candidate.\r\n     */\r\n    private static readProfileCandidate(profilePath: string): IConfigFile {\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        } catch (err) {\r\n            return null;\r\n        }\r\n        const parsedContent: IConfigFile = JSON.parse(content);\r\n        if (parsedContent && parsedContent.xliffmergeOptions) {\r\n            return parsedContent;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize me from the profile content.\r\n     * (public only for test usage).\r\n     * @param options options given at runtime via command line\r\n     * @param profileContent if null, read it from profile.\r\n     */\r\n    private configure(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n        if (!profileContent) {\r\n            profileContent = this.readProfile(options);\r\n        }\r\n        const validProfile: boolean = (!!profileContent);\r\n        if (options.quiet) {\r\n            this._quiet = options.quiet;\r\n        }\r\n        if (options.verbose) {\r\n            this._verbose = options.verbose;\r\n        }\r\n        if (validProfile) {\r\n            this.initializeFromConfig(profileContent);\r\n            // if languages are given as parameters, they ovveride everything said in profile\r\n            if (!!options.languages && options.languages.length > 0) {\r\n                this._languages = options.languages;\r\n                if (!this._defaultLanguage) {\r\n                    this._defaultLanguage = this._languages[0];\r\n                }\r\n            }\r\n            this.checkParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read profile.\r\n     * @param options program options\r\n     * @return the read profile (empty, if none, null if errors)\r\n     */\r\n    private readProfile(options: ProgramOptions): IConfigFile {\r\n        const profilePath: string = options.profilePath;\r\n        if (!profilePath) {\r\n            for (const configfilename of PROFILE_CANDIDATES) {\r\n                const profile = XliffMergeParameters.readProfileCandidate(configfilename);\r\n                if (profile) {\r\n                    this.usedProfilePath = configfilename;\r\n                    return profile;\r\n                }\r\n            }\r\n            return {};\r\n        }\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'utf-8');\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('could not read profile \"' + profilePath + '\"'));\r\n            return null;\r\n        }\r\n        this.usedProfilePath = profilePath;\r\n        const profileContent: IConfigFile = JSON.parse(content);\r\n        // replace all pathes in options by absolute paths\r\n        const xliffmergeOptions = profileContent.xliffmergeOptions;\r\n        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);\r\n        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);\r\n        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);\r\n        return profileContent;\r\n    }\r\n\r\n    private adjustPathToProfilePath(profilePath: string, pathToAdjust: string | undefined): string | undefined {\r\n        if (!pathToAdjust || isAbsolute(pathToAdjust)) {\r\n            return pathToAdjust;\r\n        }\r\n        return join(dirname(profilePath), pathToAdjust).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private initializeFromConfig(profileContent: IConfigFile) {\r\n        if (!profileContent) {\r\n            return;\r\n        }\r\n        const profile = profileContent.xliffmergeOptions;\r\n        if (profile) {\r\n            if (!isNullOrUndefined(profile.quiet)) {\r\n                this._quiet = profile.quiet;\r\n            }\r\n            if (!isNullOrUndefined(profile.verbose)) {\r\n                this._verbose = profile.verbose;\r\n            }\r\n            if (!isNullOrUndefined(profile.allowIdChange)) {\r\n                this._allowIdChange = profile.allowIdChange;\r\n            }\r\n            if (profile.defaultLanguage) {\r\n                this._defaultLanguage = profile.defaultLanguage;\r\n            }\r\n            if (profile.languages) {\r\n                this._languages = profile.languages;\r\n            }\r\n            if (profile.srcDir) {\r\n                this._srcDir = profile.srcDir;\r\n            }\r\n            if (profile.angularCompilerOptions) {\r\n                if (profile.angularCompilerOptions.genDir) {\r\n                    this._genDir = profile.angularCompilerOptions.genDir;\r\n                }\r\n            }\r\n            if (profile.genDir) {\r\n                // this must be after angularCompilerOptions to be preferred\r\n                this._genDir = profile.genDir;\r\n            }\r\n            if (profile.i18nBaseFile) {\r\n                this._i18nBaseFile = profile.i18nBaseFile;\r\n            }\r\n            if (profile.i18nFile) {\r\n                this._i18nFile = profile.i18nFile;\r\n            }\r\n            if (profile.i18nFormat) {\r\n                this._i18nFormat = profile.i18nFormat;\r\n            }\r\n            if (profile.encoding) {\r\n                this._encoding = profile.encoding;\r\n            }\r\n            if (!isNullOrUndefined(profile.removeUnusedIds)) {\r\n                this._removeUnusedIds = profile.removeUnusedIds;\r\n            }\r\n            if (!isNullOrUndefined(profile.supportNgxTranslate)) {\r\n                this._supportNgxTranslate = profile.supportNgxTranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {\r\n                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;\r\n            }\r\n            if (!isNullOrUndefined(profile.useSourceAsTarget)) {\r\n                this._useSourceAsTarget = profile.useSourceAsTarget;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetPraefix)) {\r\n                this._targetPraefix = profile.targetPraefix;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetSuffix)) {\r\n                this._targetSuffix = profile.targetSuffix;\r\n            }\r\n            if (!isNullOrUndefined(profile.autotranslate)) {\r\n                this._autotranslate = profile.autotranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.beautifyOutput)) {\r\n                this._beautifyOutput = profile.beautifyOutput;\r\n            }\r\n            if (!isNullOrUndefined(profile.preserveOrder)) {\r\n                this._preserveOrder = profile.preserveOrder;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikey)) {\r\n                this._apikey = profile.apikey;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikeyfile)) {\r\n                this._apikeyfile = profile.apikeyfile;\r\n            }\r\n        } else {\r\n            this.warningsFound.push('did not find \"xliffmergeOptions\" in profile, using defaults');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check all Parameters, wether they are complete and consistent.\r\n     * if something is wrong with the parameters, it is collected in errorsFound.\r\n     */\r\n    private checkParameters(): void {\r\n        this.checkLanguageSyntax(this.defaultLanguage());\r\n        if (this.languages().length === 0) {\r\n            this.errorsFound.push(new XliffMergeError('no languages specified'));\r\n        }\r\n        this.languages().forEach((lang) => {\r\n            this.checkLanguageSyntax(lang);\r\n        });\r\n        let stats: Stats;\r\n        let err: any;\r\n        // srcDir should exists\r\n        try {\r\n            stats = fs.statSync(this.srcDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('srcDir \"' + this.srcDir() + '\" is not a directory'));\r\n        }\r\n        // genDir should exists\r\n        try {\r\n            stats = fs.statSync(this.genDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('genDir \"' + this.genDir() + '\" is not a directory'));\r\n        }\r\n        // master file MUST exist\r\n        try {\r\n            fs.accessSync(this.i18nFile(), fs.constants.R_OK);\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFile \"' + this.i18nFile() + '\" is not readable'));\r\n        }\r\n        // i18nFormat must be xlf xlf2 or xmb\r\n        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFormat \"' + this.i18nFormat() + '\" invalid, must be \"xlf\" or \"xlf2\" or \"xmb\"'));\r\n        }\r\n        // autotranslate requires api key\r\n        if (this.autotranslate() && !this.apikey()) {\r\n            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));\r\n        }\r\n        // autotranslated languages must be in list of all languages\r\n        this.autotranslatedLanguages().forEach((lang) => {\r\n            if (this.languages().indexOf(lang) < 0) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" is not in list of languages'));\r\n            }\r\n            if (lang === this.defaultLanguage()) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('autotranslate language \"' + lang + '\" cannot be translated, because it is the source language'));\r\n            }\r\n        });\r\n        // ngx translate pattern check\r\n        if (this.supportNgxTranslate()) {\r\n            const checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());\r\n            if (!isNullOrUndefined(checkResult)) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('ngxTranslateExtractionPattern \"' + this.ngxTranslateExtractionPattern() + '\": ' + checkResult));\r\n            }\r\n        }\r\n        // targetPraefix and targetSuffix check\r\n        if (!this.useSourceAsTarget()) {\r\n            if (this.targetPraefix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetPraefix \"' + this.targetPraefix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n            if (this.targetSuffix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetSuffix \"' + this.targetSuffix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n        }\r\n     }\r\n\r\n    /**\r\n     * Check syntax of language.\r\n     * Must be compatible with XML Schema type xsd:language.\r\n     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*\r\n     * @param lang language to check\r\n     */\r\n    private checkLanguageSyntax(lang: string) {\r\n        const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;\r\n        if (!pattern.test(lang)) {\r\n            this.errorsFound.push(new XliffMergeError('language \"' + lang + '\" is not valid'));\r\n        }\r\n    }\r\n\r\n    public allowIdChange(): boolean {\r\n        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;\r\n    }\r\n\r\n    public verbose(): boolean {\r\n        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;\r\n    }\r\n\r\n    public quiet(): boolean {\r\n        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;\r\n    }\r\n\r\n    /**\r\n     * Debug output all parameters to commandOutput.\r\n     */\r\n    public showAllParameters(commandOutput: CommandOutput): void {\r\n        commandOutput.debug('xliffmerge Used Parameters:');\r\n        commandOutput.debug('usedProfilePath:\\t\"%s\"', this.usedProfilePath);\r\n        commandOutput.debug('defaultLanguage:\\t\"%s\"', this.defaultLanguage());\r\n        commandOutput.debug('srcDir:\\t\"%s\"', this.srcDir());\r\n        commandOutput.debug('genDir:\\t\"%s\"', this.genDir());\r\n        commandOutput.debug('i18nBaseFile:\\t\"%s\"', this.i18nBaseFile());\r\n        commandOutput.debug('i18nFile:\\t\"%s\"', this.i18nFile());\r\n        commandOutput.debug('languages:\\t%s', this.languages());\r\n        for (const language of this.languages()) {\r\n            commandOutput.debug('outputFile[%s]:\\t%s', language, this.generatedI18nFile(language));\r\n        }\r\n        commandOutput.debug('removeUnusedIds:\\t%s', this.removeUnusedIds());\r\n        commandOutput.debug('supportNgxTranslate:\\t%s', this.supportNgxTranslate());\r\n        if (this.supportNgxTranslate()) {\r\n            commandOutput.debug('ngxTranslateExtractionPattern:\\t%s', this.ngxTranslateExtractionPattern());\r\n        }\r\n        commandOutput.debug('useSourceAsTarget:\\t%s', this.useSourceAsTarget());\r\n        if (this.useSourceAsTarget()) {\r\n            commandOutput.debug('targetPraefix:\\t\"%s\"', this.targetPraefix());\r\n            commandOutput.debug('targetSuffix:\\t\"%s\"', this.targetSuffix());\r\n        }\r\n        commandOutput.debug('allowIdChange:\\t%s', this.allowIdChange());\r\n        commandOutput.debug('beautifyOutput:\\t%s', this.beautifyOutput());\r\n        commandOutput.debug('preserveOrder:\\t%s', this.preserveOrder());\r\n        commandOutput.debug('autotranslate:\\t%s', this.autotranslate());\r\n        if (this.autotranslate()) {\r\n            commandOutput.debug('autotranslated languages:\\t%s', this.autotranslatedLanguages());\r\n            commandOutput.debug('apikey:\\t%s', this.apikey() ? '****' : 'NOT SET');\r\n            commandOutput.debug('apikeyfile:\\t%s', this.apikeyfile());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Default-Language, default en.\r\n     * @return default language\r\n     */\r\n    public defaultLanguage(): string {\r\n        return this._defaultLanguage ? this._defaultLanguage : 'en';\r\n    }\r\n\r\n    /**\r\n     * Liste der zu bearbeitenden Sprachen.\r\n     * @return languages\r\n     */\r\n    public languages(): string[] {\r\n        return this._languages ? this._languages : [];\r\n    }\r\n\r\n    /**\r\n     * src directory, where the master xlif is located.\r\n     * @return srcDir\r\n     */\r\n    public srcDir(): string {\r\n        return this._srcDir ? this._srcDir : '.';\r\n    }\r\n\r\n    /**\r\n     * The base file name of the xlif file for input and output.\r\n     * Default is messages\r\n     * @return base file\r\n     */\r\n    public i18nBaseFile(): string {\r\n        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';\r\n    }\r\n\r\n    /**\r\n     * The master xlif file (the one generated by ng-xi18n).\r\n     * Default is <srcDir>/<i18nBaseFile>.xlf.\r\n     * @return master file\r\n     */\r\n    public i18nFile(): string {\r\n        return join(this.srcDir(),\r\n            (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())\r\n        ).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * Format of the master xlif file.\r\n     * Default is \"xlf\", possible are \"xlf\" or \"xlf2\" or \"xmb\".\r\n     * @return format\r\n     */\r\n    public i18nFormat(): string {\r\n        return (this._i18nFormat ? this._i18nFormat : 'xlf');\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated I18n-File with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private suffixForGeneratedI18nFile(): string {\r\n        switch (this.i18nFormat()) {\r\n            case 'xlf':\r\n                return 'xlf';\r\n            case 'xlf2':\r\n                return 'xlf';\r\n            case 'xmb':\r\n                return 'xtb';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated translate-File for ngx-translate with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * The encoding used to write new XLIFF-files.\r\n     * @return encoding\r\n     */\r\n    public encoding(): BufferEncoding {\r\n        return this._encoding ? this._encoding : 'utf-8';\r\n    }\r\n\r\n     /**\r\n      * Output-Directory, where the output is written to.\r\n      * Default is <srcDir>.\r\n     */\r\n    public genDir(): string {\r\n        return this._genDir ? this._genDir : this.srcDir();\r\n    }\r\n\r\n    public removeUnusedIds(): boolean {\r\n        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;\r\n    }\r\n\r\n    public supportNgxTranslate(): boolean {\r\n        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;\r\n    }\r\n\r\n    public ngxTranslateExtractionPattern(): string {\r\n        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?\r\n            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;\r\n    }\r\n\r\n    /**\r\n     * Whether source must be used as target for new trans-units\r\n     * Default is true\r\n     */\r\n    public useSourceAsTarget(): boolean {\r\n        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;\r\n    }\r\n\r\n    /**\r\n     * Praefix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetPraefix(): string {\r\n        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Suffix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetSuffix(): string {\r\n        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * If set, run xml result through beautifier (pretty-data).\r\n     */\r\n    public beautifyOutput(): boolean {\r\n        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;\r\n    }\r\n\r\n    /**\r\n     * If set, order of new trans units will be as in master.\r\n     * Otherwise they are added at the end.\r\n     */\r\n    public preserveOrder(): boolean {\r\n        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for new trans-units\r\n     * Default is false\r\n     */\r\n    public autotranslate(): boolean {\r\n        if (isNullOrUndefined(this._autotranslate)) {\r\n            return false;\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate).length > 0;\r\n        }\r\n        return <boolean> this._autotranslate;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for a given language.\r\n     * @param lang language code.\r\n     */\r\n    public autotranslateLanguage(lang: string): boolean {\r\n        return this.autotranslatedLanguages().indexOf(lang) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Return a list of languages to be autotranslated.\r\n     */\r\n    public autotranslatedLanguages(): string[] {\r\n        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {\r\n            return [];\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate);\r\n        }\r\n        return this.languages().slice(1); // first is source language\r\n    }\r\n\r\n    /**\r\n     * API key to be used for Google Translate\r\n     * @return api key\r\n     */\r\n    public apikey(): string {\r\n        if (!isNullOrUndefined(this._apikey)) {\r\n            return this._apikey;\r\n        } else {\r\n            const apikeyPath = this.apikeyfile();\r\n            if (this.apikeyfile()) {\r\n                if (fs.existsSync(apikeyPath)) {\r\n                    return FileUtil.read(apikeyPath, 'utf-8');\r\n                } else {\r\n                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * file name for API key to be used for Google Translate.\r\n     * Explicitly set or read from env var API_KEY_FILE.\r\n     * @return file of api key\r\n     */\r\n    public apikeyfile(): string {\r\n        if (this._apikeyfile) {\r\n            return this._apikeyfile;\r\n        } else if (process.env.API_KEY_FILE) {\r\n            return process.env.API_KEY_FILE;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 19.02.2017.\r\n */\r\nimport * as path from 'path';\r\n\r\nlet pkg = null;\r\ntry {\r\n    pkg = require(path.resolve(__dirname, '..', 'package.json'));\r\n} catch (e) {\r\n    try {\r\n        pkg = require(path.resolve(__dirname, '..', '..', 'package.json'));\r\n    } catch (e) {\r\n        pkg = null;\r\n    }\r\n}\r\n\r\nexport const VERSION = (pkg ? pkg.version : 'unknown');\r\n","import {FileUtil} from '../common/file-util';\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * Helper class to read XMl with a correct encoding.\r\n */\r\n\r\nexport class XmlReader {\r\n    static DEFAULT_ENCODING = 'utf-8' as BufferEncoding;\r\n\r\n    /**\r\n     * Read an xml-File.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return file content and encoding found in the file.\r\n     */\r\n    public static readXmlFileContent(path: string, encoding?: BufferEncoding): {content: string, encoding: BufferEncoding } {\r\n        if (!encoding) {\r\n            encoding = XmlReader.DEFAULT_ENCODING as BufferEncoding;\r\n        }\r\n        let content: string = FileUtil.read(path, encoding);\r\n        const foundEncoding = XmlReader.encodingFromXml(content) as BufferEncoding;\r\n        if (foundEncoding !== encoding) {\r\n            // read again with the correct encoding\r\n            content = FileUtil.read(path, foundEncoding);\r\n        }\r\n        return {\r\n            content: content,\r\n            encoding: foundEncoding\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Read the encoding from the xml.\r\n     * xml File starts with .. encoding=\"..\"\r\n     * @param xmlString xmlString\r\n     * @return encoding\r\n     */\r\n    private static encodingFromXml(xmlString: string): string {\r\n        const index = xmlString.indexOf('encoding=\"');\r\n        if (index < 0) {\r\n            return this.DEFAULT_ENCODING; // default in xml if not explicitly set\r\n        }\r\n        const endIndex = xmlString.indexOf('\"', index + 10); // 10 = length of 'encoding=\"'\r\n        return xmlString.substring(index + 10, endIndex);\r\n    }\r\n\r\n}\r\n\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile, TranslationMessagesFileFactory} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {XmlReader} from './xml-reader';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n */\r\nexport class TranslationMessagesFileReader {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat format\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromFile(i18nFormat: string,\r\n                           path: string,\r\n                           encoding: BufferEncoding,\r\n                           optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromUnknownFormatFile(path: string,\r\n                                        encoding: BufferEncoding,\r\n                                        optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read master xmb file\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @param encoding encoding\r\n     * @return content and encoding of file\r\n     */\r\n    private static masterFileContent(optionalMasterFilePath: string, encoding: BufferEncoding)\r\n        : { xmlContent: string, path: string, encoding: BufferEncoding } {\r\n        if (optionalMasterFilePath) {\r\n            const masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);\r\n            return {\r\n                xmlContent: masterXmlContent.content,\r\n                path: optionalMasterFilePath,\r\n                encoding: masterXmlContent.encoding\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save edited file.\r\n     * @param messagesFile messagesFile\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public static save(messagesFile: ITranslationMessagesFile, beautifyOutput?: boolean) {\r\n        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding() as BufferEncoding);\r\n    }\r\n}\r\n\r\n","import {format} from 'util';\r\nimport * as request from 'request';\r\nimport {Observable} from 'rxjs';\r\nimport {of, forkJoin, throwError} from 'rxjs';\r\nimport {map} from 'rxjs/operators';\r\n\r\n/**\r\n * Created by roobm on 03.07.2017.\r\n * Low Level Service to call Google Translate.\r\n */\r\n\r\n/**\r\n * Types form google translate api.\r\n */\r\n\r\ninterface GetSupportedLanguagesRequest {\r\n    target: string; // The language to use to return localized, human readable names of supported\\nlanguages.\r\n}\r\n\r\ninterface LanguagesResource {\r\n    language: string; // code of the language\r\n    name: string; // human readable name (in target language)\r\n}\r\n\r\ninterface LanguagesListResponse {\r\n    languages: LanguagesResource[];\r\n}\r\n\r\ninterface TranslateTextRequest {\r\n    q: string[];  // The input texts to translate\r\n    target: string; // The language to use for translation of the input text\r\n    source: string; // The language of the source text\r\n    format?: string; // \"html\" (default) or \"text\"\r\n    model?: string; // see public documentation\r\n}\r\n\r\ninterface TranslationsResource {\r\n    detectedSourceLanguage?: string;\r\n    model?: string;\r\n    translatedText: string;\r\n}\r\n\r\ninterface TranslationsListResponse {\r\n    translations: TranslationsResource[];\r\n}\r\n\r\ninterface InternalRequestResponse {\r\n    response: request.RequestResponse;\r\n    body: any;\r\n}\r\n\r\nconst MAX_SEGMENTS = 128;\r\n\r\nexport class AutoTranslateService {\r\n\r\n    private _request: request.RequestAPI<request.Request, request.CoreOptions, request.RequiredUriUrl>;\r\n    _rootUrl: string;\r\n    _apiKey: string;\r\n\r\n    /**\r\n     * Strip region code and convert to lower\r\n     * @param lang lang\r\n     * @return lang without region code and in lower case.\r\n     */\r\n    public static stripRegioncode(lang: string): string {\r\n        const langLower = lang.toLowerCase();\r\n        for (let i = 0; i < langLower.length; i++) {\r\n            const c = langLower.charAt(i);\r\n            if (c < 'a' || c > 'z') {\r\n                return langLower.substring(0, i);\r\n            }\r\n        }\r\n        return langLower;\r\n    }\r\n\r\n    constructor(apiKey: string) {\r\n        this._request = request;\r\n        this._apiKey = apiKey;\r\n        this._rootUrl = 'https://translation.googleapis.com/';\r\n    }\r\n\r\n    /**\r\n     * Change API key (just for tests).\r\n     * @param apikey apikey\r\n     */\r\n    public setApiKey(apikey: string) {\r\n        this._apiKey = apikey;\r\n    }\r\n\r\n    /**\r\n     * Translate an array of messages at once.\r\n     * @param messages the messages to be translated\r\n     * @param from source language code\r\n     * @param to target language code\r\n     * @return Observable with translated messages or error\r\n     */\r\n    public translateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        // empty array needs no translation and always works ... (#78)\r\n        if (messages.length === 0) {\r\n            return of([]);\r\n        }\r\n        if (!this._apiKey) {\r\n            return throwError('cannot autotranslate: no api key');\r\n        }\r\n        if (!from || !to) {\r\n            return throwError('cannot autotranslate: source and target language must be set');\r\n        }\r\n        from = AutoTranslateService.stripRegioncode(from);\r\n        to = AutoTranslateService.stripRegioncode(to);\r\n        const allRequests: Observable<string[]>[] = this.splitMessagesToGoogleLimit(messages).map((partialMessages: string[]) => {\r\n            return this.limitedTranslateMultipleStrings(partialMessages, from, to);\r\n        });\r\n        return forkJoin(allRequests).pipe(\r\n            map((allTranslations: string[][]) => {\r\n                let all = [];\r\n                for (let i = 0; i < allTranslations.length; i++) {\r\n                    all = all.concat(allTranslations[i]);\r\n                }\r\n                return all;\r\n        }));\r\n    }\r\n\r\n    private splitMessagesToGoogleLimit(messages: string[]): string[][] {\r\n        if (messages.length <= MAX_SEGMENTS) {\r\n            return [messages];\r\n        }\r\n        const result = [];\r\n        let currentPackage = [];\r\n        let packageSize = 0;\r\n        for (let i = 0; i < messages.length; i++) {\r\n            currentPackage.push(messages[i]);\r\n            packageSize++;\r\n            if (packageSize >= MAX_SEGMENTS) {\r\n                result.push(currentPackage);\r\n                currentPackage = [];\r\n                packageSize = 0;\r\n            }\r\n        }\r\n        if (currentPackage.length > 0) {\r\n            result.push(currentPackage);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return translation request, but messages must be limited to google limits.\r\n     * Not more that 128 single messages.\r\n     * @param messages messages\r\n     * @param from from\r\n     * @param to to\r\n     * @return the translated strings\r\n     */\r\n    private limitedTranslateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        const realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;\r\n        const translateRequest: TranslateTextRequest = {\r\n            q: messages,\r\n            target: to,\r\n            source: from,\r\n        };\r\n        const options = {\r\n            url: realUrl,\r\n            body: translateRequest,\r\n            json: true,\r\n//            proxy: 'http://127.0.0.1:8888' To set a proxy use env var HTTPS_PROXY\r\n        };\r\n        return this.post(realUrl, options).pipe(\r\n            map((data) => {\r\n            const body: any = data.body;\r\n            if (!body) {\r\n                throw new Error('no result received');\r\n            }\r\n            if (body.error) {\r\n                if (body.error.code === 400) {\r\n                    if (body.error.message === 'Invalid Value') {\r\n                        throw new Error(format('Translation from \"%s\" to \"%s\" not supported', from, to));\r\n                    }\r\n                    throw new Error(format('Invalid request: %s', body.error.message));\r\n                } else {\r\n                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));\r\n                }\r\n            }\r\n            const result = body.data;\r\n            return result.translations.map((translation: TranslationsResource) => {\r\n                return translation.translatedText;\r\n            });\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Function to do a POST HTTP request\r\n     *\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     */\r\n    post(uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> this._call.apply(this, [].concat('post', <string> uri,\r\n            <request.CoreOptions> Object.assign({}, options || {})));\r\n    }\r\n\r\n    /**\r\n     * Function to do a HTTP request for given method\r\n     *\r\n     * @param method method\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     *\r\n     */\r\n    private _call(method: string, uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> Observable.create((observer) => {\r\n            // build params array\r\n            const params = [].concat(<string> uri, <request.CoreOptions> Object.assign({}, options || {}),\r\n                <RequestCallback>(error: any, response: request.RequestResponse, body: any) => {\r\n                    if (error) {\r\n                        return observer.error(error);\r\n                    }\r\n\r\n                    observer.next(<InternalRequestResponse> Object.assign({}, {\r\n                        response: <request.RequestResponse> response,\r\n                        body: <any> body\r\n                    }));\r\n                    observer.complete();\r\n                });\r\n\r\n            // _call request method\r\n            try {\r\n                this._request[<string> method].apply(\r\n                    <request.RequestAPI<request.Request,\r\n                    request.CoreOptions,\r\n                    request.RequiredUriUrl>> this._request,\r\n                    params);\r\n            } catch (error) {\r\n                observer.error(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateResult {\r\n\r\n  constructor(private _success: boolean, private _details: string) {\r\n\r\n  }\r\n\r\n  public success(): boolean {\r\n    return this._success;\r\n  }\r\n}\r\n","import {AutoTranslateResult} from './auto-translate-result';\r\nimport {format} from 'util';\r\nimport {ITransUnit} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\n\r\n/**\r\n * A report about a run of Google Translate over all untranslated unit.\r\n * * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateSummaryReport {\r\n\r\n  private _error: string;\r\n  private _from: string;\r\n  private _to: string;\r\n  private _total: number;\r\n  private _ignored: number;\r\n  private _success: number;\r\n  private _failed: number;\r\n\r\n  constructor(from: string, to: string) {\r\n    this._from = from;\r\n    this._to = to;\r\n    this._total = 0;\r\n    this._ignored = 0;\r\n    this._success = 0;\r\n    this._failed = 0;\r\n  }\r\n\r\n  /**\r\n   * Set error if total call failed (e.g. \"invalid api key\" or \"no connection\" ...)\r\n   * @param error error\r\n   * @param total total\r\n   */\r\n  public setError(error: string, total: number) {\r\n    this._error = error;\r\n    this._total = total;\r\n    this._failed = total;\r\n  }\r\n\r\n  public error(): string {\r\n    return this._error;\r\n  }\r\n\r\n  public setIgnored(ignored: number) {\r\n    this._total += ignored;\r\n    this._ignored = ignored;\r\n  }\r\n\r\n  /**\r\n   * Add a single result to the summary.\r\n   * @param tu tu\r\n   * @param result result\r\n   */\r\n  public addSingleResult(tu: ITransUnit, result: AutoTranslateResult) {\r\n    this._total++;\r\n    if (result.success()) {\r\n      this._success++;\r\n    } else {\r\n      this._failed++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge another summary into this one.\r\n   * @param anotherSummary anotherSummary\r\n   */\r\n  public merge(anotherSummary: AutoTranslateSummaryReport) {\r\n    if (!this._error) {\r\n      this._error = anotherSummary._error;\r\n    }\r\n    this._total += anotherSummary.total();\r\n    this._ignored += anotherSummary.ignored();\r\n    this._success += anotherSummary.success();\r\n    this._failed += anotherSummary.failed();\r\n  }\r\n\r\n  public total(): number {\r\n    return this._total;\r\n  }\r\n\r\n  public ignored(): number {\r\n    return this._ignored;\r\n  }\r\n\r\n  public success(): number {\r\n    return this._success;\r\n  }\r\n\r\n  public failed(): number {\r\n    return this._failed;\r\n  }\r\n\r\n  /**\r\n   * Human readable version of report\r\n   */\r\n  public content(): string {\r\n    let result;\r\n    if (this._error) {\r\n      result = format('Auto translation from \"%s\" to \"%s\" failed: \"%s\", failed units: %s', this._from, this._to, this._error, this._failed);\r\n    } else {\r\n      result = format('Auto translation from \"%s\" to \"%s\", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s',\r\n          this._from, this._to, this._total, this._ignored, this._success, this._failed);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import {isNullOrUndefined} from '../common/util';\r\nimport {Observable, forkJoin, of} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport * as entityDecoderLib from 'he';\r\nimport {\r\n    IICUMessage, IICUMessageTranslation, INormalizedMessage, ITranslationMessagesFile, ITransUnit,\r\n    STATE_NEW\r\n} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {AutoTranslateService} from './auto-translate-service';\r\nimport {AutoTranslateResult} from './auto-translate-result';\r\nimport {AutoTranslateSummaryReport} from './auto-translate-summary-report';\r\n/**\r\n * Created by martin on 07.07.2017.\r\n * Service to autotranslate Transunits via Google Translate.\r\n */\r\n\r\nexport class XliffMergeAutoTranslateService {\r\n\r\n    private autoTranslateService: AutoTranslateService;\r\n\r\n    constructor(apikey: string) {\r\n        this.autoTranslateService = new AutoTranslateService(apikey);\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    public autoTranslate(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        return forkJoin([\r\n            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile),\r\n            ...this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)])\r\n            .pipe(\r\n                map((summaries: AutoTranslateSummaryReport[]) => {\r\n                    const summary = summaries[0];\r\n                    for (let i = 1; i < summaries.length; i++) {\r\n                        summary.merge(summaries[i]);\r\n                    }\r\n                    return summary;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Collect all units that are untranslated.\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return all untranslated units\r\n     */\r\n    private allUntranslatedTUs(languageSpecificMessagesFile: ITranslationMessagesFile): ITransUnit[] {\r\n        // collect all units, that should be auto translated\r\n        const allUntranslated: ITransUnit[] = [];\r\n        languageSpecificMessagesFile.forEachTransUnit((tu) => {\r\n            if (tu.targetState() === STATE_NEW) {\r\n                allUntranslated.push(tu);\r\n            }\r\n        });\r\n        return allUntranslated;\r\n    }\r\n\r\n    private doAutoTranslateNonICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatable = allUntranslated.filter((tu) => isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        const allMessages: string[] = allTranslatable.map((tu) => {\r\n            return tu.sourceContentNormalized().asDisplayString();\r\n        });\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                const summary = new AutoTranslateSummaryReport(from, to);\r\n                summary.setIgnored(allUntranslated.length - allTranslatable.length);\r\n                for (let i = 0; i < translations.length; i++) {\r\n                    const tu = allTranslatable[i];\r\n                    const translationText = translations[i];\r\n                    const result = this.autoTranslateNonICUUnit(tu, translationText);\r\n                    summary.addSingleResult(tu, result);\r\n                }\r\n                return summary;\r\n                }),\r\n                catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private doAutoTranslateICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport>[] {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatableICU = allUntranslated.filter((tu) => !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        return allTranslatableICU.map((tu) => {\r\n            return this.doAutoTranslateICUMessage(from, to, tu);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Translate single ICU Messages.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tu transunit to translate (must contain ICU Message)\r\n     * @return summary report\r\n     */\r\n    private doAutoTranslateICUMessage(from: string, to: string, tu: ITransUnit): Observable<AutoTranslateSummaryReport> {\r\n        const icuMessage: IICUMessage = tu.sourceContentNormalized().getICUMessage();\r\n        const categories = icuMessage.getCategories();\r\n        // check for nested ICUs, we do not support that\r\n        if (categories.find((category) => !isNullOrUndefined(category.getMessageNormalized().getICUMessage()))) {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(1);\r\n            return of(summary);\r\n        }\r\n        const allMessages: string[] = categories.map((category) => category.getMessageNormalized().asDisplayString());\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                    const summary = new AutoTranslateSummaryReport(from, to);\r\n                    const icuTranslation: IICUMessageTranslation = {};\r\n                    for (let i = 0; i < translations.length; i++) {\r\n                        icuTranslation[categories[i].getCategory()] = translations[i];\r\n                    }\r\n                    const result = this.autoTranslateICUUnit(tu, icuTranslation);\r\n                    summary.addSingleResult(tu, result);\r\n                    return summary;\r\n                }), catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private autoTranslateNonICUUnit(tu: ITransUnit, translatedMessage: string): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));\r\n    }\r\n\r\n    private autoTranslateICUUnit(tu: ITransUnit, translation: IICUMessageTranslation): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));\r\n    }\r\n\r\n    private autoTranslateUnit(tu: ITransUnit, translatedMessage: INormalizedMessage): AutoTranslateResult {\r\n        const errors = translatedMessage.validate();\r\n        const warnings = translatedMessage.validateWarnings();\r\n        if (!isNullOrUndefined(errors)) {\r\n            return new AutoTranslateResult(false, 'errors detected, not translated');\r\n        } else if (!isNullOrUndefined(warnings)) {\r\n            return new AutoTranslateResult(false, 'warnings detected, not translated');\r\n        } else {\r\n            tu.translate(translatedMessage);\r\n            return new AutoTranslateResult(true, null); // success\r\n        }\r\n    }\r\n}\r\n","import {CommandOutput} from '../common/command-output';\r\nimport {XliffMergeParameters} from './xliff-merge-parameters';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {VERSION} from './version';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {ITranslationMessagesFile, ITransUnit,\r\n    FORMAT_XMB, FORMAT_XTB,\r\n    NORMALIZATION_FORMAT_DEFAULT, STATE_FINAL, STATE_TRANSLATED} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {TranslationMessagesFileReader} from './translation-messages-file-reader';\r\nimport {Observable, of, forkJoin} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport {XliffMergeAutoTranslateService} from '../autotranslate/xliff-merge-auto-translate-service';\r\nimport {AutoTranslateSummaryReport} from '../autotranslate/auto-translate-summary-report';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.\r\n *\r\n */\r\n\r\nexport class XliffMerge {\r\n\r\n    private readonly commandOutput: CommandOutput;\r\n\r\n    private readonly options: ProgramOptions;\r\n\r\n    private parameters: XliffMergeParameters;\r\n\r\n    /**\r\n     * The read master xlf file.\r\n     */\r\n    private master: ITranslationMessagesFile; // XliffFile or Xliff2File or XmbFile\r\n\r\n    private autoTranslateService: XliffMergeAutoTranslateService;\r\n\r\n    static main(argv: string[]) {\r\n        const options = XliffMerge.parseArgs(argv);\r\n        if (options) {\r\n            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {\r\n                process.exit(result);\r\n            });\r\n        }\r\n    }\r\n\r\n    static parseArgs(argv: string[]): ProgramOptions {\r\n        const options: ProgramOptions = {\r\n            languages: []\r\n        };\r\n        for (let i = 1; i < argv.length; i++) {\r\n            const arg = argv[i];\r\n            if (arg === '--version' || arg === '-version') {\r\n                console.log('xliffmerge ' + VERSION);\r\n            } else if (arg === '--verbose' || arg === '-v') {\r\n                options.verbose = true;\r\n            } else if (arg === '--profile' || arg === '-p') {\r\n                i++;\r\n                if (i >= argv.length) {\r\n                    console.log('missing config file');\r\n                    XliffMerge.showUsage();\r\n                    return null;\r\n                } else {\r\n                    options.profilePath = argv[i];\r\n                }\r\n            } else if (arg === '--quiet' || arg === '-q') {\r\n                options.quiet = true;\r\n            } else if (arg === '--help' || arg === '-help' || arg === '-h') {\r\n                XliffMerge.showUsage();\r\n            } else if (arg.length > 0 && arg.charAt(0) === '-') {\r\n                console.log('unknown option');\r\n                return null;\r\n            } else {\r\n                options.languages.push(arg);\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n\r\n    static showUsage() {\r\n        console.log('usage: xliffmerge <option>* <language>*');\r\n        console.log('Options');\r\n        console.log('\\t-p|--profile a json configuration file containing all relevant parameters.');\r\n        console.log('\\t\\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');\r\n        console.log('\\t-v|--verbose show some output for debugging purposes');\r\n        console.log('\\t-q|--quiet only show errors, nothing else');\r\n        console.log('\\t-version|--version show version string');\r\n        console.log('');\r\n        console.log('\\t<language> has to be a valid language short string, e,g. \"en\", \"de\", \"de-ch\"');\r\n    }\r\n\r\n    /**\r\n     * For Tests, create instance with given profile\r\n     * @param commandOutput commandOutput\r\n     * @param options options\r\n     * @param profileContent profileContent\r\n     */\r\n    public static createFromOptions(commandOutput: CommandOutput, options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const instance = new XliffMerge(commandOutput, options);\r\n        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);\r\n        return instance;\r\n    }\r\n\r\n    constructor(commandOutput: CommandOutput, options: ProgramOptions) {\r\n        this.commandOutput = commandOutput;\r\n        this.options = options;\r\n        this.parameters = null;\r\n    }\r\n\r\n    /**\r\n     * Run the command.\r\n     * This runs async.\r\n     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.\r\n     * @param errorFunction callbackFunction for error handling\r\n     */\r\n    public run(callbackFunction?: ((retcode: number) => any), errorFunction?: ((error: any) => any)) {\r\n        this.runAsync()\r\n            .subscribe((retcode: number) => {\r\n                if (!isNullOrUndefined(callbackFunction)) {\r\n                    callbackFunction(retcode);\r\n                }\r\n            }, (error) => {\r\n                if (!isNullOrUndefined(errorFunction)) {\r\n                    errorFunction(error);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Execute merge-Process.\r\n     * @return Async operation, on completion returns retcode 0=ok, other = error.\r\n     */\r\n    public runAsync(): Observable<number> {\r\n        if (this.options && this.options.quiet) {\r\n            this.commandOutput.setQuiet();\r\n        }\r\n        if (this.options && this.options.verbose) {\r\n            this.commandOutput.setVerbose();\r\n        }\r\n        if (!this.parameters) {\r\n            this.parameters = XliffMergeParameters.createFromOptions(this.options);\r\n        }\r\n        this.commandOutput.info('xliffmerge version %s', VERSION);\r\n        if (this.parameters.verbose()) {\r\n            this.parameters.showAllParameters(this.commandOutput);\r\n        }\r\n        if (this.parameters.errorsFound.length > 0) {\r\n            for (const err of this.parameters.errorsFound) {\r\n                this.commandOutput.error(err.message);\r\n            }\r\n            return of(-1);\r\n        }\r\n        if (this.parameters.warningsFound.length > 0) {\r\n            for (const warn of this.parameters.warningsFound) {\r\n                this.commandOutput.warn(warn);\r\n            }\r\n        }\r\n        this.readMaster();\r\n        if (this.parameters.autotranslate()) {\r\n            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());\r\n        }\r\n        const executionForAllLanguages: Observable<number>[] = [];\r\n        this.parameters.languages().forEach((lang: string) => {\r\n            executionForAllLanguages.push(this.processLanguage(lang));\r\n        });\r\n        return forkJoin(executionForAllLanguages).pipe(\r\n            map((retcodes: number[]) => this.totalRetcode(retcodes)));\r\n    }\r\n\r\n    /**\r\n     * Give an array of retcodes for the different languages, return the total retcode.\r\n     * If all are 0, it is 0, otherwise the first non zero.\r\n     * @param retcodes retcodes\r\n     * @return number\r\n     */\r\n    private totalRetcode(retcodes: number[]): number {\r\n        for (let i = 0; i < retcodes.length; i++) {\r\n            if (retcodes[i] !== 0) {\r\n                return retcodes[i];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated file for given lang.\r\n     * @param lang language\r\n     * @return name of generated file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return this.parameters.generatedI18nFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated ngx-translation file for given lang.\r\n     * @param lang language\r\n     * @return name of translate file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return this.parameters.generatedNgxTranslateFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Warnings found during the run.\r\n     * @return warnings\r\n     */\r\n    public warnings(): string[] {\r\n        return this.parameters.warningsFound;\r\n    }\r\n\r\n    private readMaster() {\r\n        try {\r\n            this.master = TranslationMessagesFileReader.fromFile(\r\n                this.parameters.i18nFormat(),\r\n                this.parameters.i18nFile(),\r\n                this.parameters.encoding() as BufferEncoding);\r\n            this.master.warnings().forEach((warning: string) => {\r\n                this.commandOutput.warn(warning);\r\n            });\r\n            const count = this.master.numberOfTransUnits();\r\n            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();\r\n            this.commandOutput.info('master contains %s trans-units', count);\r\n            if (missingIdCount > 0) {\r\n                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);\r\n            }\r\n            const sourceLang: string = this.master.sourceLanguage();\r\n            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {\r\n                this.commandOutput.warn(\r\n                    'master says to have source-language=\"%s\", should be \"%s\" (your defaultLanguage)',\r\n                    sourceLang,\r\n                    this.parameters.defaultLanguage());\r\n                this.master.setSourceLanguage(this.parameters.defaultLanguage());\r\n                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());\r\n                this.commandOutput.warn('changed master source-language=\"%s\" to \"%s\"', sourceLang, this.parameters.defaultLanguage());\r\n            }\r\n        } catch (err) {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            } else {\r\n                // unhandled\r\n                const currentFilename = this.parameters.i18nFile();\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the given language.\r\n     * Async operation.\r\n     * @param lang language\r\n     * @return on completion 0 for ok, other for error\r\n     */\r\n    private processLanguage(lang: string): Observable<number> {\r\n        this.commandOutput.debug('processing language %s', lang);\r\n        const languageXliffFile = this.parameters.generatedI18nFile(lang);\r\n        const currentFilename = languageXliffFile;\r\n        let result: Observable<void>;\r\n        if (!FileUtil.exists(languageXliffFile)) {\r\n            result = this.createUntranslatedXliff(lang, languageXliffFile);\r\n        } else {\r\n            result = this.mergeMasterTo(lang, languageXliffFile);\r\n        }\r\n        return result\r\n            .pipe(map(() => {\r\n                if (this.parameters.supportNgxTranslate()) {\r\n                    const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n                        TranslationMessagesFileReader.fromFile(\r\n                            this.translationFormat(this.parameters.i18nFormat()),\r\n                            languageXliffFile,\r\n                            this.parameters.encoding(),\r\n                            this.master.filename());\r\n                    NgxTranslateExtractor.extract(\r\n                        languageSpecificMessagesFile,\r\n                        this.parameters.ngxTranslateExtractionPattern(),\r\n                        this.parameters.generatedNgxTranslateFile(lang));\r\n                }\r\n                return 0;\r\n            }), catchError((err) => {\r\n                if (err instanceof XliffMergeError) {\r\n                    this.commandOutput.error(err.message);\r\n                    return of(-1);\r\n                } else {\r\n                    // unhandled\r\n                    const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                    this.commandOutput.error(filenameString + 'oops ' + err);\r\n                    throw err;\r\n                }\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * create a new file for the language, which contains no translations, but all keys.\r\n     * in principle, this is just a copy of the master with target-language set.\r\n     * @param lang language\r\n     * @param languageXliffFilePath name of file\r\n     */\r\n    private createUntranslatedXliff(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // copy master ...\r\n        // and set target-language\r\n        // and copy source to target if necessary\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());\r\n        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(\r\n            map((/* summary */) => {\r\n            // write it to file\r\n            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n            this.commandOutput.info('created new file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n            if (!isDefaultLang) {\r\n                this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Map the input format to the format of the translation.\r\n     * Normally they are the same but for xmb the translation format is xtb.\r\n     * @param i18nFormat format\r\n     */\r\n    private translationFormat(i18nFormat: string): string {\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return FORMAT_XTB;\r\n        } else {\r\n            return i18nFormat;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all\r\n     * @param lang language\r\n     * @param languageXliffFilePath filename\r\n     */\r\n    private mergeMasterTo(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // read lang specific file\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            TranslationMessagesFileReader.fromFile(\r\n                this.translationFormat(this.parameters.i18nFormat()),\r\n                languageXliffFilePath,\r\n                this.parameters.encoding());\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        let newCount = 0;\r\n        let correctSourceContentCount = 0;\r\n        let correctSourceRefCount = 0;\r\n        let correctDescriptionOrMeaningCount = 0;\r\n        let idChangedCount = 0;\r\n        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        let lastProcessedUnit: ITransUnit = null;\r\n        this.master.forEachTransUnit((masterTransUnit) => {\r\n            const transUnit: ITransUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);\r\n\r\n            if (!transUnit) {\r\n                // oops, no translation, must be a new key, so add it\r\n                let newUnit;\r\n                if (this.parameters.allowIdChange()\r\n                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {\r\n                    lastProcessedUnit = newUnit;\r\n                    idChangedCount++;\r\n                } else {\r\n                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n                        masterTransUnit,\r\n                        isDefaultLang,\r\n                        this.parameters.useSourceAsTarget(),\r\n                        (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n                    newCount++;\r\n                }\r\n            } else {\r\n                // check for changed source content and change it if needed\r\n                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.\r\n                if (transUnit.supportsSetSourceContent() && !this.areSourcesNearlyEqual(masterTransUnit, transUnit)) {\r\n                    transUnit.setSourceContent(masterTransUnit.sourceContent());\r\n                    if (isDefaultLang) {\r\n                        // #81 changed source must be copied to target for default lang\r\n                        transUnit.translate(masterTransUnit.sourceContent());\r\n                        transUnit.setTargetState(STATE_FINAL);\r\n                    } else {\r\n                        if (transUnit.targetState() === STATE_FINAL) {\r\n                            // source is changed, so translation has to be checked again\r\n                            transUnit.setTargetState(STATE_TRANSLATED);\r\n                        }\r\n                    }\r\n                    correctSourceContentCount++;\r\n                }\r\n                // check for missing or changed source ref and add it if needed\r\n                if (transUnit.supportsSetSourceReferences()\r\n                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {\r\n                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());\r\n                    correctSourceRefCount++;\r\n                }\r\n                // check for changed description or meaning\r\n                if (transUnit.supportsSetDescriptionAndMeaning()) {\r\n                    let changed = false;\r\n                    if (transUnit.description() !== masterTransUnit.description()) {\r\n                        transUnit.setDescription(masterTransUnit.description());\r\n                        changed = true;\r\n                    }\r\n                    if (transUnit.meaning() !== masterTransUnit.meaning()) {\r\n                        transUnit.setMeaning(masterTransUnit.meaning());\r\n                        changed = true;\r\n                    }\r\n                    if (changed) {\r\n                        correctDescriptionOrMeaningCount++;\r\n                    }\r\n                }\r\n                lastProcessedUnit = transUnit;\r\n            }\r\n        });\r\n        if (newCount > 0) {\r\n            this.commandOutput.warn('merged %s trans-units from master to \"%s\"', newCount, lang);\r\n        }\r\n        if (correctSourceContentCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed source content from master to \"%s\"', correctSourceContentCount, lang);\r\n        }\r\n        if (correctSourceRefCount > 0) {\r\n            this.commandOutput.warn('transferred %s source references from master to \"%s\"', correctSourceRefCount, lang);\r\n        }\r\n        if (idChangedCount > 0) {\r\n            this.commandOutput.warn('found %s changed id\\'s in \"%s\"', idChangedCount, lang);\r\n        }\r\n        if (correctDescriptionOrMeaningCount > 0) {\r\n            this.commandOutput.warn(\r\n                'transferred %s changed descriptions/meanings from master to \"%s\"', correctDescriptionOrMeaningCount, lang);\r\n        }\r\n\r\n        // remove all elements that are no longer used\r\n        let removeCount = 0;\r\n        languageSpecificMessagesFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));\r\n            if (!existsInMaster) {\r\n                if (this.parameters.removeUnusedIds()) {\r\n                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);\r\n                }\r\n                removeCount++;\r\n            }\r\n        });\r\n        if (removeCount > 0) {\r\n            if (this.parameters.removeUnusedIds()) {\r\n                this.commandOutput.warn('removed %s unused trans-units in \"%s\"', removeCount, lang);\r\n            } else {\r\n                this.commandOutput.warn('keeping %s unused trans-units in \"%s\", because removeUnused is disabled', removeCount, lang);\r\n            }\r\n        }\r\n\r\n        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0\r\n            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {\r\n            this.commandOutput.info('file for \"%s\" was up to date', lang);\r\n            return of(null);\r\n        } else {\r\n            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)\r\n                .pipe(map(() => {\r\n                    // write it to file\r\n                    TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n                    this.commandOutput.info('updated file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    if (newCount > 0 && !isDefaultLang) {\r\n                        this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    }\r\n                    return null;\r\n                }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the case of changed id due to small white space changes.\r\n     * @param masterTransUnit unit in master file\r\n     * @param languageSpecificMessagesFile translation file\r\n     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.\r\n     * @return processed unit, if done, null if no changed unit found\r\n     */\r\n    private processChangedIdUnit(\r\n        masterTransUnit: ITransUnit,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile,\r\n        lastProcessedUnit: ITransUnit): ITransUnit {\r\n\r\n        let changedTransUnit: ITransUnit = null;\r\n        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {\r\n             if (this.areSourcesNearlyEqual(languageTransUnit, masterTransUnit)) {\r\n                 changedTransUnit = languageTransUnit;\r\n             }\r\n        });\r\n        if (!changedTransUnit) {\r\n            return null;\r\n        }\r\n        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n            masterTransUnit,\r\n            false,\r\n            false,\r\n            (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n        const translatedContent = changedTransUnit.targetContent();\r\n        if (translatedContent) { // issue #68 set translated only, if it is really translated\r\n            mergedTransUnit.translate(translatedContent);\r\n            mergedTransUnit.setTargetState(STATE_TRANSLATED);\r\n        }\r\n        return mergedTransUnit;\r\n    }\r\n\r\n    /**\r\n     * test wether the sources of 2 trans units are equal ignoring white spaces.\r\n     * @param tu1 tu1\r\n     * @param tu2 tu2\r\n     */\r\n    private areSourcesNearlyEqual(tu1: ITransUnit, tu2: ITransUnit): boolean {\r\n        if ((tu1 && !tu2) || (tu2 && !tu1)) {\r\n            return false;\r\n        }\r\n        const tu1Normalized = tu1.sourceContentNormalized();\r\n        const tu2Normalized = tu2.sourceContentNormalized();\r\n        if (tu1Normalized.isICUMessage()) {\r\n            if (tu2Normalized.isICUMessage()) {\r\n                const icu1Normalized = tu1Normalized.getICUMessage().asNativeString().trim();\r\n                const icu2Normalized = tu2Normalized.getICUMessage().asNativeString().trim();\r\n                return icu1Normalized === icu2Normalized;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        if (tu1Normalized.containsICUMessageRef()) {\r\n            const icuref1Normalized = tu1Normalized.asNativeString().trim();\r\n            const icuref2Normalized = tu2Normalized.asNativeString().trim();\r\n            return icuref1Normalized === icuref2Normalized;\r\n        }\r\n        const s1Normalized = tu1Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        const s2Normalized = tu2Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        return s1Normalized === s2Normalized;\r\n    }\r\n\r\n    private areSourceReferencesEqual(\r\n        ref1: {sourcefile: string; linenumber: number; }[],\r\n        ref2: {sourcefile: string; linenumber: number; }[]): boolean {\r\n\r\n        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {\r\n            return false;\r\n        }\r\n        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {\r\n            return true;\r\n        }\r\n        // bot refs are set now, convert to set to compare them\r\n        const set1: Set<string> = new Set<string>();\r\n        ref1.forEach((ref) => {set1.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        const set2: Set<string> = new Set<string>();\r\n        ref2.forEach((ref) => {set2.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        if (set1.size !== set2.size) {\r\n            return false;\r\n        }\r\n        let match = true;\r\n        set2.forEach((ref) => {\r\n            if (!set1.has(ref)) {\r\n                match = false;\r\n            }\r\n        });\r\n        return match;\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    private autoTranslate(\r\n        from: string,\r\n        to: string,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile): Observable<AutoTranslateSummaryReport> {\r\n\r\n        let serviceCall: Observable<AutoTranslateSummaryReport>;\r\n        const autotranslateEnabled: boolean = this.parameters.autotranslateLanguage(to);\r\n        if (autotranslateEnabled) {\r\n            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);\r\n        } else {\r\n            serviceCall = of(new AutoTranslateSummaryReport(from, to));\r\n        }\r\n        return serviceCall.pipe(map((summary) => {\r\n            if (autotranslateEnabled) {\r\n                if (summary.error() || summary.failed() > 0) {\r\n                    this.commandOutput.error(summary.content());\r\n                } else {\r\n                    this.commandOutput.warn(summary.content());\r\n                }\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n\r\n}\r\n","/*\r\n * Public API Surface of xliffmerge\r\n * In principle, there is only the bin file xliffmerge,\r\n * because this is not mentioned as a library.\r\n * But the tooling uses the configuration file type.\r\n */\r\n\r\n// The module is here only because ng-packagr needs it\r\nexport * from './lib/xliffmerge.module';\r\nexport {IXliffMergeOptions, IConfigFile, ProgramOptions} from './xliffmerge/i-xliff-merge-options';\r\nexport {WriterToString} from './common/writer-to-string';\r\nexport {CommandOutput} from './common/command-output';\r\nexport {XliffMerge} from './xliffmerge/xliff-merge';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":"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"}}}